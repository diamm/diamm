/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/plugins/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./source/js/plugins/manipulation.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./source/js/gesture-events.js":
/*!*************************************!*\
  !*** ./source/js/gesture-events.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    onDoubleClick,\n    onPinch,\n    onDoubleTap\n});\n\nconst DOUBLE_CLICK_TIMEOUT = 500;\nconst DOUBLE_TAP_DISTANCE_THRESHOLD = 50;\nconst DOUBLE_TAP_TIMEOUT = 250;\n\nfunction onDoubleClick(elem, callback)\n{\n    elem.addEventListener('dblclick', function (event)\n    {\n        if (!event.ctrlKey)\n        {\n            callback(event, getRelativeOffset(event.currentTarget, event));\n        }\n    });\n\n    // Handle the control key for macs (in conjunction with double-clicking)\n    // FIXME: Does a click get handled with ctrl pressed on non-Macs?\n    const tracker = createDoubleEventTracker(DOUBLE_CLICK_TIMEOUT);\n\n    elem.addEventListener('contextmenu', function (event)\n    {\n        event.preventDefault();\n\n        if (event.ctrlKey)\n        {\n            if (tracker.isTriggered())\n            {\n                tracker.reset();\n                callback(event, getRelativeOffset(event.currentTarget, event));\n            }\n            else\n            {\n                tracker.trigger();\n            }\n        }\n    });\n}\n\nfunction onPinch(elem, callback)\n{\n    let startDistance = 0;\n\n    elem.addEventListener('touchstart', function (event)\n    {\n        // Prevent mouse event from firing\n        event.preventDefault();\n\n        if (event.originalEvent.touches.length === 2)\n        {\n            startDistance = distance(\n                event.originalEvent.touches[0].clientX,\n                event.originalEvent.touches[0].clientY,\n                event.originalEvent.touches[1].clientX,\n                event.originalEvent.touches[1].clientY\n            );\n        }\n    });\n\n    elem.addEventListener('touchmove', function(event)\n    {\n        // Prevent mouse event from firing\n        event.preventDefault();\n\n        if (event.originalEvent.touches.length === 2)\n        {\n            const touches = event.originalEvent.touches;\n\n            const moveDistance = distance(\n                touches[0].clientX,\n                touches[0].clientY,\n                touches[1].clientX,\n                touches[1].clientY\n            );\n\n            const zoomDelta = moveDistance - startDistance;\n\n            if (Math.abs(zoomDelta) > 0)\n            {\n                const touchCenter = {\n                    pageX: (touches[0].clientX + touches[1].clientX) / 2,\n                    pageY: (touches[0].clientY + touches[1].clientY) / 2\n                };\n\n                callback(event, getRelativeOffset(event.currentTarget, touchCenter), startDistance, moveDistance);\n            }\n        }\n    });\n}\n\nfunction onDoubleTap(elem, callback)\n{\n    const tracker = createDoubleEventTracker(DOUBLE_TAP_TIMEOUT);\n    let firstTap = null;\n\n    elem.addEventListener('touchend', (event) =>\n    {\n        // Prevent mouse event from firing\n        event.preventDefault();\n\n        if (tracker.isTriggered())\n        {\n            tracker.reset();\n\n            // Doubletap has occurred\n            const secondTap = {\n                pageX: event.originalEvent.changedTouches[0].clientX,\n                pageY: event.originalEvent.changedTouches[0].clientY\n            };\n\n            // If first tap is close to second tap (prevents interference with scale event)\n            const tapDistance = distance(firstTap.pageX, firstTap.pageY, secondTap.pageX, secondTap.pageY);\n\n            // TODO: Could give something higher-level than secondTap to callback\n            if (tapDistance < DOUBLE_TAP_DISTANCE_THRESHOLD)\n                callback(event, getRelativeOffset(event.currentTarget, secondTap));\n\n            firstTap = null;\n        }\n        else\n        {\n            firstTap = {\n                pageX: event.originalEvent.changedTouches[0].clientX,\n                pageY: event.originalEvent.changedTouches[0].clientY\n            };\n\n            tracker.trigger();\n        }\n    });\n}\n\n// Pythagorean theorem to get the distance between two points (used for\n// calculating finger distance for double-tap and pinch-zoom)\nfunction distance(x1, y1, x2, y2)\n{\n    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\n\n// Utility to keep track of whether an event has been triggered twice\n// during a a given duration\nfunction createDoubleEventTracker(timeoutDuration)\n{\n    let triggered = false;\n    let timeoutId = null;\n\n    return {\n        trigger()\n        {\n            triggered = true;\n            resetTimeout();\n            timeoutId = setTimeout(function ()\n            {\n                triggered = false;\n                timeoutId = null;\n            }, timeoutDuration);\n        },\n        isTriggered()\n        {\n            return triggered;\n        },\n        reset()\n        {\n            triggered = false;\n            resetTimeout();\n        }\n    };\n\n    function resetTimeout()\n    {\n        if (timeoutId !== null)\n        {\n            clearTimeout(timeoutId);\n            timeoutId = null;\n        }\n    }\n}\n\nfunction getRelativeOffset(elem, pageCoords)\n{\n    const bounds = elem.getBoundingClientRect();\n\n    return {\n        left: pageCoords.pageX - bounds.left,\n        top: pageCoords.pageY - bounds.top\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvZ2VzdHVyZS1ldmVudHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvZ2VzdHVyZS1ldmVudHMuanM/MDVmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB7XG4gICAgb25Eb3VibGVDbGljayxcbiAgICBvblBpbmNoLFxuICAgIG9uRG91YmxlVGFwXG59O1xuXG5jb25zdCBET1VCTEVfQ0xJQ0tfVElNRU9VVCA9IDUwMDtcbmNvbnN0IERPVUJMRV9UQVBfRElTVEFOQ0VfVEhSRVNIT0xEID0gNTA7XG5jb25zdCBET1VCTEVfVEFQX1RJTUVPVVQgPSAyNTA7XG5cbmZ1bmN0aW9uIG9uRG91YmxlQ2xpY2soZWxlbSwgY2FsbGJhY2spXG57XG4gICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGZ1bmN0aW9uIChldmVudClcbiAgICB7XG4gICAgICAgIGlmICghZXZlbnQuY3RybEtleSlcbiAgICAgICAge1xuICAgICAgICAgICAgY2FsbGJhY2soZXZlbnQsIGdldFJlbGF0aXZlT2Zmc2V0KGV2ZW50LmN1cnJlbnRUYXJnZXQsIGV2ZW50KSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSB0aGUgY29udHJvbCBrZXkgZm9yIG1hY3MgKGluIGNvbmp1bmN0aW9uIHdpdGggZG91YmxlLWNsaWNraW5nKVxuICAgIC8vIEZJWE1FOiBEb2VzIGEgY2xpY2sgZ2V0IGhhbmRsZWQgd2l0aCBjdHJsIHByZXNzZWQgb24gbm9uLU1hY3M/XG4gICAgY29uc3QgdHJhY2tlciA9IGNyZWF0ZURvdWJsZUV2ZW50VHJhY2tlcihET1VCTEVfQ0xJQ0tfVElNRU9VVCk7XG5cbiAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKGV2ZW50KVxuICAgIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRyYWNrZXIuaXNUcmlnZ2VyZWQoKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0cmFja2VyLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXZlbnQsIGdldFJlbGF0aXZlT2Zmc2V0KGV2ZW50LmN1cnJlbnRUYXJnZXQsIGV2ZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHJhY2tlci50cmlnZ2VyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gb25QaW5jaChlbGVtLCBjYWxsYmFjaylcbntcbiAgICBsZXQgc3RhcnREaXN0YW5jZSA9IDA7XG5cbiAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQpXG4gICAge1xuICAgICAgICAvLyBQcmV2ZW50IG1vdXNlIGV2ZW50IGZyb20gZmlyaW5nXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0YXJ0RGlzdGFuY2UgPSBkaXN0YW5jZShcbiAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMV0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMV0uY2xpZW50WVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBmdW5jdGlvbihldmVudClcbiAgICB7XG4gICAgICAgIC8vIFByZXZlbnQgbW91c2UgZXZlbnQgZnJvbSBmaXJpbmdcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMilcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdG91Y2hlcyA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcztcblxuICAgICAgICAgICAgY29uc3QgbW92ZURpc3RhbmNlID0gZGlzdGFuY2UoXG4gICAgICAgICAgICAgICAgdG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgICAgICB0b3VjaGVzWzFdLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgdG91Y2hlc1sxXS5jbGllbnRZXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb25zdCB6b29tRGVsdGEgPSBtb3ZlRGlzdGFuY2UgLSBzdGFydERpc3RhbmNlO1xuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoem9vbURlbHRhKSA+IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG91Y2hDZW50ZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VYOiAodG91Y2hlc1swXS5jbGllbnRYICsgdG91Y2hlc1sxXS5jbGllbnRYKSAvIDIsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VZOiAodG91Y2hlc1swXS5jbGllbnRZICsgdG91Y2hlc1sxXS5jbGllbnRZKSAvIDJcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXZlbnQsIGdldFJlbGF0aXZlT2Zmc2V0KGV2ZW50LmN1cnJlbnRUYXJnZXQsIHRvdWNoQ2VudGVyKSwgc3RhcnREaXN0YW5jZSwgbW92ZURpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBvbkRvdWJsZVRhcChlbGVtLCBjYWxsYmFjaylcbntcbiAgICBjb25zdCB0cmFja2VyID0gY3JlYXRlRG91YmxlRXZlbnRUcmFja2VyKERPVUJMRV9UQVBfVElNRU9VVCk7XG4gICAgbGV0IGZpcnN0VGFwID0gbnVsbDtcblxuICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCAoZXZlbnQpID0+XG4gICAge1xuICAgICAgICAvLyBQcmV2ZW50IG1vdXNlIGV2ZW50IGZyb20gZmlyaW5nXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKHRyYWNrZXIuaXNUcmlnZ2VyZWQoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdHJhY2tlci5yZXNldCgpO1xuXG4gICAgICAgICAgICAvLyBEb3VibGV0YXAgaGFzIG9jY3VycmVkXG4gICAgICAgICAgICBjb25zdCBzZWNvbmRUYXAgPSB7XG4gICAgICAgICAgICAgICAgcGFnZVg6IGV2ZW50Lm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICBwYWdlWTogZXZlbnQub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBJZiBmaXJzdCB0YXAgaXMgY2xvc2UgdG8gc2Vjb25kIHRhcCAocHJldmVudHMgaW50ZXJmZXJlbmNlIHdpdGggc2NhbGUgZXZlbnQpXG4gICAgICAgICAgICBjb25zdCB0YXBEaXN0YW5jZSA9IGRpc3RhbmNlKGZpcnN0VGFwLnBhZ2VYLCBmaXJzdFRhcC5wYWdlWSwgc2Vjb25kVGFwLnBhZ2VYLCBzZWNvbmRUYXAucGFnZVkpO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBDb3VsZCBnaXZlIHNvbWV0aGluZyBoaWdoZXItbGV2ZWwgdGhhbiBzZWNvbmRUYXAgdG8gY2FsbGJhY2tcbiAgICAgICAgICAgIGlmICh0YXBEaXN0YW5jZSA8IERPVUJMRV9UQVBfRElTVEFOQ0VfVEhSRVNIT0xEKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50LCBnZXRSZWxhdGl2ZU9mZnNldChldmVudC5jdXJyZW50VGFyZ2V0LCBzZWNvbmRUYXApKTtcblxuICAgICAgICAgICAgZmlyc3RUYXAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZmlyc3RUYXAgPSB7XG4gICAgICAgICAgICAgICAgcGFnZVg6IGV2ZW50Lm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICBwYWdlWTogZXZlbnQub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0cmFja2VyLnRyaWdnZXIoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vLyBQeXRoYWdvcmVhbiB0aGVvcmVtIHRvIGdldCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzICh1c2VkIGZvclxuLy8gY2FsY3VsYXRpbmcgZmluZ2VyIGRpc3RhbmNlIGZvciBkb3VibGUtdGFwIGFuZCBwaW5jaC16b29tKVxuZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpXG57XG4gICAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xufVxuXG4vLyBVdGlsaXR5IHRvIGtlZXAgdHJhY2sgb2Ygd2hldGhlciBhbiBldmVudCBoYXMgYmVlbiB0cmlnZ2VyZWQgdHdpY2Vcbi8vIGR1cmluZyBhIGEgZ2l2ZW4gZHVyYXRpb25cbmZ1bmN0aW9uIGNyZWF0ZURvdWJsZUV2ZW50VHJhY2tlcih0aW1lb3V0RHVyYXRpb24pXG57XG4gICAgbGV0IHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgIGxldCB0aW1lb3V0SWQgPSBudWxsO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHJpZ2dlcigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgICAgICByZXNldFRpbWVvdXQoKTtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgfSwgdGltZW91dER1cmF0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNUcmlnZ2VyZWQoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdHJpZ2dlcmVkO1xuICAgICAgICB9LFxuICAgICAgICByZXNldCgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmVzZXRUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVzZXRUaW1lb3V0KClcbiAgICB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQgIT09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgdGltZW91dElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVPZmZzZXQoZWxlbSwgcGFnZUNvb3JkcylcbntcbiAgICBjb25zdCBib3VuZHMgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogcGFnZUNvb3Jkcy5wYWdlWCAtIGJvdW5kcy5sZWZ0LFxuICAgICAgICB0b3A6IHBhZ2VDb29yZHMucGFnZVkgLSBib3VuZHMudG9wXG4gICAgfTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./source/js/gesture-events.js\n");

/***/ }),

/***/ "./source/js/plugins/_filters.js":
/*!***************************************!*\
  !*** ./source/js/plugins/_filters.js ***!
  \***************************************/
/*! exports provided: resetFilters, addFilterToQueue, grayscale, saturation, vibrance, brightness, contrast, invert, threshold, hue, gamma, ccRed, ccGreen, ccBlue, rgbToHSV, hsvToRGB, sharpen */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resetFilters\", function() { return resetFilters; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addFilterToQueue\", function() { return addFilterToQueue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"grayscale\", function() { return grayscale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"saturation\", function() { return saturation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vibrance\", function() { return vibrance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"brightness\", function() { return brightness; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"contrast\", function() { return contrast; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"threshold\", function() { return threshold; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hue\", function() { return hue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"gamma\", function() { return gamma; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ccRed\", function() { return ccRed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ccGreen\", function() { return ccGreen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ccBlue\", function() { return ccBlue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rgbToHSV\", function() { return rgbToHSV; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hsvToRGB\", function() { return hsvToRGB; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sharpen\", function() { return sharpen; });\n\n// stores an array of objects, each object stores the function, image data, adjust to apply, and name\nlet _filterQueue = [];\n// stores whether the invert filter was used (for if it should be reapplied)\nlet inverted = false;\n\nfunction resetFilters ()\n{\n    _filterQueue = [];\n    inverted = false;\n}\n\n// Add a filter to the array. If it is new, apply the filter's function to the image data of\n// the previous filter's returned image data (or the default image data if it's the first filter),\n// and return this new image data. Pass string 'name' since function.name with minifiedJS = bad\n// Threshold is exclusive to other filters and vice versa\nfunction addFilterToQueue (data, filter, adjust, name)\n{\n    // index of the filter in the queue, -1 if not found\n    let index = _filterQueue.findIndex(f => f.filter.name === filter.name);\n    if (index !== -1) // adjust a filter already in the queue\n    {\n        let filtObj = _filterQueue[index];\n        filtObj.adjust = adjust;\n        \n        // all filters except sharpness use _apply (from within their private function 'filter')\n        // whereas sharpness uses convolve, so need to check (ie. can't generalize for all filters)\n        if (filtObj.name === 'Sharpness')\n        {\n            // if adjust[1] is 0, then sharpness should be reset (cancelled)\n            if (filtObj.adjust[1] === 0)\n                filtObj.postData = filtObj.prevData;\n            else\n                filtObj.postData = convolve(filtObj.prevData, filtObj.adjust);\n        }\n        else if (filtObj.name === 'Invert')\n        {\n            // invert filter should toggle, so use post-alteration image data\n            filtObj.postData = _apply(filtObj.postData, filtObj.filter, filtObj.adjust);\n            inverted = !inverted;\n        }\n        else \n            filtObj.postData = _apply(filtObj.prevData, filtObj.filter, filtObj.adjust);\n\n        // reapply all filters that come after in the queue\n        for (let i = index + 1, len = _filterQueue.length; i < len; i++)\n        {\n            let otherFiltObj = _filterQueue[i];\n\n            if (otherFiltObj.name === 'Invert' && !inverted) // don't reinvert the image\n                continue;\n\n            otherFiltObj.prevData = _filterQueue[i - 1].postData; // starts at filt\n\n            if (otherFiltObj.name === 'Sharpness')\n                if (otherFiltObj.adjust[1] === 0)\n                    otherFiltObj.postData = otherFiltObj.prevData;\n                else\n                    otherFiltObj.postData = convolve(otherFiltObj.prevData, otherFiltObj.adjust);\n            else \n                otherFiltObj.postData = _apply(otherFiltObj.prevData, otherFiltObj.filter, otherFiltObj.adjust);\n\n            if (i === len - 1) // last filter\n                return otherFiltObj.postData;\n        }\n\n        // only two filters in queue and second was modified\n        return filtObj.postData; \n    }\n    else // add new filter to the queue\n    {\n        // handle threshold uniqueness\n        if (name === 'Threshold' || (_filterQueue[0] && _filterQueue[0].name === 'Threshold'))\n        {\n            // reset filter queue\n            resetFilters();\n\n            // reset appropriate sliders\n            let tools = document.getElementsByClassName('manipulation-tools')[0];\n            for (let i = 0, len = tools.children.length; i < len; i++)\n            {\n                let tool = tools.children[i].children[0];\n\n                if (tool && tool.type === 'range')\n                {\n                    let isThreshold = tool.parentElement.textContent.includes('Threshold');\n                    let isZoom = tool.parentElement.textContent.includes('Zoom');\n                    let isRotate = tool.parentElement.textContent.includes('Rotation');\n\n                    if (name === 'Threshold' && !isThreshold && !isZoom && !isRotate) // reset all except\n                        tool.value = 0;\n                    else if (name !== 'Threshold' && isThreshold) // reset only threshold\n                        tool.value = 0;\n                }\n            }\n\n            // reset log\n            document.getElementById('filter-log').innerHTML = \"<h3> Filter Application Order <h3>\";\n        }\n\n        _filterQueue.push({\n            filter: filter,\n            prevData: _filterQueue.length === 0 ? data : _filterQueue[_filterQueue.length - 1].postData,\n            adjust: adjust,\n            name: name\n        });\n\n        let filtObj = _filterQueue[_filterQueue.length - 1];\n\n        if (filtObj.name === 'Sharpness')\n            filtObj.postData = convolve(filtObj.prevData, filtObj.adjust);\n        else \n            filtObj.postData = _apply(filtObj.prevData, filtObj.filter, filtObj.adjust);\n\n        // invert filter was added to queue\n        if (filtObj.name === 'Invert')\n            inverted = true;\n\n        // add name to applied filters log\n        let p = document.createElement('p');\n        p.setAttribute('style', 'color: white; margin: 0;');\n        p.innerText = filtObj.name;\n        document.getElementById('filter-log').appendChild(p);\n\n        return filtObj.postData;\n    }\n}\n\n/**\n * Pre-paints the adjustment to an offscreen canvas before moving it to the on-screen canvas.\n **/\nfunction _getOffscreenCanvasData (w, h)\n{\n    let tmpCanvas = document.createElement('canvas');\n    let tmpCtx = tmpCanvas.getContext('2d');\n\n    return tmpCtx.createImageData(w, h);\n}\n\nfunction _manipulateImage (data, func, adjustment)\n{\n    let len = data.length;\n\n    for (let i = 0; i < len; i += 4)\n    {\n        let r = data[i];\n        let g = data[i + 1];\n        let b = data[i + 2];\n\n        let newPixelValue = func(r, g, b, adjustment);\n\n        data[i] = newPixelValue[0];\n        data[i + 1] = newPixelValue[1];\n        data[i + 2] = newPixelValue[2];\n        data[i + 3] = newPixelValue[3];\n    }\n\n    return data;\n}\n\nfunction _apply (data, pixelFunc, adjust)\n{\n    let dataArr = new Uint8ClampedArray(data.data);\n    let inverted = _manipulateImage(dataArr, pixelFunc, adjust);\n\n    let newCanvasData = _getOffscreenCanvasData(data.width, data.height);\n    newCanvasData.data.set(inverted);\n\n    return newCanvasData;\n}\n\n/**\n * Inverts the colours of a canvas.\n *\n * @params {object} data - A canvas image data object.\n * @returns {object} A new canvas data object.\n **/\nfunction grayscale(data)\n{\n    return addFilterToQueue(data, _grayscale, null, 'Grayscale');\n}\n\n/**\n * See: https://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n *\n * Reference: http://www.phpied.com/image-fun/ and https://github.com/meltingice/CamanJS/blob/master/src/lib/filters.coffee#L89\n *\n * @params {integer} r - the value of the red pixel\n * @params {integer} g - the value of the green pixel\n * @params {integer} b - the value of the blue pixel\n * @returns {Array} - The computed RGB values for the input, with a constant 255 for the alpha channel.\n **/\nfunction _grayscale (r, g, b)\n{\n    let pixelAverage = (0.3 * r + 0.59 * g + 0.11 * b);\n\n    return [pixelAverage, pixelAverage, pixelAverage, 255];\n}\n\nfunction saturation (data, adjust)\n{\n    return addFilterToQueue(data, _saturation, adjust, 'Saturation');\n}\n\n/**\n * Adjusts the color saturation of the image.\n * Range is -100 to 100. Values < 0 will desaturate the image while values > 0 will saturate it.\n *\n * See https://github.com/meltingice/CamanJS/blob/master/src/lib/filters.coffee#L42-L58\n *\n * @params {integer} r - the value of the red pixel\n * @params {integer} g - the value of the green pixel\n * @params {integer} b - the value of the blue pixel\n * @params {integer} adjust - the saturation value for adjustment, -100 to 100\n * @returns {Array} - The computed RGB values for the input, with a constant 255 for the alpha channel.\n **/\nfunction _saturation (r, g, b, adjust)\n{\n    let adj = adjust * -0.01;\n    let max = Math.max(r, g, b);\n\n    return [\n        r !== max ? r + (max - r) * adj : r,\n        g !== max ? g + (max - g) * adj : g,\n        b !== max ? b + (max - b) * adj : b,\n        255\n    ];\n}\n\nfunction vibrance (data, adjust)\n{\n    return addFilterToQueue(data, _vibrance, adjust, 'Vibrance');\n}\n\n/**\n * Similar to saturation, but adjusts the saturation levels in a slightly smarter, more subtle way.\n * Vibrance will attempt to boost colors that are less saturated more and boost already saturated\n * colors less, while saturation boosts all colors by the same level.\n *\n * See: https://github.com/meltingice/CamanJS/blob/master/src/lib/filters.coffee#L60\n *\n * @params {integer} r - the value of the red pixel\n * @params {integer} g - the value of the green pixel\n * @params {integer} b - the value of the blue pixel\n * @params {integer} adjust - the vibrance value for adjustment, -100 to 100\n * @returns {Array} - The computed RGB values for the input, with a constant 255 for the alpha channel.\n **/\nfunction _vibrance (r, g, b, adjust)\n{\n    let adj = adjust * -1;\n\n    let max = Math.max(r, g, b);\n    let avg = r + g + b / 3;\n    let amt = ((Math.abs(max - avg) * 2 / 255) * adj) / 100;\n\n    return [\n        r !== max ? r + (max - r) * amt : r,\n        g !== max ? g + (max - g) * amt : g,\n        b !== max ? b + (max - b) * amt : b,\n        255\n    ];\n}\n\nfunction brightness (data, adjust)\n{\n    return addFilterToQueue(data, _brightness, adjust, 'Brightness');\n}\n\nfunction _brightness (r, g, b, adjust)\n{\n    let adj = Math.floor(255 * (adjust / 100));\n\n    return [\n        r + adj,\n        g + adj,\n        b + adj,\n        255\n    ];\n}\n\nfunction contrast (data, adjust)\n{\n    return addFilterToQueue(data, _contrast, adjust, 'Contrast');\n}\n\n/**\n * Increases or decreases the color contrast of the image.\n *\n * @params {integer} r - the value of the red pixel\n * @params {integer} g - the value of the green pixel\n * @params {integer} b - the value of the blue pixel\n * @params {integer} adjust - the contrast value for adjustment, -100 to 100\n * @returns {Array} - The computed RGB values for the input, with a constant 255 for the alpha channel.\n **/\nfunction _contrast (r, g, b, adjust)\n{\n    let adj = Math.pow((adjust + 100) / 100, 2);\n    let rr = r, gg = g, bb = b;\n\n    rr /= 255;\n    rr -= 0.5;\n    rr *= adj;\n    rr += 0.5;\n    rr *= 255;\n\n    gg /= 255;\n    gg -= 0.5;\n    gg *= adj;\n    gg += 0.5;\n    gg *= 255;\n\n    bb /= 255;\n    bb -= 0.5;\n    bb *= adj;\n    bb += 0.5;\n    bb *= 255;\n\n    return [\n        rr, gg, bb, 255\n    ];\n}\n/**\n * Inverts the colours of a canvas.\n *\n * @params {object} data - A canvas image data object.\n * @returns {object} A new canvas data object.\n **/\nfunction invert(data)\n{\n    return addFilterToQueue(data, _invert, null, 'Invert');\n}\n\n/**\n * Inverts the colours of the image.\n * See: https://github.com/meltingice/CamanJS/blob/master/src/lib/filters.coffee#L183\n *\n * @params {integer} r - the value of the red pixel\n * @params {integer} g - the value of the green pixel\n * @params {integer} b - the value of the blue pixel\n * @returns {Array} - The computed RGB values for the input, with a constant 255 for the alpha channel.\n **/\nfunction _invert (r, g, b)\n{\n    return [\n        255 - r,\n        255 - g,\n        255 - b,\n        255\n    ];\n}\n\nfunction threshold(data, adjust)\n{\n    return addFilterToQueue(data, _threshold, adjust, 'Threshold');\n}\n\n/**\n * Black pixels above a certain value (0-255); otherwise white. Perceptively weighted.\n *\n * See: https://www.html5rocks.com/en/tutorials/canvas/imagefilters/\n *\n * @params {integer} r - the value of the red pixel\n * @params {integer} g - the value of the green pixel\n * @params {integer} b - the value of the blue pixel\n * @params {integer} adjust - the threshold value, 0-255\n * @returns {Array} - The computed RGB values for the input, with a constant 255 for the alpha channel.\n **/\nfunction _threshold (r, g, b, adjust)\n{\n    let v = (0.2126 * r + 0.7152 * g + 0.0722 * b >= adjust) ? 255 : 0;\n\n    return [\n        v, v, v, 255\n    ];\n\n}\n\nfunction hue (data, adjust)\n{\n    return addFilterToQueue(data, _hue, adjust, 'Hue');\n}\n\nfunction _hue (r, g, b, adjust)\n{\n    let {h, s, v} = rgbToHSV(r, g, b);\n\n    h = h * 100;\n    h += Math.abs(adjust);\n    h = h % 100;\n    h /= 100;\n\n    let res = hsvToRGB(h, s, v);\n\n    return [\n        res.r, res.g, res.b, 255\n    ];\n}\n\nfunction gamma (data, adjust)\n{\n    return addFilterToQueue(data, _gamma, adjust, 'Gamma');\n}\n\n/**\n * Adjusts the gamma of the image.\n * Range is 0 to 4. Values between 0 and 1 will lessen the contrast while values greater\n * than 1 will increase it. Starts at 1 default. The actual adjust slider is from -100 to\n * 300 (so default can be 0 and offset accordingly), so must scale properly\n * See https://github.com/meltingice/CamanJS/blob/master/src/lib/filters.coffee#L210-L221\n *\n * @params {integer} r - the value of the red pixel\n * @params {integer} g - the value of the green pixel\n * @params {integer} b - the value of the blue pixel\n * @params {integer} adjust - the gamma value for adjustment, 0 to 400\n * @returns {Array} - The computed RGB values for the input, with a constant 255 for the alpha channel.\n **/\nfunction _gamma (r, g, b, adjust)\n{\n    let adj = adjust / 100 + 1;\n    if (adj < 0)\n        adj *= -1;\n\n    return [\n        Math.pow(r / 255, adj) * 255,\n        Math.pow(g / 255, adj) * 255,\n        Math.pow(b / 255, adj) * 255,\n        255\n    ];\n}\n\nfunction ccRed (data, adjust)\n{\n    return addFilterToQueue(data, _ccRed, adjust, 'CC Red');\n}\n\n/** \n * Adjusts the red intensity of the image.\n *\n * See https://github.com/meltingice/CamanJS/blob/master/src/lib/filters.coffee#L274-L305\n *\n * @params {integer} r - the value of the red pixel\n * @params {integer} g - the value of the green pixel\n * @params {integer} b - the value of the blue pixel\n * @params {integer} adjust - the red value for adjustment, -100 to 100\n * @returns {Array} - The computed RGB values for the input, with a constant 255 for the alpha channel.\n */ \nfunction _ccRed (r, g, b, adjust)\n{\n    let adj = adjust / 100;\n\n    return [\n        adj > 0 ? r + (255 - r) * adj : r - r * Math.abs(adj),\n        g,\n        b,\n        255\n    ];\n}\n\nfunction ccGreen (data, adjust)\n{\n    return addFilterToQueue(data, _ccGreen, adjust, 'CC Green');\n}\n\n/** \n * Adjusts the green intensity of the image.\n *\n * See https://github.com/meltingice/CamanJS/blob/master/src/lib/filters.coffee#L274-L305\n *\n * @params {integer} r - the value of the red pixel\n * @params {integer} g - the value of the green pixel\n * @params {integer} b - the value of the blue pixel\n * @params {integer} adjust - the green value for adjustment, -100 to 100\n * @returns {Array} - The computed RGB values for the input, with a constant 255 for the alpha channel.\n */ \nfunction _ccGreen (r, g, b, adjust)\n{\n    let adj = adjust / 100;\n\n    return [\n        r,\n        adj > 0 ? g + (255 - g) * adj : g - g * Math.abs(adj),\n        b,\n        255\n    ];\n}\n\nfunction ccBlue (data, adjust)\n{\n    return addFilterToQueue(data, _ccBlue, adjust, 'CC Blue');\n}\n\n/** \n * Adjusts the blue intensity of the image.\n *\n * See https://github.com/meltingice/CamanJS/blob/master/src/lib/filters.coffee#L274-L305\n *\n * @params {integer} r - the value of the red pixel\n * @params {integer} g - the value of the green pixel\n * @params {integer} b - the value of the blue pixel\n * @params {integer} adjust - the blue value for adjustment, -100 to 100\n * @returns {Array} - The computed RGB values for the input, with a constant 255 for the alpha channel.\n */ \nfunction _ccBlue (r, g, b, adjust)\n{\n    let adj = adjust / 100;\n\n    return [\n        r,\n        g,\n        adj > 0 ? b + (255 - b) * adj : b - b * Math.abs(adj),\n        255\n    ];\n}\n\nfunction rgbToHSV (r, g, b)\n{\n    let rr = r, gg = g, bb = b;\n\n    rr /= 255;\n    gg /= 255;\n    bb /= 255;\n\n    let max = Math.max(rr, gg, bb);\n    let min = Math.min(rr, gg, bb);\n    let v = max;\n    let d = max - min;\n\n    let s = max === 0 ? 0 : d / max;\n    let h;\n\n    if (max === min)\n        h = 0;\n    else\n    {\n        switch (max)\n        {\n            case rr:\n                h = (gg - bb) / d + (gg < bb ? 6 : 0);\n                break;\n            case gg:\n                h = (bb - rr) / d + 2;\n                break;\n            case bb:\n                h = (rr - gg) / d + 4;\n                break;\n        }\n\n        h /= 6;\n    }\n\n    return {h, s, v};\n}\n\nfunction hsvToRGB (h, s, v)\n{\n    let b, f, g, i, p, q, r, t;\n    i = Math.floor(h * 6);\n    f = h * 6 - i;\n    p = v * (1 - s);\n    q = v * (1 - f * s);\n    t = v * (1 - (1 - f) * s);\n\n    switch (i % 6)\n    {\n        case 0:\n            r = v;\n            g = t;\n            b = p;\n            break;\n        case 1:\n            r = q;\n            g = v;\n            b = p;\n            break;\n        case 2:\n            r = p;\n            g = v;\n            b = t;\n            break;\n        case 3:\n            r = p;\n            g = q;\n            b = v;\n            break;\n        case 4:\n            r = t;\n            g = p;\n            b = v;\n            break;\n        case 5:\n            r = v;\n            g = p;\n            b = q;\n            break;\n    }\n\n    return {\n        r: Math.floor(r * 255),\n        g: Math.floor(g * 255),\n        b: Math.floor(b * 255)\n    };\n}\n\n\n/*********************************************\n    Convolution filters\n *********************************************/\n\nfunction convolve (data, weights, opaque)\n{\n    let side = Math.round(Math.sqrt(weights.length));\n    let halfSide = Math.floor(side / 2);\n\n    let srcData = data.data;\n    let sw = data.width;\n    let sh = data.height;\n    let w = sw;\n    let h = sh;\n\n    let output = _getOffscreenCanvasData(w, h);\n    let dst = output.data;\n\n    let alphaFac = opaque ? 1 : 0;\n\n    for (let y = 0; y < h; y++)\n    {\n        for (let x = 0; x < w; x++)\n        {\n            let sy = y;\n            let sx = x;\n            let dstOff = (y * w + x) * 4;\n\n            let r = 0, g = 0, b = 0, a = 0;\n\n            for (let cy = 0; cy < side; cy++)\n            {\n                for (let cx = 0; cx < side; cx++)\n                {\n                    let scy = sy + cy - halfSide;\n                    let scx = sx + cx - halfSide;\n\n                    if (scy >= 0 && scy < sh && scx >= 0 && scx < sw)\n                    {\n                        let srcOff = (scy * sw + scx) * 4;\n                        let wt = weights[cy * side + cx];\n                        r += srcData[srcOff] * wt;\n                        g += srcData[srcOff + 1] * wt;\n                        b += srcData[srcOff + 2] * wt;\n                        a += srcData[srcOff + 3] * wt;\n                    }\n                }\n            }\n\n            dst[dstOff] = r;\n            dst[dstOff + 1] = g;\n            dst[dstOff + 2] = b;\n            dst[dstOff + 3] = a + alphaFac * (255 - a);\n        }\n    }\n    return output;\n}\n\n\nfunction sharpen (data, adjust)\n{\n    let adj = adjust ? adjust : 100;\n    adj /= 100;\n\n    if (adjust === 0) // reset value\n        adj = 0;\n\n    let weights = [\n        0, -adj, 0,\n        -adj, 4 * adj + 1, -adj,\n        0, -adj, 0\n    ];\n\n    return addFilterToQueue(data, convolve, weights, 'Sharpness');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvcGx1Z2lucy9fZmlsdGVycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NvdXJjZS9qcy9wbHVnaW5zL19maWx0ZXJzLmpzPzQxYmMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBzdG9yZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cywgZWFjaCBvYmplY3Qgc3RvcmVzIHRoZSBmdW5jdGlvbiwgaW1hZ2UgZGF0YSwgYWRqdXN0IHRvIGFwcGx5LCBhbmQgbmFtZVxubGV0IF9maWx0ZXJRdWV1ZSA9IFtdO1xuLy8gc3RvcmVzIHdoZXRoZXIgdGhlIGludmVydCBmaWx0ZXIgd2FzIHVzZWQgKGZvciBpZiBpdCBzaG91bGQgYmUgcmVhcHBsaWVkKVxubGV0IGludmVydGVkID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldEZpbHRlcnMgKClcbntcbiAgICBfZmlsdGVyUXVldWUgPSBbXTtcbiAgICBpbnZlcnRlZCA9IGZhbHNlO1xufVxuXG4vLyBBZGQgYSBmaWx0ZXIgdG8gdGhlIGFycmF5LiBJZiBpdCBpcyBuZXcsIGFwcGx5IHRoZSBmaWx0ZXIncyBmdW5jdGlvbiB0byB0aGUgaW1hZ2UgZGF0YSBvZlxuLy8gdGhlIHByZXZpb3VzIGZpbHRlcidzIHJldHVybmVkIGltYWdlIGRhdGEgKG9yIHRoZSBkZWZhdWx0IGltYWdlIGRhdGEgaWYgaXQncyB0aGUgZmlyc3QgZmlsdGVyKSxcbi8vIGFuZCByZXR1cm4gdGhpcyBuZXcgaW1hZ2UgZGF0YS4gUGFzcyBzdHJpbmcgJ25hbWUnIHNpbmNlIGZ1bmN0aW9uLm5hbWUgd2l0aCBtaW5pZmllZEpTID0gYmFkXG4vLyBUaHJlc2hvbGQgaXMgZXhjbHVzaXZlIHRvIG90aGVyIGZpbHRlcnMgYW5kIHZpY2UgdmVyc2FcbmV4cG9ydCBmdW5jdGlvbiBhZGRGaWx0ZXJUb1F1ZXVlIChkYXRhLCBmaWx0ZXIsIGFkanVzdCwgbmFtZSlcbntcbiAgICAvLyBpbmRleCBvZiB0aGUgZmlsdGVyIGluIHRoZSBxdWV1ZSwgLTEgaWYgbm90IGZvdW5kXG4gICAgbGV0IGluZGV4ID0gX2ZpbHRlclF1ZXVlLmZpbmRJbmRleChmID0+IGYuZmlsdGVyLm5hbWUgPT09IGZpbHRlci5uYW1lKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSAvLyBhZGp1c3QgYSBmaWx0ZXIgYWxyZWFkeSBpbiB0aGUgcXVldWVcbiAgICB7XG4gICAgICAgIGxldCBmaWx0T2JqID0gX2ZpbHRlclF1ZXVlW2luZGV4XTtcbiAgICAgICAgZmlsdE9iai5hZGp1c3QgPSBhZGp1c3Q7XG4gICAgICAgIFxuICAgICAgICAvLyBhbGwgZmlsdGVycyBleGNlcHQgc2hhcnBuZXNzIHVzZSBfYXBwbHkgKGZyb20gd2l0aGluIHRoZWlyIHByaXZhdGUgZnVuY3Rpb24gJ2ZpbHRlcicpXG4gICAgICAgIC8vIHdoZXJlYXMgc2hhcnBuZXNzIHVzZXMgY29udm9sdmUsIHNvIG5lZWQgdG8gY2hlY2sgKGllLiBjYW4ndCBnZW5lcmFsaXplIGZvciBhbGwgZmlsdGVycylcbiAgICAgICAgaWYgKGZpbHRPYmoubmFtZSA9PT0gJ1NoYXJwbmVzcycpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGlmIGFkanVzdFsxXSBpcyAwLCB0aGVuIHNoYXJwbmVzcyBzaG91bGQgYmUgcmVzZXQgKGNhbmNlbGxlZClcbiAgICAgICAgICAgIGlmIChmaWx0T2JqLmFkanVzdFsxXSA9PT0gMClcbiAgICAgICAgICAgICAgICBmaWx0T2JqLnBvc3REYXRhID0gZmlsdE9iai5wcmV2RGF0YTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmaWx0T2JqLnBvc3REYXRhID0gY29udm9sdmUoZmlsdE9iai5wcmV2RGF0YSwgZmlsdE9iai5hZGp1c3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbHRPYmoubmFtZSA9PT0gJ0ludmVydCcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGludmVydCBmaWx0ZXIgc2hvdWxkIHRvZ2dsZSwgc28gdXNlIHBvc3QtYWx0ZXJhdGlvbiBpbWFnZSBkYXRhXG4gICAgICAgICAgICBmaWx0T2JqLnBvc3REYXRhID0gX2FwcGx5KGZpbHRPYmoucG9zdERhdGEsIGZpbHRPYmouZmlsdGVyLCBmaWx0T2JqLmFkanVzdCk7XG4gICAgICAgICAgICBpbnZlcnRlZCA9ICFpbnZlcnRlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIFxuICAgICAgICAgICAgZmlsdE9iai5wb3N0RGF0YSA9IF9hcHBseShmaWx0T2JqLnByZXZEYXRhLCBmaWx0T2JqLmZpbHRlciwgZmlsdE9iai5hZGp1c3QpO1xuXG4gICAgICAgIC8vIHJlYXBwbHkgYWxsIGZpbHRlcnMgdGhhdCBjb21lIGFmdGVyIGluIHRoZSBxdWV1ZVxuICAgICAgICBmb3IgKGxldCBpID0gaW5kZXggKyAxLCBsZW4gPSBfZmlsdGVyUXVldWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBvdGhlckZpbHRPYmogPSBfZmlsdGVyUXVldWVbaV07XG5cbiAgICAgICAgICAgIGlmIChvdGhlckZpbHRPYmoubmFtZSA9PT0gJ0ludmVydCcgJiYgIWludmVydGVkKSAvLyBkb24ndCByZWludmVydCB0aGUgaW1hZ2VcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgb3RoZXJGaWx0T2JqLnByZXZEYXRhID0gX2ZpbHRlclF1ZXVlW2kgLSAxXS5wb3N0RGF0YTsgLy8gc3RhcnRzIGF0IGZpbHRcblxuICAgICAgICAgICAgaWYgKG90aGVyRmlsdE9iai5uYW1lID09PSAnU2hhcnBuZXNzJylcbiAgICAgICAgICAgICAgICBpZiAob3RoZXJGaWx0T2JqLmFkanVzdFsxXSA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJGaWx0T2JqLnBvc3REYXRhID0gb3RoZXJGaWx0T2JqLnByZXZEYXRhO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJGaWx0T2JqLnBvc3REYXRhID0gY29udm9sdmUob3RoZXJGaWx0T2JqLnByZXZEYXRhLCBvdGhlckZpbHRPYmouYWRqdXN0KTtcbiAgICAgICAgICAgIGVsc2UgXG4gICAgICAgICAgICAgICAgb3RoZXJGaWx0T2JqLnBvc3REYXRhID0gX2FwcGx5KG90aGVyRmlsdE9iai5wcmV2RGF0YSwgb3RoZXJGaWx0T2JqLmZpbHRlciwgb3RoZXJGaWx0T2JqLmFkanVzdCk7XG5cbiAgICAgICAgICAgIGlmIChpID09PSBsZW4gLSAxKSAvLyBsYXN0IGZpbHRlclxuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlckZpbHRPYmoucG9zdERhdGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbmx5IHR3byBmaWx0ZXJzIGluIHF1ZXVlIGFuZCBzZWNvbmQgd2FzIG1vZGlmaWVkXG4gICAgICAgIHJldHVybiBmaWx0T2JqLnBvc3REYXRhOyBcbiAgICB9XG4gICAgZWxzZSAvLyBhZGQgbmV3IGZpbHRlciB0byB0aGUgcXVldWVcbiAgICB7XG4gICAgICAgIC8vIGhhbmRsZSB0aHJlc2hvbGQgdW5pcXVlbmVzc1xuICAgICAgICBpZiAobmFtZSA9PT0gJ1RocmVzaG9sZCcgfHwgKF9maWx0ZXJRdWV1ZVswXSAmJiBfZmlsdGVyUXVldWVbMF0ubmFtZSA9PT0gJ1RocmVzaG9sZCcpKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyByZXNldCBmaWx0ZXIgcXVldWVcbiAgICAgICAgICAgIHJlc2V0RmlsdGVycygpO1xuXG4gICAgICAgICAgICAvLyByZXNldCBhcHByb3ByaWF0ZSBzbGlkZXJzXG4gICAgICAgICAgICBsZXQgdG9vbHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdtYW5pcHVsYXRpb24tdG9vbHMnKVswXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0b29scy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9vbCA9IHRvb2xzLmNoaWxkcmVuW2ldLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRvb2wgJiYgdG9vbC50eXBlID09PSAncmFuZ2UnKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzVGhyZXNob2xkID0gdG9vbC5wYXJlbnRFbGVtZW50LnRleHRDb250ZW50LmluY2x1ZGVzKCdUaHJlc2hvbGQnKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzWm9vbSA9IHRvb2wucGFyZW50RWxlbWVudC50ZXh0Q29udGVudC5pbmNsdWRlcygnWm9vbScpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNSb3RhdGUgPSB0b29sLnBhcmVudEVsZW1lbnQudGV4dENvbnRlbnQuaW5jbHVkZXMoJ1JvdGF0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdUaHJlc2hvbGQnICYmICFpc1RocmVzaG9sZCAmJiAhaXNab29tICYmICFpc1JvdGF0ZSkgLy8gcmVzZXQgYWxsIGV4Y2VwdFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbC52YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgIT09ICdUaHJlc2hvbGQnICYmIGlzVGhyZXNob2xkKSAvLyByZXNldCBvbmx5IHRocmVzaG9sZFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbC52YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXNldCBsb2dcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWx0ZXItbG9nJykuaW5uZXJIVE1MID0gXCI8aDM+IEZpbHRlciBBcHBsaWNhdGlvbiBPcmRlciA8aDM+XCI7XG4gICAgICAgIH1cblxuICAgICAgICBfZmlsdGVyUXVldWUucHVzaCh7XG4gICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgICAgIHByZXZEYXRhOiBfZmlsdGVyUXVldWUubGVuZ3RoID09PSAwID8gZGF0YSA6IF9maWx0ZXJRdWV1ZVtfZmlsdGVyUXVldWUubGVuZ3RoIC0gMV0ucG9zdERhdGEsXG4gICAgICAgICAgICBhZGp1c3Q6IGFkanVzdCxcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGZpbHRPYmogPSBfZmlsdGVyUXVldWVbX2ZpbHRlclF1ZXVlLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChmaWx0T2JqLm5hbWUgPT09ICdTaGFycG5lc3MnKVxuICAgICAgICAgICAgZmlsdE9iai5wb3N0RGF0YSA9IGNvbnZvbHZlKGZpbHRPYmoucHJldkRhdGEsIGZpbHRPYmouYWRqdXN0KTtcbiAgICAgICAgZWxzZSBcbiAgICAgICAgICAgIGZpbHRPYmoucG9zdERhdGEgPSBfYXBwbHkoZmlsdE9iai5wcmV2RGF0YSwgZmlsdE9iai5maWx0ZXIsIGZpbHRPYmouYWRqdXN0KTtcblxuICAgICAgICAvLyBpbnZlcnQgZmlsdGVyIHdhcyBhZGRlZCB0byBxdWV1ZVxuICAgICAgICBpZiAoZmlsdE9iai5uYW1lID09PSAnSW52ZXJ0JylcbiAgICAgICAgICAgIGludmVydGVkID0gdHJ1ZTtcblxuICAgICAgICAvLyBhZGQgbmFtZSB0byBhcHBsaWVkIGZpbHRlcnMgbG9nXG4gICAgICAgIGxldCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgICAgICBwLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnY29sb3I6IHdoaXRlOyBtYXJnaW46IDA7Jyk7XG4gICAgICAgIHAuaW5uZXJUZXh0ID0gZmlsdE9iai5uYW1lO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlsdGVyLWxvZycpLmFwcGVuZENoaWxkKHApO1xuXG4gICAgICAgIHJldHVybiBmaWx0T2JqLnBvc3REYXRhO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQcmUtcGFpbnRzIHRoZSBhZGp1c3RtZW50IHRvIGFuIG9mZnNjcmVlbiBjYW52YXMgYmVmb3JlIG1vdmluZyBpdCB0byB0aGUgb24tc2NyZWVuIGNhbnZhcy5cbiAqKi9cbmZ1bmN0aW9uIF9nZXRPZmZzY3JlZW5DYW52YXNEYXRhICh3LCBoKVxue1xuICAgIGxldCB0bXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBsZXQgdG1wQ3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICByZXR1cm4gdG1wQ3R4LmNyZWF0ZUltYWdlRGF0YSh3LCBoKTtcbn1cblxuZnVuY3Rpb24gX21hbmlwdWxhdGVJbWFnZSAoZGF0YSwgZnVuYywgYWRqdXN0bWVudClcbntcbiAgICBsZXQgbGVuID0gZGF0YS5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA0KVxuICAgIHtcbiAgICAgICAgbGV0IHIgPSBkYXRhW2ldO1xuICAgICAgICBsZXQgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICBsZXQgYiA9IGRhdGFbaSArIDJdO1xuXG4gICAgICAgIGxldCBuZXdQaXhlbFZhbHVlID0gZnVuYyhyLCBnLCBiLCBhZGp1c3RtZW50KTtcblxuICAgICAgICBkYXRhW2ldID0gbmV3UGl4ZWxWYWx1ZVswXTtcbiAgICAgICAgZGF0YVtpICsgMV0gPSBuZXdQaXhlbFZhbHVlWzFdO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IG5ld1BpeGVsVmFsdWVbMl07XG4gICAgICAgIGRhdGFbaSArIDNdID0gbmV3UGl4ZWxWYWx1ZVszXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gX2FwcGx5IChkYXRhLCBwaXhlbEZ1bmMsIGFkanVzdClcbntcbiAgICBsZXQgZGF0YUFyciA9IG5ldyBVaW50OENsYW1wZWRBcnJheShkYXRhLmRhdGEpO1xuICAgIGxldCBpbnZlcnRlZCA9IF9tYW5pcHVsYXRlSW1hZ2UoZGF0YUFyciwgcGl4ZWxGdW5jLCBhZGp1c3QpO1xuXG4gICAgbGV0IG5ld0NhbnZhc0RhdGEgPSBfZ2V0T2Zmc2NyZWVuQ2FudmFzRGF0YShkYXRhLndpZHRoLCBkYXRhLmhlaWdodCk7XG4gICAgbmV3Q2FudmFzRGF0YS5kYXRhLnNldChpbnZlcnRlZCk7XG5cbiAgICByZXR1cm4gbmV3Q2FudmFzRGF0YTtcbn1cblxuLyoqXG4gKiBJbnZlcnRzIHRoZSBjb2xvdXJzIG9mIGEgY2FudmFzLlxuICpcbiAqIEBwYXJhbXMge29iamVjdH0gZGF0YSAtIEEgY2FudmFzIGltYWdlIGRhdGEgb2JqZWN0LlxuICogQHJldHVybnMge29iamVjdH0gQSBuZXcgY2FudmFzIGRhdGEgb2JqZWN0LlxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGdyYXlzY2FsZShkYXRhKVxue1xuICAgIHJldHVybiBhZGRGaWx0ZXJUb1F1ZXVlKGRhdGEsIF9ncmF5c2NhbGUsIG51bGwsICdHcmF5c2NhbGUnKTtcbn1cblxuLyoqXG4gKiBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyYXlzY2FsZSNDb252ZXJ0aW5nX2NvbG9yX3RvX2dyYXlzY2FsZVxuICpcbiAqIFJlZmVyZW5jZTogaHR0cDovL3d3dy5waHBpZWQuY29tL2ltYWdlLWZ1bi8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWx0aW5naWNlL0NhbWFuSlMvYmxvYi9tYXN0ZXIvc3JjL2xpYi9maWx0ZXJzLmNvZmZlZSNMODlcbiAqXG4gKiBAcGFyYW1zIHtpbnRlZ2VyfSByIC0gdGhlIHZhbHVlIG9mIHRoZSByZWQgcGl4ZWxcbiAqIEBwYXJhbXMge2ludGVnZXJ9IGcgLSB0aGUgdmFsdWUgb2YgdGhlIGdyZWVuIHBpeGVsXG4gKiBAcGFyYW1zIHtpbnRlZ2VyfSBiIC0gdGhlIHZhbHVlIG9mIHRoZSBibHVlIHBpeGVsXG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gVGhlIGNvbXB1dGVkIFJHQiB2YWx1ZXMgZm9yIHRoZSBpbnB1dCwgd2l0aCBhIGNvbnN0YW50IDI1NSBmb3IgdGhlIGFscGhhIGNoYW5uZWwuXG4gKiovXG5mdW5jdGlvbiBfZ3JheXNjYWxlIChyLCBnLCBiKVxue1xuICAgIGxldCBwaXhlbEF2ZXJhZ2UgPSAoMC4zICogciArIDAuNTkgKiBnICsgMC4xMSAqIGIpO1xuXG4gICAgcmV0dXJuIFtwaXhlbEF2ZXJhZ2UsIHBpeGVsQXZlcmFnZSwgcGl4ZWxBdmVyYWdlLCAyNTVdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2F0dXJhdGlvbiAoZGF0YSwgYWRqdXN0KVxue1xuICAgIHJldHVybiBhZGRGaWx0ZXJUb1F1ZXVlKGRhdGEsIF9zYXR1cmF0aW9uLCBhZGp1c3QsICdTYXR1cmF0aW9uJyk7XG59XG5cbi8qKlxuICogQWRqdXN0cyB0aGUgY29sb3Igc2F0dXJhdGlvbiBvZiB0aGUgaW1hZ2UuXG4gKiBSYW5nZSBpcyAtMTAwIHRvIDEwMC4gVmFsdWVzIDwgMCB3aWxsIGRlc2F0dXJhdGUgdGhlIGltYWdlIHdoaWxlIHZhbHVlcyA+IDAgd2lsbCBzYXR1cmF0ZSBpdC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21lbHRpbmdpY2UvQ2FtYW5KUy9ibG9iL21hc3Rlci9zcmMvbGliL2ZpbHRlcnMuY29mZmVlI0w0Mi1MNThcbiAqXG4gKiBAcGFyYW1zIHtpbnRlZ2VyfSByIC0gdGhlIHZhbHVlIG9mIHRoZSByZWQgcGl4ZWxcbiAqIEBwYXJhbXMge2ludGVnZXJ9IGcgLSB0aGUgdmFsdWUgb2YgdGhlIGdyZWVuIHBpeGVsXG4gKiBAcGFyYW1zIHtpbnRlZ2VyfSBiIC0gdGhlIHZhbHVlIG9mIHRoZSBibHVlIHBpeGVsXG4gKiBAcGFyYW1zIHtpbnRlZ2VyfSBhZGp1c3QgLSB0aGUgc2F0dXJhdGlvbiB2YWx1ZSBmb3IgYWRqdXN0bWVudCwgLTEwMCB0byAxMDBcbiAqIEByZXR1cm5zIHtBcnJheX0gLSBUaGUgY29tcHV0ZWQgUkdCIHZhbHVlcyBmb3IgdGhlIGlucHV0LCB3aXRoIGEgY29uc3RhbnQgMjU1IGZvciB0aGUgYWxwaGEgY2hhbm5lbC5cbiAqKi9cbmZ1bmN0aW9uIF9zYXR1cmF0aW9uIChyLCBnLCBiLCBhZGp1c3QpXG57XG4gICAgbGV0IGFkaiA9IGFkanVzdCAqIC0wLjAxO1xuICAgIGxldCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIHIgIT09IG1heCA/IHIgKyAobWF4IC0gcikgKiBhZGogOiByLFxuICAgICAgICBnICE9PSBtYXggPyBnICsgKG1heCAtIGcpICogYWRqIDogZyxcbiAgICAgICAgYiAhPT0gbWF4ID8gYiArIChtYXggLSBiKSAqIGFkaiA6IGIsXG4gICAgICAgIDI1NVxuICAgIF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2aWJyYW5jZSAoZGF0YSwgYWRqdXN0KVxue1xuICAgIHJldHVybiBhZGRGaWx0ZXJUb1F1ZXVlKGRhdGEsIF92aWJyYW5jZSwgYWRqdXN0LCAnVmlicmFuY2UnKTtcbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIHNhdHVyYXRpb24sIGJ1dCBhZGp1c3RzIHRoZSBzYXR1cmF0aW9uIGxldmVscyBpbiBhIHNsaWdodGx5IHNtYXJ0ZXIsIG1vcmUgc3VidGxlIHdheS5cbiAqIFZpYnJhbmNlIHdpbGwgYXR0ZW1wdCB0byBib29zdCBjb2xvcnMgdGhhdCBhcmUgbGVzcyBzYXR1cmF0ZWQgbW9yZSBhbmQgYm9vc3QgYWxyZWFkeSBzYXR1cmF0ZWRcbiAqIGNvbG9ycyBsZXNzLCB3aGlsZSBzYXR1cmF0aW9uIGJvb3N0cyBhbGwgY29sb3JzIGJ5IHRoZSBzYW1lIGxldmVsLlxuICpcbiAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21lbHRpbmdpY2UvQ2FtYW5KUy9ibG9iL21hc3Rlci9zcmMvbGliL2ZpbHRlcnMuY29mZmVlI0w2MFxuICpcbiAqIEBwYXJhbXMge2ludGVnZXJ9IHIgLSB0aGUgdmFsdWUgb2YgdGhlIHJlZCBwaXhlbFxuICogQHBhcmFtcyB7aW50ZWdlcn0gZyAtIHRoZSB2YWx1ZSBvZiB0aGUgZ3JlZW4gcGl4ZWxcbiAqIEBwYXJhbXMge2ludGVnZXJ9IGIgLSB0aGUgdmFsdWUgb2YgdGhlIGJsdWUgcGl4ZWxcbiAqIEBwYXJhbXMge2ludGVnZXJ9IGFkanVzdCAtIHRoZSB2aWJyYW5jZSB2YWx1ZSBmb3IgYWRqdXN0bWVudCwgLTEwMCB0byAxMDBcbiAqIEByZXR1cm5zIHtBcnJheX0gLSBUaGUgY29tcHV0ZWQgUkdCIHZhbHVlcyBmb3IgdGhlIGlucHV0LCB3aXRoIGEgY29uc3RhbnQgMjU1IGZvciB0aGUgYWxwaGEgY2hhbm5lbC5cbiAqKi9cbmZ1bmN0aW9uIF92aWJyYW5jZSAociwgZywgYiwgYWRqdXN0KVxue1xuICAgIGxldCBhZGogPSBhZGp1c3QgKiAtMTtcblxuICAgIGxldCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICBsZXQgYXZnID0gciArIGcgKyBiIC8gMztcbiAgICBsZXQgYW10ID0gKChNYXRoLmFicyhtYXggLSBhdmcpICogMiAvIDI1NSkgKiBhZGopIC8gMTAwO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgciAhPT0gbWF4ID8gciArIChtYXggLSByKSAqIGFtdCA6IHIsXG4gICAgICAgIGcgIT09IG1heCA/IGcgKyAobWF4IC0gZykgKiBhbXQgOiBnLFxuICAgICAgICBiICE9PSBtYXggPyBiICsgKG1heCAtIGIpICogYW10IDogYixcbiAgICAgICAgMjU1XG4gICAgXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJyaWdodG5lc3MgKGRhdGEsIGFkanVzdClcbntcbiAgICByZXR1cm4gYWRkRmlsdGVyVG9RdWV1ZShkYXRhLCBfYnJpZ2h0bmVzcywgYWRqdXN0LCAnQnJpZ2h0bmVzcycpO1xufVxuXG5mdW5jdGlvbiBfYnJpZ2h0bmVzcyAociwgZywgYiwgYWRqdXN0KVxue1xuICAgIGxldCBhZGogPSBNYXRoLmZsb29yKDI1NSAqIChhZGp1c3QgLyAxMDApKTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIHIgKyBhZGosXG4gICAgICAgIGcgKyBhZGosXG4gICAgICAgIGIgKyBhZGosXG4gICAgICAgIDI1NVxuICAgIF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb250cmFzdCAoZGF0YSwgYWRqdXN0KVxue1xuICAgIHJldHVybiBhZGRGaWx0ZXJUb1F1ZXVlKGRhdGEsIF9jb250cmFzdCwgYWRqdXN0LCAnQ29udHJhc3QnKTtcbn1cblxuLyoqXG4gKiBJbmNyZWFzZXMgb3IgZGVjcmVhc2VzIHRoZSBjb2xvciBjb250cmFzdCBvZiB0aGUgaW1hZ2UuXG4gKlxuICogQHBhcmFtcyB7aW50ZWdlcn0gciAtIHRoZSB2YWx1ZSBvZiB0aGUgcmVkIHBpeGVsXG4gKiBAcGFyYW1zIHtpbnRlZ2VyfSBnIC0gdGhlIHZhbHVlIG9mIHRoZSBncmVlbiBwaXhlbFxuICogQHBhcmFtcyB7aW50ZWdlcn0gYiAtIHRoZSB2YWx1ZSBvZiB0aGUgYmx1ZSBwaXhlbFxuICogQHBhcmFtcyB7aW50ZWdlcn0gYWRqdXN0IC0gdGhlIGNvbnRyYXN0IHZhbHVlIGZvciBhZGp1c3RtZW50LCAtMTAwIHRvIDEwMFxuICogQHJldHVybnMge0FycmF5fSAtIFRoZSBjb21wdXRlZCBSR0IgdmFsdWVzIGZvciB0aGUgaW5wdXQsIHdpdGggYSBjb25zdGFudCAyNTUgZm9yIHRoZSBhbHBoYSBjaGFubmVsLlxuICoqL1xuZnVuY3Rpb24gX2NvbnRyYXN0IChyLCBnLCBiLCBhZGp1c3QpXG57XG4gICAgbGV0IGFkaiA9IE1hdGgucG93KChhZGp1c3QgKyAxMDApIC8gMTAwLCAyKTtcbiAgICBsZXQgcnIgPSByLCBnZyA9IGcsIGJiID0gYjtcblxuICAgIHJyIC89IDI1NTtcbiAgICByciAtPSAwLjU7XG4gICAgcnIgKj0gYWRqO1xuICAgIHJyICs9IDAuNTtcbiAgICByciAqPSAyNTU7XG5cbiAgICBnZyAvPSAyNTU7XG4gICAgZ2cgLT0gMC41O1xuICAgIGdnICo9IGFkajtcbiAgICBnZyArPSAwLjU7XG4gICAgZ2cgKj0gMjU1O1xuXG4gICAgYmIgLz0gMjU1O1xuICAgIGJiIC09IDAuNTtcbiAgICBiYiAqPSBhZGo7XG4gICAgYmIgKz0gMC41O1xuICAgIGJiICo9IDI1NTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIHJyLCBnZywgYmIsIDI1NVxuICAgIF07XG59XG4vKipcbiAqIEludmVydHMgdGhlIGNvbG91cnMgb2YgYSBjYW52YXMuXG4gKlxuICogQHBhcmFtcyB7b2JqZWN0fSBkYXRhIC0gQSBjYW52YXMgaW1hZ2UgZGF0YSBvYmplY3QuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBBIG5ldyBjYW52YXMgZGF0YSBvYmplY3QuXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KGRhdGEpXG57XG4gICAgcmV0dXJuIGFkZEZpbHRlclRvUXVldWUoZGF0YSwgX2ludmVydCwgbnVsbCwgJ0ludmVydCcpO1xufVxuXG4vKipcbiAqIEludmVydHMgdGhlIGNvbG91cnMgb2YgdGhlIGltYWdlLlxuICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbWVsdGluZ2ljZS9DYW1hbkpTL2Jsb2IvbWFzdGVyL3NyYy9saWIvZmlsdGVycy5jb2ZmZWUjTDE4M1xuICpcbiAqIEBwYXJhbXMge2ludGVnZXJ9IHIgLSB0aGUgdmFsdWUgb2YgdGhlIHJlZCBwaXhlbFxuICogQHBhcmFtcyB7aW50ZWdlcn0gZyAtIHRoZSB2YWx1ZSBvZiB0aGUgZ3JlZW4gcGl4ZWxcbiAqIEBwYXJhbXMge2ludGVnZXJ9IGIgLSB0aGUgdmFsdWUgb2YgdGhlIGJsdWUgcGl4ZWxcbiAqIEByZXR1cm5zIHtBcnJheX0gLSBUaGUgY29tcHV0ZWQgUkdCIHZhbHVlcyBmb3IgdGhlIGlucHV0LCB3aXRoIGEgY29uc3RhbnQgMjU1IGZvciB0aGUgYWxwaGEgY2hhbm5lbC5cbiAqKi9cbmZ1bmN0aW9uIF9pbnZlcnQgKHIsIGcsIGIpXG57XG4gICAgcmV0dXJuIFtcbiAgICAgICAgMjU1IC0gcixcbiAgICAgICAgMjU1IC0gZyxcbiAgICAgICAgMjU1IC0gYixcbiAgICAgICAgMjU1XG4gICAgXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRocmVzaG9sZChkYXRhLCBhZGp1c3QpXG57XG4gICAgcmV0dXJuIGFkZEZpbHRlclRvUXVldWUoZGF0YSwgX3RocmVzaG9sZCwgYWRqdXN0LCAnVGhyZXNob2xkJyk7XG59XG5cbi8qKlxuICogQmxhY2sgcGl4ZWxzIGFib3ZlIGEgY2VydGFpbiB2YWx1ZSAoMC0yNTUpOyBvdGhlcndpc2Ugd2hpdGUuIFBlcmNlcHRpdmVseSB3ZWlnaHRlZC5cbiAqXG4gKiBTZWU6IGh0dHBzOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9jYW52YXMvaW1hZ2VmaWx0ZXJzL1xuICpcbiAqIEBwYXJhbXMge2ludGVnZXJ9IHIgLSB0aGUgdmFsdWUgb2YgdGhlIHJlZCBwaXhlbFxuICogQHBhcmFtcyB7aW50ZWdlcn0gZyAtIHRoZSB2YWx1ZSBvZiB0aGUgZ3JlZW4gcGl4ZWxcbiAqIEBwYXJhbXMge2ludGVnZXJ9IGIgLSB0aGUgdmFsdWUgb2YgdGhlIGJsdWUgcGl4ZWxcbiAqIEBwYXJhbXMge2ludGVnZXJ9IGFkanVzdCAtIHRoZSB0aHJlc2hvbGQgdmFsdWUsIDAtMjU1XG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gVGhlIGNvbXB1dGVkIFJHQiB2YWx1ZXMgZm9yIHRoZSBpbnB1dCwgd2l0aCBhIGNvbnN0YW50IDI1NSBmb3IgdGhlIGFscGhhIGNoYW5uZWwuXG4gKiovXG5mdW5jdGlvbiBfdGhyZXNob2xkIChyLCBnLCBiLCBhZGp1c3QpXG57XG4gICAgbGV0IHYgPSAoMC4yMTI2ICogciArIDAuNzE1MiAqIGcgKyAwLjA3MjIgKiBiID49IGFkanVzdCkgPyAyNTUgOiAwO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgdiwgdiwgdiwgMjU1XG4gICAgXTtcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gaHVlIChkYXRhLCBhZGp1c3QpXG57XG4gICAgcmV0dXJuIGFkZEZpbHRlclRvUXVldWUoZGF0YSwgX2h1ZSwgYWRqdXN0LCAnSHVlJyk7XG59XG5cbmZ1bmN0aW9uIF9odWUgKHIsIGcsIGIsIGFkanVzdClcbntcbiAgICBsZXQge2gsIHMsIHZ9ID0gcmdiVG9IU1YociwgZywgYik7XG5cbiAgICBoID0gaCAqIDEwMDtcbiAgICBoICs9IE1hdGguYWJzKGFkanVzdCk7XG4gICAgaCA9IGggJSAxMDA7XG4gICAgaCAvPSAxMDA7XG5cbiAgICBsZXQgcmVzID0gaHN2VG9SR0IoaCwgcywgdik7XG5cbiAgICByZXR1cm4gW1xuICAgICAgICByZXMuciwgcmVzLmcsIHJlcy5iLCAyNTVcbiAgICBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2FtbWEgKGRhdGEsIGFkanVzdClcbntcbiAgICByZXR1cm4gYWRkRmlsdGVyVG9RdWV1ZShkYXRhLCBfZ2FtbWEsIGFkanVzdCwgJ0dhbW1hJyk7XG59XG5cbi8qKlxuICogQWRqdXN0cyB0aGUgZ2FtbWEgb2YgdGhlIGltYWdlLlxuICogUmFuZ2UgaXMgMCB0byA0LiBWYWx1ZXMgYmV0d2VlbiAwIGFuZCAxIHdpbGwgbGVzc2VuIHRoZSBjb250cmFzdCB3aGlsZSB2YWx1ZXMgZ3JlYXRlclxuICogdGhhbiAxIHdpbGwgaW5jcmVhc2UgaXQuIFN0YXJ0cyBhdCAxIGRlZmF1bHQuIFRoZSBhY3R1YWwgYWRqdXN0IHNsaWRlciBpcyBmcm9tIC0xMDAgdG9cbiAqIDMwMCAoc28gZGVmYXVsdCBjYW4gYmUgMCBhbmQgb2Zmc2V0IGFjY29yZGluZ2x5KSwgc28gbXVzdCBzY2FsZSBwcm9wZXJseVxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWx0aW5naWNlL0NhbWFuSlMvYmxvYi9tYXN0ZXIvc3JjL2xpYi9maWx0ZXJzLmNvZmZlZSNMMjEwLUwyMjFcbiAqXG4gKiBAcGFyYW1zIHtpbnRlZ2VyfSByIC0gdGhlIHZhbHVlIG9mIHRoZSByZWQgcGl4ZWxcbiAqIEBwYXJhbXMge2ludGVnZXJ9IGcgLSB0aGUgdmFsdWUgb2YgdGhlIGdyZWVuIHBpeGVsXG4gKiBAcGFyYW1zIHtpbnRlZ2VyfSBiIC0gdGhlIHZhbHVlIG9mIHRoZSBibHVlIHBpeGVsXG4gKiBAcGFyYW1zIHtpbnRlZ2VyfSBhZGp1c3QgLSB0aGUgZ2FtbWEgdmFsdWUgZm9yIGFkanVzdG1lbnQsIDAgdG8gNDAwXG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gVGhlIGNvbXB1dGVkIFJHQiB2YWx1ZXMgZm9yIHRoZSBpbnB1dCwgd2l0aCBhIGNvbnN0YW50IDI1NSBmb3IgdGhlIGFscGhhIGNoYW5uZWwuXG4gKiovXG5mdW5jdGlvbiBfZ2FtbWEgKHIsIGcsIGIsIGFkanVzdClcbntcbiAgICBsZXQgYWRqID0gYWRqdXN0IC8gMTAwICsgMTtcbiAgICBpZiAoYWRqIDwgMClcbiAgICAgICAgYWRqICo9IC0xO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5wb3cociAvIDI1NSwgYWRqKSAqIDI1NSxcbiAgICAgICAgTWF0aC5wb3coZyAvIDI1NSwgYWRqKSAqIDI1NSxcbiAgICAgICAgTWF0aC5wb3coYiAvIDI1NSwgYWRqKSAqIDI1NSxcbiAgICAgICAgMjU1XG4gICAgXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNjUmVkIChkYXRhLCBhZGp1c3QpXG57XG4gICAgcmV0dXJuIGFkZEZpbHRlclRvUXVldWUoZGF0YSwgX2NjUmVkLCBhZGp1c3QsICdDQyBSZWQnKTtcbn1cblxuLyoqIFxuICogQWRqdXN0cyB0aGUgcmVkIGludGVuc2l0eSBvZiB0aGUgaW1hZ2UuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWx0aW5naWNlL0NhbWFuSlMvYmxvYi9tYXN0ZXIvc3JjL2xpYi9maWx0ZXJzLmNvZmZlZSNMMjc0LUwzMDVcbiAqXG4gKiBAcGFyYW1zIHtpbnRlZ2VyfSByIC0gdGhlIHZhbHVlIG9mIHRoZSByZWQgcGl4ZWxcbiAqIEBwYXJhbXMge2ludGVnZXJ9IGcgLSB0aGUgdmFsdWUgb2YgdGhlIGdyZWVuIHBpeGVsXG4gKiBAcGFyYW1zIHtpbnRlZ2VyfSBiIC0gdGhlIHZhbHVlIG9mIHRoZSBibHVlIHBpeGVsXG4gKiBAcGFyYW1zIHtpbnRlZ2VyfSBhZGp1c3QgLSB0aGUgcmVkIHZhbHVlIGZvciBhZGp1c3RtZW50LCAtMTAwIHRvIDEwMFxuICogQHJldHVybnMge0FycmF5fSAtIFRoZSBjb21wdXRlZCBSR0IgdmFsdWVzIGZvciB0aGUgaW5wdXQsIHdpdGggYSBjb25zdGFudCAyNTUgZm9yIHRoZSBhbHBoYSBjaGFubmVsLlxuICovIFxuZnVuY3Rpb24gX2NjUmVkIChyLCBnLCBiLCBhZGp1c3QpXG57XG4gICAgbGV0IGFkaiA9IGFkanVzdCAvIDEwMDtcblxuICAgIHJldHVybiBbXG4gICAgICAgIGFkaiA+IDAgPyByICsgKDI1NSAtIHIpICogYWRqIDogciAtIHIgKiBNYXRoLmFicyhhZGopLFxuICAgICAgICBnLFxuICAgICAgICBiLFxuICAgICAgICAyNTVcbiAgICBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2NHcmVlbiAoZGF0YSwgYWRqdXN0KVxue1xuICAgIHJldHVybiBhZGRGaWx0ZXJUb1F1ZXVlKGRhdGEsIF9jY0dyZWVuLCBhZGp1c3QsICdDQyBHcmVlbicpO1xufVxuXG4vKiogXG4gKiBBZGp1c3RzIHRoZSBncmVlbiBpbnRlbnNpdHkgb2YgdGhlIGltYWdlLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWVsdGluZ2ljZS9DYW1hbkpTL2Jsb2IvbWFzdGVyL3NyYy9saWIvZmlsdGVycy5jb2ZmZWUjTDI3NC1MMzA1XG4gKlxuICogQHBhcmFtcyB7aW50ZWdlcn0gciAtIHRoZSB2YWx1ZSBvZiB0aGUgcmVkIHBpeGVsXG4gKiBAcGFyYW1zIHtpbnRlZ2VyfSBnIC0gdGhlIHZhbHVlIG9mIHRoZSBncmVlbiBwaXhlbFxuICogQHBhcmFtcyB7aW50ZWdlcn0gYiAtIHRoZSB2YWx1ZSBvZiB0aGUgYmx1ZSBwaXhlbFxuICogQHBhcmFtcyB7aW50ZWdlcn0gYWRqdXN0IC0gdGhlIGdyZWVuIHZhbHVlIGZvciBhZGp1c3RtZW50LCAtMTAwIHRvIDEwMFxuICogQHJldHVybnMge0FycmF5fSAtIFRoZSBjb21wdXRlZCBSR0IgdmFsdWVzIGZvciB0aGUgaW5wdXQsIHdpdGggYSBjb25zdGFudCAyNTUgZm9yIHRoZSBhbHBoYSBjaGFubmVsLlxuICovIFxuZnVuY3Rpb24gX2NjR3JlZW4gKHIsIGcsIGIsIGFkanVzdClcbntcbiAgICBsZXQgYWRqID0gYWRqdXN0IC8gMTAwO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgcixcbiAgICAgICAgYWRqID4gMCA/IGcgKyAoMjU1IC0gZykgKiBhZGogOiBnIC0gZyAqIE1hdGguYWJzKGFkaiksXG4gICAgICAgIGIsXG4gICAgICAgIDI1NVxuICAgIF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjY0JsdWUgKGRhdGEsIGFkanVzdClcbntcbiAgICByZXR1cm4gYWRkRmlsdGVyVG9RdWV1ZShkYXRhLCBfY2NCbHVlLCBhZGp1c3QsICdDQyBCbHVlJyk7XG59XG5cbi8qKiBcbiAqIEFkanVzdHMgdGhlIGJsdWUgaW50ZW5zaXR5IG9mIHRoZSBpbWFnZS5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21lbHRpbmdpY2UvQ2FtYW5KUy9ibG9iL21hc3Rlci9zcmMvbGliL2ZpbHRlcnMuY29mZmVlI0wyNzQtTDMwNVxuICpcbiAqIEBwYXJhbXMge2ludGVnZXJ9IHIgLSB0aGUgdmFsdWUgb2YgdGhlIHJlZCBwaXhlbFxuICogQHBhcmFtcyB7aW50ZWdlcn0gZyAtIHRoZSB2YWx1ZSBvZiB0aGUgZ3JlZW4gcGl4ZWxcbiAqIEBwYXJhbXMge2ludGVnZXJ9IGIgLSB0aGUgdmFsdWUgb2YgdGhlIGJsdWUgcGl4ZWxcbiAqIEBwYXJhbXMge2ludGVnZXJ9IGFkanVzdCAtIHRoZSBibHVlIHZhbHVlIGZvciBhZGp1c3RtZW50LCAtMTAwIHRvIDEwMFxuICogQHJldHVybnMge0FycmF5fSAtIFRoZSBjb21wdXRlZCBSR0IgdmFsdWVzIGZvciB0aGUgaW5wdXQsIHdpdGggYSBjb25zdGFudCAyNTUgZm9yIHRoZSBhbHBoYSBjaGFubmVsLlxuICovIFxuZnVuY3Rpb24gX2NjQmx1ZSAociwgZywgYiwgYWRqdXN0KVxue1xuICAgIGxldCBhZGogPSBhZGp1c3QgLyAxMDA7XG5cbiAgICByZXR1cm4gW1xuICAgICAgICByLFxuICAgICAgICBnLFxuICAgICAgICBhZGogPiAwID8gYiArICgyNTUgLSBiKSAqIGFkaiA6IGIgLSBiICogTWF0aC5hYnMoYWRqKSxcbiAgICAgICAgMjU1XG4gICAgXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJnYlRvSFNWIChyLCBnLCBiKVxue1xuICAgIGxldCByciA9IHIsIGdnID0gZywgYmIgPSBiO1xuXG4gICAgcnIgLz0gMjU1O1xuICAgIGdnIC89IDI1NTtcbiAgICBiYiAvPSAyNTU7XG5cbiAgICBsZXQgbWF4ID0gTWF0aC5tYXgocnIsIGdnLCBiYik7XG4gICAgbGV0IG1pbiA9IE1hdGgubWluKHJyLCBnZywgYmIpO1xuICAgIGxldCB2ID0gbWF4O1xuICAgIGxldCBkID0gbWF4IC0gbWluO1xuXG4gICAgbGV0IHMgPSBtYXggPT09IDAgPyAwIDogZCAvIG1heDtcbiAgICBsZXQgaDtcblxuICAgIGlmIChtYXggPT09IG1pbilcbiAgICAgICAgaCA9IDA7XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgc3dpdGNoIChtYXgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhc2UgcnI6XG4gICAgICAgICAgICAgICAgaCA9IChnZyAtIGJiKSAvIGQgKyAoZ2cgPCBiYiA/IDYgOiAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZ2c6XG4gICAgICAgICAgICAgICAgaCA9IChiYiAtIHJyKSAvIGQgKyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBiYjpcbiAgICAgICAgICAgICAgICBoID0gKHJyIC0gZ2cpIC8gZCArIDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBoIC89IDY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtoLCBzLCB2fTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzdlRvUkdCIChoLCBzLCB2KVxue1xuICAgIGxldCBiLCBmLCBnLCBpLCBwLCBxLCByLCB0O1xuICAgIGkgPSBNYXRoLmZsb29yKGggKiA2KTtcbiAgICBmID0gaCAqIDYgLSBpO1xuICAgIHAgPSB2ICogKDEgLSBzKTtcbiAgICBxID0gdiAqICgxIC0gZiAqIHMpO1xuICAgIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG5cbiAgICBzd2l0Y2ggKGkgJSA2KVxuICAgIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgciA9IHY7XG4gICAgICAgICAgICBnID0gdDtcbiAgICAgICAgICAgIGIgPSBwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHIgPSBxO1xuICAgICAgICAgICAgZyA9IHY7XG4gICAgICAgICAgICBiID0gcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByID0gcDtcbiAgICAgICAgICAgIGcgPSB2O1xuICAgICAgICAgICAgYiA9IHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgciA9IHA7XG4gICAgICAgICAgICBnID0gcTtcbiAgICAgICAgICAgIGIgPSB2O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHIgPSB0O1xuICAgICAgICAgICAgZyA9IHA7XG4gICAgICAgICAgICBiID0gdjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByID0gdjtcbiAgICAgICAgICAgIGcgPSBwO1xuICAgICAgICAgICAgYiA9IHE7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByOiBNYXRoLmZsb29yKHIgKiAyNTUpLFxuICAgICAgICBnOiBNYXRoLmZsb29yKGcgKiAyNTUpLFxuICAgICAgICBiOiBNYXRoLmZsb29yKGIgKiAyNTUpXG4gICAgfTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgQ29udm9sdXRpb24gZmlsdGVyc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuZnVuY3Rpb24gY29udm9sdmUgKGRhdGEsIHdlaWdodHMsIG9wYXF1ZSlcbntcbiAgICBsZXQgc2lkZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHdlaWdodHMubGVuZ3RoKSk7XG4gICAgbGV0IGhhbGZTaWRlID0gTWF0aC5mbG9vcihzaWRlIC8gMik7XG5cbiAgICBsZXQgc3JjRGF0YSA9IGRhdGEuZGF0YTtcbiAgICBsZXQgc3cgPSBkYXRhLndpZHRoO1xuICAgIGxldCBzaCA9IGRhdGEuaGVpZ2h0O1xuICAgIGxldCB3ID0gc3c7XG4gICAgbGV0IGggPSBzaDtcblxuICAgIGxldCBvdXRwdXQgPSBfZ2V0T2Zmc2NyZWVuQ2FudmFzRGF0YSh3LCBoKTtcbiAgICBsZXQgZHN0ID0gb3V0cHV0LmRhdGE7XG5cbiAgICBsZXQgYWxwaGFGYWMgPSBvcGFxdWUgPyAxIDogMDtcblxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaDsgeSsrKVxuICAgIHtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3OyB4KyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBzeSA9IHk7XG4gICAgICAgICAgICBsZXQgc3ggPSB4O1xuICAgICAgICAgICAgbGV0IGRzdE9mZiA9ICh5ICogdyArIHgpICogNDtcblxuICAgICAgICAgICAgbGV0IHIgPSAwLCBnID0gMCwgYiA9IDAsIGEgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBjeSA9IDA7IGN5IDwgc2lkZTsgY3krKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjeCA9IDA7IGN4IDwgc2lkZTsgY3grKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzY3kgPSBzeSArIGN5IC0gaGFsZlNpZGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzY3ggPSBzeCArIGN4IC0gaGFsZlNpZGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjeSA+PSAwICYmIHNjeSA8IHNoICYmIHNjeCA+PSAwICYmIHNjeCA8IHN3KVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3JjT2ZmID0gKHNjeSAqIHN3ICsgc2N4KSAqIDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgd3QgPSB3ZWlnaHRzW2N5ICogc2lkZSArIGN4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gc3JjRGF0YVtzcmNPZmZdICogd3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBnICs9IHNyY0RhdGFbc3JjT2ZmICsgMV0gKiB3dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgKz0gc3JjRGF0YVtzcmNPZmYgKyAyXSAqIHd0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYSArPSBzcmNEYXRhW3NyY09mZiArIDNdICogd3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRzdFtkc3RPZmZdID0gcjtcbiAgICAgICAgICAgIGRzdFtkc3RPZmYgKyAxXSA9IGc7XG4gICAgICAgICAgICBkc3RbZHN0T2ZmICsgMl0gPSBiO1xuICAgICAgICAgICAgZHN0W2RzdE9mZiArIDNdID0gYSArIGFscGhhRmFjICogKDI1NSAtIGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNoYXJwZW4gKGRhdGEsIGFkanVzdClcbntcbiAgICBsZXQgYWRqID0gYWRqdXN0ID8gYWRqdXN0IDogMTAwO1xuICAgIGFkaiAvPSAxMDA7XG5cbiAgICBpZiAoYWRqdXN0ID09PSAwKSAvLyByZXNldCB2YWx1ZVxuICAgICAgICBhZGogPSAwO1xuXG4gICAgbGV0IHdlaWdodHMgPSBbXG4gICAgICAgIDAsIC1hZGosIDAsXG4gICAgICAgIC1hZGosIDQgKiBhZGogKyAxLCAtYWRqLFxuICAgICAgICAwLCAtYWRqLCAwXG4gICAgXTtcblxuICAgIHJldHVybiBhZGRGaWx0ZXJUb1F1ZXVlKGRhdGEsIGNvbnZvbHZlLCB3ZWlnaHRzLCAnU2hhcnBuZXNzJyk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/plugins/_filters.js\n");

/***/ }),

/***/ "./source/js/plugins/manipulation.js":
/*!*******************************************!*\
  !*** ./source/js/plugins/manipulation.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ManipulationPlugin; });\n/* harmony import */ var _filters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_filters */ \"./source/js/plugins/_filters.js\");\n/* harmony import */ var _gesture_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gesture-events */ \"./source/js/gesture-events.js\");\n\n\n\n/**\n * Returns a function, that, as long as it continues to be invoked, will not\n be triggered. The function will be called after it stops being called for\n N milliseconds. If `immediate` is passed, trigger the function on the\n leading edge, instead of the trailing.\n */\nfunction debounce (func, wait, immediate)\n{\n    let timeout;\n    return function ()\n    {\n        let context = this, args = arguments;\n        let later = function ()\n        {\n            timeout = null;\n            if (!immediate)\n            {\n                func.apply(context, args);\n            }\n        };\n        let callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow)\n        {\n            func.apply(context, args);\n        }\n    };\n}\n\n/**\n * A Diva.js plugin that allows users to manipulate images by adjusting their\n * brightness, contrast, and other parameters.\n **/\nclass ManipulationPlugin\n{\n    constructor (core)\n    {\n        this._core = core;\n        this.pageToolsIcon = this.createIcon();\n        this._backdrop = null;\n        this._page = null;\n        this._mainImage = null;\n        this._canvas = null;\n\n        // store the data for the original main image so that we\n        // do the processing on that, not on a previously-processed image.\n        this._originalData = null;\n\n        // zoom stuff\n        this.maxZoom = 4;\n        this.minZoom = 1;\n        this.zoom = 1;\n\n        this.rotate = 0;\n\n        // mirror stuff, 1 for not mirrored, -1 for mirrored\n        this.mirrorHorizontal = 1;\n        this.mirrorVertical = 1;\n\n        this.boundEscapeListener = this.escapeListener.bind(this);\n\n        // url of currently loaded image\n        this.currentImageURL = null;\n    }\n\n    handleClick (event, settings, publicInstance, pageIndex)\n    {\n        document.body.style.overflow = 'hidden';\n        this._backdrop = document.createElement('div');\n        this._backdrop.classList.add('manipulation-fullscreen');\n\n        this._sidebar = document.createElement('div');\n        this._sidebar.classList.add('manipulation-sidebar');\n\n        this._mainArea = document.createElement('div');\n        this._mainArea.classList.add('manipulation-main-area');\n\n        // enable scroll by dragging\n        this._mainArea.classList.add('dragscroll');\n        this._mainArea.addEventListener('mousedown', () => { this._mainArea.classList.add('grabbing'); });\n        this._mainArea.addEventListener('mouseup', () => { this._mainArea.classList.remove('grabbing'); });\n\n        // add double click zoom handler\n        _gesture_events__WEBPACK_IMPORTED_MODULE_1__[\"default\"].onDoubleClick(this._mainArea, this.handleDblClick.bind(this));\n\n        this._tools = document.createElement('div');\n        this._tools.classList.add('manipulation-tools');\n\n        this._backdrop.appendChild(this._sidebar);\n        this._backdrop.appendChild(this._mainArea);\n        this._backdrop.appendChild(this._tools);\n\n        this._core.parentObject.appendChild(this._backdrop);\n        document.addEventListener('keyup', this.boundEscapeListener);\n\n        this._page = settings.manifest.pages[pageIndex];\n\n        this._canvas = document.createElement('canvas');\n        this._ctx = this._canvas.getContext('2d');\n        this._mainArea.appendChild(this._canvas);\n\n        this._initializeSidebar();\n        this._initializeTools();\n\n        window.resetDragscroll();\n        this._loadImageInMainArea(event, this._page.url);\n\n        // hide toolbar if fullscreen\n        if (settings.inFullscreen)\n        {\n            document.getElementById(settings.selector + 'tools').style.display = 'none';\n        }\n\n        // handle smaller viewport\n        if (window.innerWidth <= 1000)\n        {\n            this._mainArea.classList.remove('manipulation-main-area');\n            this._mainArea.classList.add('manipulation-main-area-mobile');\n            this._sidebar.classList.remove('manipulation-sidebar');\n            this._sidebar.classList.add('manipulation-sidebar-mobile');\n            this._tools.classList.remove('manipulation-tools');\n            this._tools.classList.add('manipulation-tools-mobile');\n\n            // add hamburger menus\n            let burger = document.createElement('div');\n            burger.classList.add('burger-menu');\n            let s1 = document.createElement('div');\n            let s2 = document.createElement('div');\n            let s3 = document.createElement('div');\n            s1.classList.add('stripe');\n            s2.classList.add('stripe');\n            s3.classList.add('stripe');\n\n            burger.appendChild(s1);\n            burger.appendChild(s2);\n            burger.appendChild(s3);\n\n            this.burgerClicked = false;\n\n            burger.onclick = () => {\n                if (this.burgerClicked)\n                {\n                    this._sidebar.style.display = 'none';\n                    this._tools.style.display = 'none';\n                    this._mainArea.style.display = 'block';\n                }\n                else\n                {\n                    this._sidebar.style.display = 'block';\n                    this._tools.style.display = 'block';\n                    this._mainArea.style.display = 'none';\n                }\n                this.burgerClicked = !this.burgerClicked;\n            };\n\n            this._backdrop.appendChild(burger);\n        }\n    }\n\n    handleDblClick (event)\n    {\n        let newZoom = event.ctrlKey ? this.zoom - 1 : this.zoom + 1;\n        if (newZoom < this.minZoom || newZoom > this.maxZoom)\n            return;\n\n        // update slider\n        let slider = document.getElementById('zoom-slider');\n        slider.value = newZoom;\n\n        this.handleZoom(event, newZoom, true);\n    }\n\n    /*\n    *  Returns an SVG object representing the icon for the project. Implemented in code\n    *  here so that the entire Diva object can be passed to the client with no external\n    *  dependencies.\n    **/\n    createIcon ()\n    {\n        const manipulationIcon = document.createElement('div');\n        manipulationIcon.classList.add('diva-manipulation-icon');\n\n        let root = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n        root.setAttribute(\"x\", \"0px\");\n        root.setAttribute(\"y\", \"0px\");\n        root.setAttribute(\"viewBox\", \"0 0 25 25\");\n        root.id = `${this._core.settings.selector}manipulation-icon`;\n\n        let g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n        g.id = `${this._core.settings.selector}manipulation-icon-glyph`;\n        g.setAttribute(\"transform\", \"matrix(1, 0, 0, 1, -11.5, -11.5)\");\n        g.setAttribute(\"class\", \"diva-pagetool-icon\");\n\n        let path1 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path1.setAttribute(\"d\", \"M27,21h-1v-9h-3v9h-1c-0.55,0-1,0.45-1,1v3c0,0.55,0.45,1,1,1h1h3h1c0.55,0,1-0.45,1-1v-3C28,21.45,27.55,21,27,21z M27,24h-5v-0.5h5V24z\");\n\n        let path2 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path2.setAttribute(\"d\", \"M35,16h-1v-4h-3v4h-1c-0.55,0-1,0.45-1,1v3c0,0.55,0.45,1,1,1h1h3h1c0.55,0,1-0.45,1-1v-3C36,16.45,35.55,16,35,16z M35,19h-5v-0.5h5V19z\");\n\n        let path3 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path3.setAttribute(\"d\", \"M19,26h-1V12h-3v14h-1c-0.55,0-1,0.45-1,1v3c0,0.55,0.45,1,1,1h1h3h1c0.55,0,1-0.45,1-1v-3C20,26.45,19.55,26,19,26zM19,29h-5v-0.5h5V29z\");\n\n        let rect1 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n        rect1.setAttribute('x', '23');\n        rect1.setAttribute('y', '27');\n        rect1.setAttribute('width', '3');\n        rect1.setAttribute('height', '9');\n\n        let rect2 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n        rect2.setAttribute('x', '31');\n        rect2.setAttribute('y', '22');\n        rect2.setAttribute('width', '3');\n        rect2.setAttribute('height', '14');\n\n        let rect3 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n        rect3.setAttribute('x', '15');\n        rect3.setAttribute('y', '32');\n        rect3.setAttribute('width', '3');\n        rect3.setAttribute('height', '4');\n\n        g.appendChild(path1);\n        g.appendChild(path2);\n        g.appendChild(rect1);\n        g.appendChild(path3);\n        g.appendChild(rect2);\n        g.appendChild(rect3);\n        root.appendChild(g);\n\n        manipulationIcon.appendChild(root);\n\n        return manipulationIcon;\n    }\n\n    escapeListener (event)\n    {\n        if (event.keyCode === 27)\n        {\n            document.removeEventListener('keyup', this.boundEscapeListener);\n            document.body.style.overflow = 'auto';\n            this._core.parentObject.removeChild(this._backdrop);\n\n            // show toolbar\n            document.getElementById(`${this._core.settings.selector}tools`).style.display = 'block';\n        }\n    }\n\n    _initializeSidebar ()\n    {\n        // 150px wide images for the sidebar.\n        let thumbnailSize = \"150\";\n        let mainPageSidebarImageURL = `${this._page.url}full/${thumbnailSize},/0/default.jpg`;\n\n        let otherImageURLs = this._page.otherImages.map((img) =>\n        {\n            return `${img.url}full/${thumbnailSize},/0/default.jpg`;\n        });\n\n        let primaryImgDiv = document.createElement('div');\n        primaryImgDiv.classList.add('manipulation-sidebar-primary-image');\n\n        let primaryImg = document.createElement('img');\n        primaryImg.setAttribute('src', mainPageSidebarImageURL);\n\n        let primaryImgLabel = document.createElement('div');\n        primaryImgLabel.textContent = this._page.il;\n\n        primaryImgDiv.appendChild(primaryImg);\n        primaryImgDiv.appendChild(primaryImgLabel);\n\n        this._sidebar.appendChild(primaryImgDiv);\n\n        primaryImgDiv.addEventListener('click', () =>\n        {\n            this._loadImageInMainArea.call(this, event, this._page.url);\n        });\n\n        otherImageURLs.map((url, idx) =>\n        {\n            let othDiv = document.createElement('div');\n            othDiv.classList.add('manipulation-sidebar-secondary-image');\n\n            let othImg = document.createElement('img');\n            othImg.setAttribute('src', url);\n\n            let othImgLabel = document.createElement('div');\n            othImgLabel.textContent = this._page.otherImages[idx].il;\n\n            othDiv.appendChild(othImg);\n            othDiv.appendChild(othImgLabel);\n\n            this._sidebar.appendChild(othDiv);\n\n            othDiv.addEventListener('click', () => this._loadImageInMainArea.call(this, event, this._page.otherImages[idx].url));\n        });\n    }\n\n    _initializeTools ()\n    {\n        // Close button\n        let closeButton = document.createElement('button');\n\n        closeButton.innerHTML = '&#10006';\n        closeButton.classList.add('close-button');\n        closeButton.setAttribute('style', 'display: absolute; top: 1em; right: 1em;');\n\n        closeButton.onclick = () =>\n        {\n            document.body.style.overflow = 'auto';\n            this._core.parentObject.removeChild(this._backdrop);\n            document.getElementById(this._core.settings.selector + 'tools').style.display = 'block';\n        };\n\n        // Header title\n        let header = document.createElement('h2');\n\n        header.setAttribute('style', 'margin-bottom: 0.3em;');\n        header.classList.add('manipulation-tools-text');\n        header.innerText = 'Image tools';\n\n        // Zoom tool\n        let zoomDiv = document.createElement('div');\n        let zoomAdjust = document.createElement('input');\n        let zoomText = document.createElement('label');\n        zoomText.textContent = 'Zoom';\n        zoomText.setAttribute('for', 'zoom-slider');\n\n        zoomDiv.classList.add('manipulation-tools-text');\n        zoomAdjust.setAttribute('type', 'range');\n        zoomAdjust.setAttribute('max', this.maxZoom);\n        zoomAdjust.setAttribute('min', this.minZoom);\n        zoomAdjust.setAttribute('value', this.zoom);\n        zoomAdjust.id = 'zoom-slider';\n        zoomDiv.addEventListener('change', debounce((e) => this.handleZoom(e, e.target.value, true), 250));\n        zoomDiv.appendChild(zoomAdjust);\n        zoomDiv.appendChild(zoomText);\n\n        // Rotation tool\n        let rotateDiv = document.createElement('div');\n        let rotateAdjust = document.createElement('input');\n        let rotateText = document.createElement('label');\n        rotateText.textContent = 'Rotation';\n        rotateText.setAttribute('for', 'rotate-slider');\n\n        rotateDiv.classList.add('manipulation-tools-text');\n        rotateAdjust.id = 'rotate-slider';\n        rotateAdjust.setAttribute('type', 'range');\n        rotateAdjust.setAttribute('max', 359);\n        rotateAdjust.setAttribute('min', 0);\n        rotateAdjust.setAttribute('value', 0);\n\n        rotateDiv.addEventListener('input', (e) => { this.handleTransform(e, null, e.target.value); });\n        rotateDiv.appendChild(rotateAdjust);\n        rotateDiv.appendChild(rotateText);\n\n        // Mirror tool\n        let mirrorDiv = document.createElement('div');\n        let verticalMirrorButton = document.createElement('button');\n        verticalMirrorButton.id = 'vertical-mirror-button';\n        let horizontalMirrorButton = document.createElement('button');\n        horizontalMirrorButton.id = 'horizontal-mirror-button';\n\n        verticalMirrorButton.textContent = \"Mirror Vertically\";\n        horizontalMirrorButton.textContent = \"Mirror Horizontally\";\n        verticalMirrorButton.addEventListener('click', (e) => this.handleTransform(e, 'vertical', this.rotate));\n        horizontalMirrorButton.addEventListener('click', (e) => this.handleTransform(e, 'horizontal', this.rotate));\n        mirrorDiv.appendChild(verticalMirrorButton);\n        mirrorDiv.appendChild(horizontalMirrorButton);\n\n        // Filters title\n        let filtersTitle = document.createElement('div');\n        filtersTitle.setAttribute('style', 'margin: 1em 0;');\n\n        let titleText = document.createElement('h3');\n        titleText.setAttribute('style', 'margin: 0;');\n        titleText.classList.add('manipulation-tools-text');\n        titleText.innerText = 'Filters';\n        titleText.id = 'filters-title';\n\n        // Selection options (color filters or threshold)\n        let select = document.createElement('select');\n        select.id = 'filter-select';\n        select.style.backgroundColor = 'white';\n        select.setAttribute('aria-labelledby', 'filters-title');\n\n        let colorFilters = document.createElement('option');\n        colorFilters.value = 'colours';\n        colorFilters.innerText = 'Color Filters';\n\n        let otherFilters = document.createElement('option');\n        otherFilters.value = 'threshold';\n        otherFilters.innerText = 'Threshold';\n\n        select.addEventListener('change', switchVisibleFilters);\n        select.appendChild(colorFilters);\n        select.appendChild(otherFilters);\n        filtersTitle.appendChild(titleText);\n        filtersTitle.appendChild(select);\n\n        // Grayscale filter\n        let bwDiv = document.createElement('div');\n        bwDiv.classList.add('color-filters');\n        let blackWhiteButton = document.createElement('button');\n        blackWhiteButton.textContent = \"Grayscale\";\n        blackWhiteButton.addEventListener('click', (e) => this._applyTransformationToImageData(e, _filters__WEBPACK_IMPORTED_MODULE_0__[\"grayscale\"]));\n        bwDiv.appendChild(blackWhiteButton);\n\n        // Saturation filter\n        let saturationDiv = document.createElement('div');\n        saturationDiv.classList.add('color-filters');\n        saturationDiv.classList.add('manipulation-tools-text');\n        let saturationAdjust = document.createElement('input');\n        let saturationText = document.createElement('label');\n        saturationText.textContent = 'Saturation';\n        saturationText.setAttribute('for', 'saturation-slider');\n        saturationAdjust.setAttribute('type', 'range');\n        saturationAdjust.setAttribute('max', 100);\n        saturationAdjust.setAttribute('min', -100);\n        saturationAdjust.setAttribute('value', 0);\n        saturationAdjust.id = 'saturation-slider';\n\n        saturationAdjust.addEventListener('change', debounce((e) => this._applyTransformationToImageData(e, _filters__WEBPACK_IMPORTED_MODULE_0__[\"saturation\"], e.target.value), 250));\n        saturationDiv.appendChild(saturationAdjust);\n        saturationDiv.appendChild(saturationText);\n\n        // Vibrance filter\n        let vibDiv = document.createElement('div');\n        vibDiv.classList.add('color-filters');\n        vibDiv.classList.add('manipulation-tools-text');\n        let vibranceAdjust = document.createElement('input');\n        let vibranceText = document.createElement('label');\n        vibranceText.textContent = 'Vibrance';\n        vibranceText.setAttribute('for', 'vibrance-slider');\n        vibranceAdjust.setAttribute('type', 'range');\n        vibranceAdjust.setAttribute('max', 100);\n        vibranceAdjust.setAttribute('min', -100);\n        vibranceAdjust.setAttribute('value', 0);\n        vibranceAdjust.id = 'vibrance-slider';\n\n        vibranceAdjust.addEventListener('change', debounce((e) => this._applyTransformationToImageData(e, _filters__WEBPACK_IMPORTED_MODULE_0__[\"vibrance\"], e.target.value), 250));\n        vibDiv.appendChild(vibranceAdjust);\n        vibDiv.appendChild(vibranceText);\n\n        // Brightness filter\n        let brightDiv = document.createElement('div');\n        brightDiv.classList.add('color-filters');\n        brightDiv.classList.add('manipulation-tools-text');\n        let brightnessAdjust = document.createElement('input');\n        let brightnessText = document.createElement('label');\n        brightnessText.setAttribute('for', 'brightness-slider');\n        brightnessText.textContent = 'Brightness';\n        brightnessAdjust.setAttribute('type', 'range');\n        brightnessAdjust.setAttribute('max', 100);\n        brightnessAdjust.setAttribute('min', -100);\n        brightnessAdjust.setAttribute('value', 0);\n        brightnessAdjust.id = 'brightness-slider';\n\n        brightnessAdjust.addEventListener('change', debounce((e) => this._applyTransformationToImageData(e, _filters__WEBPACK_IMPORTED_MODULE_0__[\"brightness\"], e.target.value), 250));\n        brightDiv.appendChild(brightnessAdjust);\n        brightDiv.appendChild(brightnessText);\n\n        // Contrast filter\n        let contrastDiv = document.createElement('div');\n        contrastDiv.classList.add('color-filters');\n        contrastDiv.classList.add('manipulation-tools-text');\n        let contrastAdjust = document.createElement('input');\n        let contrastText = document.createElement('label');\n        contrastText.textContent = 'Contrast';\n        contrastText.setAttribute('for', 'contrast-slider');\n        contrastAdjust.setAttribute('type', 'range');\n        contrastAdjust.setAttribute('max', 100);\n        contrastAdjust.setAttribute('min', -100);\n        contrastAdjust.setAttribute('value', 0);\n        contrastAdjust.id = 'contrast-slider';\n\n        contrastAdjust.addEventListener('change', debounce((e) => this._applyTransformationToImageData(e, _filters__WEBPACK_IMPORTED_MODULE_0__[\"contrast\"], e.target.value), 250));\n        contrastDiv.appendChild(contrastAdjust);\n        contrastDiv.appendChild(contrastText);\n\n        // Invert colours filter\n        let invDiv = document.createElement('div');\n        invDiv.classList.add('color-filters');\n        let invertButton = document.createElement('button');\n        invertButton.textContent = \"Invert Colours\";\n        invertButton.addEventListener('click', (e) => this._applyTransformationToImageData(e, _filters__WEBPACK_IMPORTED_MODULE_0__[\"invert\"]));\n        invDiv.appendChild(invertButton);\n\n        // Sharpness filter\n        let sharpDiv = document.createElement('div');\n        sharpDiv.classList.add('color-filters');\n        sharpDiv.classList.add('manipulation-tools-text');\n        let sharpenAdjust = document.createElement('input');\n        let sharpenText = document.createElement('label');\n        sharpenText.textContent = 'Sharpness';\n        sharpenText.setAttribute('for', 'sharpness-slider');\n        sharpenAdjust.setAttribute('type', 'range');\n        sharpenAdjust.setAttribute('max', 100);\n        sharpenAdjust.setAttribute('min', 0);\n        sharpenAdjust.setAttribute('value', 0);\n        sharpenAdjust.id = 'sharpness-slider';\n\n        sharpenAdjust.addEventListener('change', debounce((e) => this._applyTransformationToImageData(e, _filters__WEBPACK_IMPORTED_MODULE_0__[\"sharpen\"], e.target.value), 250));\n        sharpDiv.appendChild(sharpenAdjust);\n        sharpDiv.appendChild(sharpenText);\n\n        // Hue filter\n        let hueDiv = document.createElement('div');\n        hueDiv.classList.add('color-filters');\n        hueDiv.classList.add('manipulation-tools-text');\n        let hueAdjust = document.createElement('input');\n        let hueText = document.createElement('label');\n        hueText.textContent = 'Hue';\n        hueText.setAttribute('for', 'hue-slider');\n        hueAdjust.setAttribute('type', 'range');\n        hueAdjust.setAttribute('max', 100);\n        hueAdjust.setAttribute('min', 0);\n        hueAdjust.setAttribute('value', 0);\n        hueAdjust.id = 'hue-slider';\n\n        hueAdjust.addEventListener('change', debounce((e) => this._applyTransformationToImageData(e, _filters__WEBPACK_IMPORTED_MODULE_0__[\"hue\"], e.target.value), 250));\n        hueDiv.appendChild(hueAdjust);\n        hueDiv.appendChild(hueText);\n\n        // Gamma filter\n        let gammaDiv = document.createElement('div');\n        gammaDiv.classList.add('color-filters');\n        gammaDiv.classList.add('manipulation-tools-text');\n        let gammaAdjust = document.createElement('input');\n        let gammaText = document.createElement('label');\n        gammaText.textContent = 'Gamma';\n        gammaText.setAttribute('for', 'gamma-slider');\n        gammaAdjust.setAttribute('type', 'range');\n        gammaAdjust.setAttribute('max', 300);\n        gammaAdjust.setAttribute('min', -100);\n        gammaAdjust.setAttribute('value', 0);\n        gammaAdjust.id = 'gamma-slider';\n\n        gammaAdjust.addEventListener('change', debounce((e) => this._applyTransformationToImageData(e, _filters__WEBPACK_IMPORTED_MODULE_0__[\"gamma\"], e.target.value), 250));\n        gammaDiv.appendChild(gammaAdjust);\n        gammaDiv.appendChild(gammaText);\n\n        // Colour channel RGB slides\n        let ccRedDiv = document.createElement('div');\n        ccRedDiv.classList.add('color-filters');\n        ccRedDiv.classList.add('manipulation-tools-text');\n        let ccRedAdjust = document.createElement('input');\n        let ccRedText = document.createElement('label');\n        ccRedText.textContent = 'CC Red';\n        ccRedText.setAttribute('for', 'cc-red-slider');\n        ccRedAdjust.setAttribute('type', 'range');\n        ccRedAdjust.setAttribute('max', 100);\n        ccRedAdjust.setAttribute('min', -100);\n        ccRedAdjust.setAttribute('value', 0);\n        ccRedAdjust.id = 'cc-red-slider';\n\n        let ccGreenDiv = document.createElement('div');\n        ccGreenDiv.classList.add('color-filters');\n        ccGreenDiv.classList.add('manipulation-tools-text');\n        let ccGreenAdjust = document.createElement('input');\n        let ccGreenText = document.createElement('label');\n        ccGreenText.textContent = 'CC Green';\n        ccGreenText.setAttribute('for', 'cc-green-slider');\n        ccGreenAdjust.setAttribute('type', 'range');\n        ccGreenAdjust.setAttribute('max', 100);\n        ccGreenAdjust.setAttribute('min', -100);\n        ccGreenAdjust.setAttribute('value', 0);\n        ccGreenAdjust.id = 'cc-green-slider';\n\n        let ccBlueDiv = document.createElement('div');\n        ccBlueDiv.classList.add('color-filters');\n        ccBlueDiv.classList.add('manipulation-tools-text');\n        let ccBlueAdjust = document.createElement('input');\n        let ccBlueText = document.createElement('label');\n        ccBlueText.textContent = 'CC Blue';\n        ccBlueText.setAttribute('for', 'cc-blue-slider');\n        ccBlueAdjust.setAttribute('type', 'range');\n        ccBlueAdjust.setAttribute('max', 100);\n        ccBlueAdjust.setAttribute('min', -100);\n        ccBlueAdjust.setAttribute('value', 0);\n        ccBlueAdjust.id = 'cc-blue-slider';\n\n        ccRedAdjust.addEventListener('change', debounce((e) => this._applyTransformationToImageData(e, _filters__WEBPACK_IMPORTED_MODULE_0__[\"ccRed\"], e.target.value), 250));\n        ccGreenAdjust.addEventListener('change', debounce((e) => this._applyTransformationToImageData(e, _filters__WEBPACK_IMPORTED_MODULE_0__[\"ccGreen\"], e.target.value), 250));\n        ccBlueAdjust.addEventListener('change', debounce((e) => this._applyTransformationToImageData(e, _filters__WEBPACK_IMPORTED_MODULE_0__[\"ccBlue\"], e.target.value), 250));\n\n        ccRedDiv.appendChild(ccRedAdjust);\n        ccRedDiv.appendChild(ccRedText);\n        ccGreenDiv.appendChild(ccGreenAdjust);\n        ccGreenDiv.appendChild(ccGreenText);\n        ccBlueDiv.appendChild(ccBlueAdjust);\n        ccBlueDiv.appendChild(ccBlueText);\n\n        // Threshold filter\n        let threshDiv = document.createElement('div');\n        threshDiv.style.display = 'none';\n        let thresholdAdjust = document.createElement('input');\n        let thresholdText = document.createElement('label');\n        thresholdText.textContent = 'Threshold';\n        thresholdText.setAttribute('for', 'threshold-slider');\n        threshDiv.classList.add('manipulation-tools-text');\n        thresholdAdjust.setAttribute('type', 'range');\n        thresholdAdjust.setAttribute('max', 255);\n        thresholdAdjust.setAttribute('min', 64);\n        thresholdAdjust.setAttribute('value', 0);\n        thresholdAdjust.id = 'threshold-slider';\n\n        thresholdAdjust.addEventListener('change', debounce((e) => this._applyTransformationToImageData(e, _filters__WEBPACK_IMPORTED_MODULE_0__[\"threshold\"], e.target.value), 250));\n        threshDiv.appendChild(thresholdAdjust);\n        threshDiv.appendChild(thresholdText);\n\n        // Reset button\n        let resetButton = document.createElement('button');\n        resetButton.setAttribute('style', 'margin-top: 1em;');\n        let buttonText = document.createTextNode('Reset');\n        resetButton.appendChild(buttonText);\n        resetButton.onclick = (e) => { this._loadImageInMainArea(e, this.currentImageURL); };\n\n        // Log to keep track of the order of filter application\n        let filterLog = document.createElement('div');\n        filterLog.classList.add('manipulation-tools-text');\n        filterLog.innerHTML = \"<h3> Filter Application Order <h3>\";\n        filterLog.id = 'filter-log';\n\n        this._tools.appendChild(closeButton);\n        this._tools.appendChild(header);\n        this._tools.appendChild(zoomDiv);\n        this._tools.appendChild(rotateDiv);\n        this._tools.appendChild(mirrorDiv);\n        this._tools.appendChild(filtersTitle);\n        this._tools.appendChild(bwDiv);\n        this._tools.appendChild(invDiv);\n        this._tools.appendChild(saturationDiv);\n        this._tools.appendChild(vibDiv);\n        this._tools.appendChild(brightDiv);\n        this._tools.appendChild(contrastDiv);\n        this._tools.appendChild(sharpDiv);\n        this._tools.appendChild(hueDiv);\n        this._tools.appendChild(gammaDiv);\n        this._tools.appendChild(ccRedDiv);\n        this._tools.appendChild(ccGreenDiv);\n        this._tools.appendChild(ccBlueDiv);\n        this._tools.appendChild(threshDiv);\n        this._tools.appendChild(resetButton);\n        this._tools.appendChild(filterLog);\n\n        this._tools.setAttribute('style', 'padding: 0 1em;');\n\n        function switchVisibleFilters ()\n        {\n            let filters = document.getElementsByClassName('color-filters');\n\n            if (this.value === 'threshold')\n            {\n                for (let i = 0, len = filters.length; i < len; i++)\n                {\n                    filters[i].style.display = 'none';\n                }\n\n                threshDiv.style.display = 'block';\n            }\n            else\n            {\n                for (let i = 0, len = filters.length; i < len; i++)\n                {\n                    filters[i].style.display = 'block';\n                }\n\n                threshDiv.style.display = 'none';\n            }\n        }\n    }\n\n    _resetSliders ()\n    {\n        // check if element is a slider, if so then reset\n        for (let i = 0, len = this._tools.children.length; i < len; i++)\n        {\n            let tool = this._tools.children[i].children[0];\n            if (tool && tool.type === 'range')\n                tool.value = 0;\n        }\n\n        document.getElementById('filter-log').innerHTML = \"<h3> Filter Application Order <h3>\";\n\n        // reset counters\n        this.zoom = 1;\n        this.rotate = 0;\n\n        // reset mirror\n        this.mirrorHorizontal = 1;\n        this.mirrorVertical = 1;\n        this.handleTransform(null, null, this.rotate);\n\n        Object(_filters__WEBPACK_IMPORTED_MODULE_0__[\"resetFilters\"])();\n    }\n\n    _loadImageInMainArea (event, imageURL)\n    {\n        this.currentImageURL = imageURL; // for resetting\n\n        let url = `${imageURL}full/full/0/default.jpg`;\n\n        this._mainImage = new Image();\n        this._mainImage.crossOrigin = \"anonymous\";\n\n        this._mainImage.addEventListener('load', () =>\n        {\n            // Determine the size of the (square) canvas based on the hypoteneuse\n            this._canvas.size = Math.sqrt(this._mainImage.width * this._mainImage.width + this._mainImage.height * this._mainImage.height);\n            this._canvas.width = this._canvas.size;\n            this._canvas.height = this._canvas.size;\n            this._canvas.cornerX = (this._canvas.size - this._mainImage.width) / 2;\n            this._canvas.cornerY = (this._canvas.size - this._mainImage.height) / 2;\n\n            this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n            this._ctx.drawImage(this._mainImage, this._canvas.cornerX, this._canvas.cornerY, this._mainImage.width, this._mainImage.height);\n            this._originalData = this._ctx.getImageData(this._canvas.cornerX, this._canvas.cornerY, this._mainImage.width, this._mainImage.height);\n            this._alteredData = this._originalData;\n\n            // to preserve pre-zoom dimensions\n            this.dims = {\n                w: this._canvas.width,\n                h: this._canvas.height\n            };\n\n            // clean up the image data since it's been painted to the canvas\n            this._mainImage = null;\n\n            // center the viewport\n            this.centerView();\n        });\n\n        this._mainImage.src = url;\n\n        this._resetSliders();\n    }\n\n    _applyTransformationToImageData (event, func, value)\n    {\n        let cw = this._canvas.width;\n        let ch = this._canvas.height;\n        let adjustment;\n\n        if (value)\n        {\n            adjustment = parseInt(value, 10);\n        }\n\n        let newData = func(this._originalData, adjustment);\n        this._alteredData = newData;\n\n        this._ctx.clearRect(0, 0, cw, ch);\n        this._ctx.putImageData(newData, this._canvas.cornerX, this._canvas.cornerY);\n\n        // necessary to reset the current zoom level (since ImageData gets altered at zoom 1)\n        this.handleZoom(event, this.zoom, false);\n    }\n\n    handleZoom (event, value, recenter)\n    {\n        let scale = value * 0.5 + 0.5;\n\n        let w = this.dims.w;\n        let h = this.dims.h;\n\n        // temp canvas for drawing at original zoom level\n        let tempCanvas = document.createElement('canvas');\n        let tempCtx = tempCanvas.getContext('2d');\n        tempCanvas.width = w;\n        tempCanvas.height = h;\n        tempCtx.putImageData(this._alteredData, this._canvas.cornerX, this._canvas.cornerY);\n\n        this._canvas.width = w * scale;\n        this._canvas.height = h * scale;\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n        this._ctx.scale(scale, scale);\n        this._ctx.drawImage(tempCanvas, 0, 0);\n\n        // determine if zooming in or not\n        let zoomingIn = value > this.zoom ? true : false;\n\n        this.zoom = parseInt(value, 10);\n\n        if (recenter)\n        {\n            let rect = event.target.getBoundingClientRect();\n            let x = event.clientX - rect.left;\n            let y = event.clientY - rect.top;\n\n            if (!zoomingIn)\n            {\n                // x & y are in terms of pre-zoom-out dimensions, so scale down accordingly\n                let scaleOut = (this.zoom * 0.5 + 0.5) / ((this.zoom + 1) * 0.5 + 0.5);\n                x *= scaleOut;\n                y *= scaleOut;\n            }\n\n            this.centerView(x, y, zoomingIn);\n        }\n    }\n\n    centerView (x, y, zoomingIn)\n    {\n        let view = document.getElementsByClassName('manipulation-main-area')[0];\n        if (!view)\n            view = document.getElementsByClassName('manipulation-main-area-mobile')[0];\n\n        if (zoomingIn)\n        {\n            // x & y are in terms of pre-zoom-in dimensions, so scale up accordingly\n            let scaleIn = (this.zoom * 0.5 + 0.5) / ((this.zoom - 1) * 0.5 + 0.5);\n            x *= scaleIn;\n            y *= scaleIn;\n        }\n\n        // distance from center\n        let center = this._canvas.height / 2;\n        let distY = y - center;\n        let distX = x - center;\n\n        let h = this._canvas.height;\n        let w = this._canvas.width;\n\n        let topCentered = (h - view.clientHeight) / 2;\n        let leftCentered = (w - view.clientWidth) / 2;\n\n        let top = y ? topCentered + distY : topCentered;\n        let left = x ? leftCentered + distX : leftCentered;\n\n        view.scrollTop = top;\n        view.scrollLeft = left;\n    }\n\n    handleTransform (event, type, value)\n    {\n        let canvas = document.getElementsByClassName('manipulation-main-area')[0].children[0];\n\n        if (type === 'vertical')\n            this.mirrorVertical *= -1;\n        else if (type === 'horizontal')\n            this.mirrorHorizontal *= -1;\n\n        canvas.style.transform = \"scale(\"+this.mirrorHorizontal+\",\"+this.mirrorVertical+\") rotate(\"+value+\"deg)\";\n\n        this.rotate = value;\n    }\n}\n\nManipulationPlugin.prototype.pluginName = \"manipulation\";\nManipulationPlugin.prototype.isPageTool = true;\n\n/**\n * Make this plugin available in the global context\n * as part of the 'Diva' namespace.\n **/\n(function (global)\n{\n    global.Diva.ManipulationPlugin = ManipulationPlugin;\n})(window);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvcGx1Z2lucy9tYW5pcHVsYXRpb24uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvcGx1Z2lucy9tYW5pcHVsYXRpb24uanM/YTAyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIGdyYXlzY2FsZSxcbiAgICBzYXR1cmF0aW9uLFxuICAgIHZpYnJhbmNlLFxuICAgIGJyaWdodG5lc3MsXG4gICAgY29udHJhc3QsXG4gICAgaHVlLFxuICAgIGdhbW1hLFxuICAgIGNjUmVkLFxuICAgIGNjR3JlZW4sXG4gICAgY2NCbHVlLFxuICAgIGludmVydCxcbiAgICB0aHJlc2hvbGQsXG4gICAgc2hhcnBlbixcbiAgICByZXNldEZpbHRlcnNcbn0gZnJvbSBcIi4vX2ZpbHRlcnNcIjtcbmltcG9ydCBnZXN0dXJlRXZlbnRzIGZyb20gJy4uL2dlc3R1cmUtZXZlbnRzJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlIChmdW5jLCB3YWl0LCBpbW1lZGlhdGUpXG57XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBsZXQgY29udGV4dCA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGxldCBsYXRlciA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgICBpZiAoY2FsbE5vdylcbiAgICAgICAge1xuICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qKlxuICogQSBEaXZhLmpzIHBsdWdpbiB0aGF0IGFsbG93cyB1c2VycyB0byBtYW5pcHVsYXRlIGltYWdlcyBieSBhZGp1c3RpbmcgdGhlaXJcbiAqIGJyaWdodG5lc3MsIGNvbnRyYXN0LCBhbmQgb3RoZXIgcGFyYW1ldGVycy5cbiAqKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hbmlwdWxhdGlvblBsdWdpblxue1xuICAgIGNvbnN0cnVjdG9yIChjb3JlKVxuICAgIHtcbiAgICAgICAgdGhpcy5fY29yZSA9IGNvcmU7XG4gICAgICAgIHRoaXMucGFnZVRvb2xzSWNvbiA9IHRoaXMuY3JlYXRlSWNvbigpO1xuICAgICAgICB0aGlzLl9iYWNrZHJvcCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9tYWluSW1hZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYW52YXMgPSBudWxsO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBkYXRhIGZvciB0aGUgb3JpZ2luYWwgbWFpbiBpbWFnZSBzbyB0aGF0IHdlXG4gICAgICAgIC8vIGRvIHRoZSBwcm9jZXNzaW5nIG9uIHRoYXQsIG5vdCBvbiBhIHByZXZpb3VzbHktcHJvY2Vzc2VkIGltYWdlLlxuICAgICAgICB0aGlzLl9vcmlnaW5hbERhdGEgPSBudWxsO1xuXG4gICAgICAgIC8vIHpvb20gc3R1ZmZcbiAgICAgICAgdGhpcy5tYXhab29tID0gNDtcbiAgICAgICAgdGhpcy5taW5ab29tID0gMTtcbiAgICAgICAgdGhpcy56b29tID0gMTtcblxuICAgICAgICB0aGlzLnJvdGF0ZSA9IDA7XG5cbiAgICAgICAgLy8gbWlycm9yIHN0dWZmLCAxIGZvciBub3QgbWlycm9yZWQsIC0xIGZvciBtaXJyb3JlZFxuICAgICAgICB0aGlzLm1pcnJvckhvcml6b250YWwgPSAxO1xuICAgICAgICB0aGlzLm1pcnJvclZlcnRpY2FsID0gMTtcblxuICAgICAgICB0aGlzLmJvdW5kRXNjYXBlTGlzdGVuZXIgPSB0aGlzLmVzY2FwZUxpc3RlbmVyLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gdXJsIG9mIGN1cnJlbnRseSBsb2FkZWQgaW1hZ2VcbiAgICAgICAgdGhpcy5jdXJyZW50SW1hZ2VVUkwgPSBudWxsO1xuICAgIH1cblxuICAgIGhhbmRsZUNsaWNrIChldmVudCwgc2V0dGluZ3MsIHB1YmxpY0luc3RhbmNlLCBwYWdlSW5kZXgpXG4gICAge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIHRoaXMuX2JhY2tkcm9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX2JhY2tkcm9wLmNsYXNzTGlzdC5hZGQoJ21hbmlwdWxhdGlvbi1mdWxsc2NyZWVuJyk7XG5cbiAgICAgICAgdGhpcy5fc2lkZWJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9zaWRlYmFyLmNsYXNzTGlzdC5hZGQoJ21hbmlwdWxhdGlvbi1zaWRlYmFyJyk7XG5cbiAgICAgICAgdGhpcy5fbWFpbkFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fbWFpbkFyZWEuY2xhc3NMaXN0LmFkZCgnbWFuaXB1bGF0aW9uLW1haW4tYXJlYScpO1xuXG4gICAgICAgIC8vIGVuYWJsZSBzY3JvbGwgYnkgZHJhZ2dpbmdcbiAgICAgICAgdGhpcy5fbWFpbkFyZWEuY2xhc3NMaXN0LmFkZCgnZHJhZ3Njcm9sbCcpO1xuICAgICAgICB0aGlzLl9tYWluQXJlYS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoKSA9PiB7IHRoaXMuX21haW5BcmVhLmNsYXNzTGlzdC5hZGQoJ2dyYWJiaW5nJyk7IH0pO1xuICAgICAgICB0aGlzLl9tYWluQXJlYS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKCkgPT4geyB0aGlzLl9tYWluQXJlYS5jbGFzc0xpc3QucmVtb3ZlKCdncmFiYmluZycpOyB9KTtcblxuICAgICAgICAvLyBhZGQgZG91YmxlIGNsaWNrIHpvb20gaGFuZGxlclxuICAgICAgICBnZXN0dXJlRXZlbnRzLm9uRG91YmxlQ2xpY2sodGhpcy5fbWFpbkFyZWEsIHRoaXMuaGFuZGxlRGJsQ2xpY2suYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy5fdG9vbHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fdG9vbHMuY2xhc3NMaXN0LmFkZCgnbWFuaXB1bGF0aW9uLXRvb2xzJyk7XG5cbiAgICAgICAgdGhpcy5fYmFja2Ryb3AuYXBwZW5kQ2hpbGQodGhpcy5fc2lkZWJhcik7XG4gICAgICAgIHRoaXMuX2JhY2tkcm9wLmFwcGVuZENoaWxkKHRoaXMuX21haW5BcmVhKTtcbiAgICAgICAgdGhpcy5fYmFja2Ryb3AuYXBwZW5kQ2hpbGQodGhpcy5fdG9vbHMpO1xuXG4gICAgICAgIHRoaXMuX2NvcmUucGFyZW50T2JqZWN0LmFwcGVuZENoaWxkKHRoaXMuX2JhY2tkcm9wKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLmJvdW5kRXNjYXBlTGlzdGVuZXIpO1xuXG4gICAgICAgIHRoaXMuX3BhZ2UgPSBzZXR0aW5ncy5tYW5pZmVzdC5wYWdlc1twYWdlSW5kZXhdO1xuXG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0aGlzLl9jdHggPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdGhpcy5fbWFpbkFyZWEuYXBwZW5kQ2hpbGQodGhpcy5fY2FudmFzKTtcblxuICAgICAgICB0aGlzLl9pbml0aWFsaXplU2lkZWJhcigpO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplVG9vbHMoKTtcblxuICAgICAgICB3aW5kb3cucmVzZXREcmFnc2Nyb2xsKCk7XG4gICAgICAgIHRoaXMuX2xvYWRJbWFnZUluTWFpbkFyZWEoZXZlbnQsIHRoaXMuX3BhZ2UudXJsKTtcblxuICAgICAgICAvLyBoaWRlIHRvb2xiYXIgaWYgZnVsbHNjcmVlblxuICAgICAgICBpZiAoc2V0dGluZ3MuaW5GdWxsc2NyZWVuKVxuICAgICAgICB7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZXR0aW5ncy5zZWxlY3RvciArICd0b29scycpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgc21hbGxlciB2aWV3cG9ydFxuICAgICAgICBpZiAod2luZG93LmlubmVyV2lkdGggPD0gMTAwMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbWFpbkFyZWEuY2xhc3NMaXN0LnJlbW92ZSgnbWFuaXB1bGF0aW9uLW1haW4tYXJlYScpO1xuICAgICAgICAgICAgdGhpcy5fbWFpbkFyZWEuY2xhc3NMaXN0LmFkZCgnbWFuaXB1bGF0aW9uLW1haW4tYXJlYS1tb2JpbGUnKTtcbiAgICAgICAgICAgIHRoaXMuX3NpZGViYXIuY2xhc3NMaXN0LnJlbW92ZSgnbWFuaXB1bGF0aW9uLXNpZGViYXInKTtcbiAgICAgICAgICAgIHRoaXMuX3NpZGViYXIuY2xhc3NMaXN0LmFkZCgnbWFuaXB1bGF0aW9uLXNpZGViYXItbW9iaWxlJyk7XG4gICAgICAgICAgICB0aGlzLl90b29scy5jbGFzc0xpc3QucmVtb3ZlKCdtYW5pcHVsYXRpb24tdG9vbHMnKTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2xzLmNsYXNzTGlzdC5hZGQoJ21hbmlwdWxhdGlvbi10b29scy1tb2JpbGUnKTtcblxuICAgICAgICAgICAgLy8gYWRkIGhhbWJ1cmdlciBtZW51c1xuICAgICAgICAgICAgbGV0IGJ1cmdlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgYnVyZ2VyLmNsYXNzTGlzdC5hZGQoJ2J1cmdlci1tZW51Jyk7XG4gICAgICAgICAgICBsZXQgczEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGxldCBzMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbGV0IHMzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBzMS5jbGFzc0xpc3QuYWRkKCdzdHJpcGUnKTtcbiAgICAgICAgICAgIHMyLmNsYXNzTGlzdC5hZGQoJ3N0cmlwZScpO1xuICAgICAgICAgICAgczMuY2xhc3NMaXN0LmFkZCgnc3RyaXBlJyk7XG5cbiAgICAgICAgICAgIGJ1cmdlci5hcHBlbmRDaGlsZChzMSk7XG4gICAgICAgICAgICBidXJnZXIuYXBwZW5kQ2hpbGQoczIpO1xuICAgICAgICAgICAgYnVyZ2VyLmFwcGVuZENoaWxkKHMzKTtcblxuICAgICAgICAgICAgdGhpcy5idXJnZXJDbGlja2VkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGJ1cmdlci5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJ1cmdlckNsaWNrZWQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaWRlYmFyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2xzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21haW5BcmVhLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaWRlYmFyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29scy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFpbkFyZWEuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5idXJnZXJDbGlja2VkID0gIXRoaXMuYnVyZ2VyQ2xpY2tlZDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX2JhY2tkcm9wLmFwcGVuZENoaWxkKGJ1cmdlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVEYmxDbGljayAoZXZlbnQpXG4gICAge1xuICAgICAgICBsZXQgbmV3Wm9vbSA9IGV2ZW50LmN0cmxLZXkgPyB0aGlzLnpvb20gLSAxIDogdGhpcy56b29tICsgMTtcbiAgICAgICAgaWYgKG5ld1pvb20gPCB0aGlzLm1pblpvb20gfHwgbmV3Wm9vbSA+IHRoaXMubWF4Wm9vbSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAvLyB1cGRhdGUgc2xpZGVyXG4gICAgICAgIGxldCBzbGlkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnem9vbS1zbGlkZXInKTtcbiAgICAgICAgc2xpZGVyLnZhbHVlID0gbmV3Wm9vbTtcblxuICAgICAgICB0aGlzLmhhbmRsZVpvb20oZXZlbnQsIG5ld1pvb20sIHRydWUpO1xuICAgIH1cblxuICAgIC8qXG4gICAgKiAgUmV0dXJucyBhbiBTVkcgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaWNvbiBmb3IgdGhlIHByb2plY3QuIEltcGxlbWVudGVkIGluIGNvZGVcbiAgICAqICBoZXJlIHNvIHRoYXQgdGhlIGVudGlyZSBEaXZhIG9iamVjdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBjbGllbnQgd2l0aCBubyBleHRlcm5hbFxuICAgICogIGRlcGVuZGVuY2llcy5cbiAgICAqKi9cbiAgICBjcmVhdGVJY29uICgpXG4gICAge1xuICAgICAgICBjb25zdCBtYW5pcHVsYXRpb25JY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG1hbmlwdWxhdGlvbkljb24uY2xhc3NMaXN0LmFkZCgnZGl2YS1tYW5pcHVsYXRpb24taWNvbicpO1xuXG4gICAgICAgIGxldCByb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIik7XG4gICAgICAgIHJvb3Quc2V0QXR0cmlidXRlKFwieFwiLCBcIjBweFwiKTtcbiAgICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoXCJ5XCIsIFwiMHB4XCIpO1xuICAgICAgICByb290LnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgXCIwIDAgMjUgMjVcIik7XG4gICAgICAgIHJvb3QuaWQgPSBgJHt0aGlzLl9jb3JlLnNldHRpbmdzLnNlbGVjdG9yfW1hbmlwdWxhdGlvbi1pY29uYDtcblxuICAgICAgICBsZXQgZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTtcbiAgICAgICAgZy5pZCA9IGAke3RoaXMuX2NvcmUuc2V0dGluZ3Muc2VsZWN0b3J9bWFuaXB1bGF0aW9uLWljb24tZ2x5cGhgO1xuICAgICAgICBnLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcIm1hdHJpeCgxLCAwLCAwLCAxLCAtMTEuNSwgLTExLjUpXCIpO1xuICAgICAgICBnLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiZGl2YS1wYWdldG9vbC1pY29uXCIpO1xuXG4gICAgICAgIGxldCBwYXRoMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicGF0aFwiKTtcbiAgICAgICAgcGF0aDEuc2V0QXR0cmlidXRlKFwiZFwiLCBcIk0yNywyMWgtMXYtOWgtM3Y5aC0xYy0wLjU1LDAtMSwwLjQ1LTEsMXYzYzAsMC41NSwwLjQ1LDEsMSwxaDFoM2gxYzAuNTUsMCwxLTAuNDUsMS0xdi0zQzI4LDIxLjQ1LDI3LjU1LDIxLDI3LDIxeiBNMjcsMjRoLTV2LTAuNWg1VjI0elwiKTtcblxuICAgICAgICBsZXQgcGF0aDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInBhdGhcIik7XG4gICAgICAgIHBhdGgyLnNldEF0dHJpYnV0ZShcImRcIiwgXCJNMzUsMTZoLTF2LTRoLTN2NGgtMWMtMC41NSwwLTEsMC40NS0xLDF2M2MwLDAuNTUsMC40NSwxLDEsMWgxaDNoMWMwLjU1LDAsMS0wLjQ1LDEtMXYtM0MzNiwxNi40NSwzNS41NSwxNiwzNSwxNnogTTM1LDE5aC01di0wLjVoNVYxOXpcIik7XG5cbiAgICAgICAgbGV0IHBhdGgzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJwYXRoXCIpO1xuICAgICAgICBwYXRoMy5zZXRBdHRyaWJ1dGUoXCJkXCIsIFwiTTE5LDI2aC0xVjEyaC0zdjE0aC0xYy0wLjU1LDAtMSwwLjQ1LTEsMXYzYzAsMC41NSwwLjQ1LDEsMSwxaDFoM2gxYzAuNTUsMCwxLTAuNDUsMS0xdi0zQzIwLDI2LjQ1LDE5LjU1LDI2LDE5LDI2ek0xOSwyOWgtNXYtMC41aDVWMjl6XCIpO1xuXG4gICAgICAgIGxldCByZWN0MSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicmVjdFwiKTtcbiAgICAgICAgcmVjdDEuc2V0QXR0cmlidXRlKCd4JywgJzIzJyk7XG4gICAgICAgIHJlY3QxLnNldEF0dHJpYnV0ZSgneScsICcyNycpO1xuICAgICAgICByZWN0MS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzMnKTtcbiAgICAgICAgcmVjdDEuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnOScpO1xuXG4gICAgICAgIGxldCByZWN0MiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicmVjdFwiKTtcbiAgICAgICAgcmVjdDIuc2V0QXR0cmlidXRlKCd4JywgJzMxJyk7XG4gICAgICAgIHJlY3QyLnNldEF0dHJpYnV0ZSgneScsICcyMicpO1xuICAgICAgICByZWN0Mi5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzMnKTtcbiAgICAgICAgcmVjdDIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnMTQnKTtcblxuICAgICAgICBsZXQgcmVjdDMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInJlY3RcIik7XG4gICAgICAgIHJlY3QzLnNldEF0dHJpYnV0ZSgneCcsICcxNScpO1xuICAgICAgICByZWN0My5zZXRBdHRyaWJ1dGUoJ3knLCAnMzInKTtcbiAgICAgICAgcmVjdDMuc2V0QXR0cmlidXRlKCd3aWR0aCcsICczJyk7XG4gICAgICAgIHJlY3QzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzQnKTtcblxuICAgICAgICBnLmFwcGVuZENoaWxkKHBhdGgxKTtcbiAgICAgICAgZy5hcHBlbmRDaGlsZChwYXRoMik7XG4gICAgICAgIGcuYXBwZW5kQ2hpbGQocmVjdDEpO1xuICAgICAgICBnLmFwcGVuZENoaWxkKHBhdGgzKTtcbiAgICAgICAgZy5hcHBlbmRDaGlsZChyZWN0Mik7XG4gICAgICAgIGcuYXBwZW5kQ2hpbGQocmVjdDMpO1xuICAgICAgICByb290LmFwcGVuZENoaWxkKGcpO1xuXG4gICAgICAgIG1hbmlwdWxhdGlvbkljb24uYXBwZW5kQ2hpbGQocm9vdCk7XG5cbiAgICAgICAgcmV0dXJuIG1hbmlwdWxhdGlvbkljb247XG4gICAgfVxuXG4gICAgZXNjYXBlTGlzdGVuZXIgKGV2ZW50KVxuICAgIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDI3KVxuICAgICAgICB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuYm91bmRFc2NhcGVMaXN0ZW5lcik7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xuICAgICAgICAgICAgdGhpcy5fY29yZS5wYXJlbnRPYmplY3QucmVtb3ZlQ2hpbGQodGhpcy5fYmFja2Ryb3ApO1xuXG4gICAgICAgICAgICAvLyBzaG93IHRvb2xiYXJcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGAke3RoaXMuX2NvcmUuc2V0dGluZ3Muc2VsZWN0b3J9dG9vbHNgKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9pbml0aWFsaXplU2lkZWJhciAoKVxuICAgIHtcbiAgICAgICAgLy8gMTUwcHggd2lkZSBpbWFnZXMgZm9yIHRoZSBzaWRlYmFyLlxuICAgICAgICBsZXQgdGh1bWJuYWlsU2l6ZSA9IFwiMTUwXCI7XG4gICAgICAgIGxldCBtYWluUGFnZVNpZGViYXJJbWFnZVVSTCA9IGAke3RoaXMuX3BhZ2UudXJsfWZ1bGwvJHt0aHVtYm5haWxTaXplfSwvMC9kZWZhdWx0LmpwZ2A7XG5cbiAgICAgICAgbGV0IG90aGVySW1hZ2VVUkxzID0gdGhpcy5fcGFnZS5vdGhlckltYWdlcy5tYXAoKGltZykgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGAke2ltZy51cmx9ZnVsbC8ke3RodW1ibmFpbFNpemV9LC8wL2RlZmF1bHQuanBnYDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IHByaW1hcnlJbWdEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcHJpbWFyeUltZ0Rpdi5jbGFzc0xpc3QuYWRkKCdtYW5pcHVsYXRpb24tc2lkZWJhci1wcmltYXJ5LWltYWdlJyk7XG5cbiAgICAgICAgbGV0IHByaW1hcnlJbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgcHJpbWFyeUltZy5zZXRBdHRyaWJ1dGUoJ3NyYycsIG1haW5QYWdlU2lkZWJhckltYWdlVVJMKTtcblxuICAgICAgICBsZXQgcHJpbWFyeUltZ0xhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHByaW1hcnlJbWdMYWJlbC50ZXh0Q29udGVudCA9IHRoaXMuX3BhZ2UuaWw7XG5cbiAgICAgICAgcHJpbWFyeUltZ0Rpdi5hcHBlbmRDaGlsZChwcmltYXJ5SW1nKTtcbiAgICAgICAgcHJpbWFyeUltZ0Rpdi5hcHBlbmRDaGlsZChwcmltYXJ5SW1nTGFiZWwpO1xuXG4gICAgICAgIHRoaXMuX3NpZGViYXIuYXBwZW5kQ2hpbGQocHJpbWFyeUltZ0Rpdik7XG5cbiAgICAgICAgcHJpbWFyeUltZ0Rpdi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRJbWFnZUluTWFpbkFyZWEuY2FsbCh0aGlzLCBldmVudCwgdGhpcy5fcGFnZS51cmwpO1xuICAgICAgICB9KTtcblxuICAgICAgICBvdGhlckltYWdlVVJMcy5tYXAoKHVybCwgaWR4KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgb3RoRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBvdGhEaXYuY2xhc3NMaXN0LmFkZCgnbWFuaXB1bGF0aW9uLXNpZGViYXItc2Vjb25kYXJ5LWltYWdlJyk7XG5cbiAgICAgICAgICAgIGxldCBvdGhJbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgIG90aEltZy5zZXRBdHRyaWJ1dGUoJ3NyYycsIHVybCk7XG5cbiAgICAgICAgICAgIGxldCBvdGhJbWdMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgb3RoSW1nTGFiZWwudGV4dENvbnRlbnQgPSB0aGlzLl9wYWdlLm90aGVySW1hZ2VzW2lkeF0uaWw7XG5cbiAgICAgICAgICAgIG90aERpdi5hcHBlbmRDaGlsZChvdGhJbWcpO1xuICAgICAgICAgICAgb3RoRGl2LmFwcGVuZENoaWxkKG90aEltZ0xhYmVsKTtcblxuICAgICAgICAgICAgdGhpcy5fc2lkZWJhci5hcHBlbmRDaGlsZChvdGhEaXYpO1xuXG4gICAgICAgICAgICBvdGhEaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLl9sb2FkSW1hZ2VJbk1haW5BcmVhLmNhbGwodGhpcywgZXZlbnQsIHRoaXMuX3BhZ2Uub3RoZXJJbWFnZXNbaWR4XS51cmwpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2luaXRpYWxpemVUb29scyAoKVxuICAgIHtcbiAgICAgICAgLy8gQ2xvc2UgYnV0dG9uXG4gICAgICAgIGxldCBjbG9zZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuXG4gICAgICAgIGNsb3NlQnV0dG9uLmlubmVySFRNTCA9ICcmIzEwMDA2JztcbiAgICAgICAgY2xvc2VCdXR0b24uY2xhc3NMaXN0LmFkZCgnY2xvc2UtYnV0dG9uJyk7XG4gICAgICAgIGNsb3NlQnV0dG9uLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogYWJzb2x1dGU7IHRvcDogMWVtOyByaWdodDogMWVtOycpO1xuXG4gICAgICAgIGNsb3NlQnV0dG9uLm9uY2xpY2sgPSAoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xuICAgICAgICAgICAgdGhpcy5fY29yZS5wYXJlbnRPYmplY3QucmVtb3ZlQ2hpbGQodGhpcy5fYmFja2Ryb3ApO1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fY29yZS5zZXR0aW5ncy5zZWxlY3RvciArICd0b29scycpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEhlYWRlciB0aXRsZVxuICAgICAgICBsZXQgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKTtcblxuICAgICAgICBoZWFkZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdtYXJnaW4tYm90dG9tOiAwLjNlbTsnKTtcbiAgICAgICAgaGVhZGVyLmNsYXNzTGlzdC5hZGQoJ21hbmlwdWxhdGlvbi10b29scy10ZXh0Jyk7XG4gICAgICAgIGhlYWRlci5pbm5lclRleHQgPSAnSW1hZ2UgdG9vbHMnO1xuXG4gICAgICAgIC8vIFpvb20gdG9vbFxuICAgICAgICBsZXQgem9vbURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBsZXQgem9vbUFkanVzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGxldCB6b29tVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIHpvb21UZXh0LnRleHRDb250ZW50ID0gJ1pvb20nO1xuICAgICAgICB6b29tVGV4dC5zZXRBdHRyaWJ1dGUoJ2ZvcicsICd6b29tLXNsaWRlcicpO1xuXG4gICAgICAgIHpvb21EaXYuY2xhc3NMaXN0LmFkZCgnbWFuaXB1bGF0aW9uLXRvb2xzLXRleHQnKTtcbiAgICAgICAgem9vbUFkanVzdC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAncmFuZ2UnKTtcbiAgICAgICAgem9vbUFkanVzdC5zZXRBdHRyaWJ1dGUoJ21heCcsIHRoaXMubWF4Wm9vbSk7XG4gICAgICAgIHpvb21BZGp1c3Quc2V0QXR0cmlidXRlKCdtaW4nLCB0aGlzLm1pblpvb20pO1xuICAgICAgICB6b29tQWRqdXN0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCB0aGlzLnpvb20pO1xuICAgICAgICB6b29tQWRqdXN0LmlkID0gJ3pvb20tc2xpZGVyJztcbiAgICAgICAgem9vbURpdi5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBkZWJvdW5jZSgoZSkgPT4gdGhpcy5oYW5kbGVab29tKGUsIGUudGFyZ2V0LnZhbHVlLCB0cnVlKSwgMjUwKSk7XG4gICAgICAgIHpvb21EaXYuYXBwZW5kQ2hpbGQoem9vbUFkanVzdCk7XG4gICAgICAgIHpvb21EaXYuYXBwZW5kQ2hpbGQoem9vbVRleHQpO1xuXG4gICAgICAgIC8vIFJvdGF0aW9uIHRvb2xcbiAgICAgICAgbGV0IHJvdGF0ZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBsZXQgcm90YXRlQWRqdXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgbGV0IHJvdGF0ZVRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICByb3RhdGVUZXh0LnRleHRDb250ZW50ID0gJ1JvdGF0aW9uJztcbiAgICAgICAgcm90YXRlVGV4dC5zZXRBdHRyaWJ1dGUoJ2ZvcicsICdyb3RhdGUtc2xpZGVyJyk7XG5cbiAgICAgICAgcm90YXRlRGl2LmNsYXNzTGlzdC5hZGQoJ21hbmlwdWxhdGlvbi10b29scy10ZXh0Jyk7XG4gICAgICAgIHJvdGF0ZUFkanVzdC5pZCA9ICdyb3RhdGUtc2xpZGVyJztcbiAgICAgICAgcm90YXRlQWRqdXN0LnNldEF0dHJpYnV0ZSgndHlwZScsICdyYW5nZScpO1xuICAgICAgICByb3RhdGVBZGp1c3Quc2V0QXR0cmlidXRlKCdtYXgnLCAzNTkpO1xuICAgICAgICByb3RhdGVBZGp1c3Quc2V0QXR0cmlidXRlKCdtaW4nLCAwKTtcbiAgICAgICAgcm90YXRlQWRqdXN0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCAwKTtcblxuICAgICAgICByb3RhdGVEaXYuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoZSkgPT4geyB0aGlzLmhhbmRsZVRyYW5zZm9ybShlLCBudWxsLCBlLnRhcmdldC52YWx1ZSk7IH0pO1xuICAgICAgICByb3RhdGVEaXYuYXBwZW5kQ2hpbGQocm90YXRlQWRqdXN0KTtcbiAgICAgICAgcm90YXRlRGl2LmFwcGVuZENoaWxkKHJvdGF0ZVRleHQpO1xuXG4gICAgICAgIC8vIE1pcnJvciB0b29sXG4gICAgICAgIGxldCBtaXJyb3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbGV0IHZlcnRpY2FsTWlycm9yQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIHZlcnRpY2FsTWlycm9yQnV0dG9uLmlkID0gJ3ZlcnRpY2FsLW1pcnJvci1idXR0b24nO1xuICAgICAgICBsZXQgaG9yaXpvbnRhbE1pcnJvckJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBob3Jpem9udGFsTWlycm9yQnV0dG9uLmlkID0gJ2hvcml6b250YWwtbWlycm9yLWJ1dHRvbic7XG5cbiAgICAgICAgdmVydGljYWxNaXJyb3JCdXR0b24udGV4dENvbnRlbnQgPSBcIk1pcnJvciBWZXJ0aWNhbGx5XCI7XG4gICAgICAgIGhvcml6b250YWxNaXJyb3JCdXR0b24udGV4dENvbnRlbnQgPSBcIk1pcnJvciBIb3Jpem9udGFsbHlcIjtcbiAgICAgICAgdmVydGljYWxNaXJyb3JCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4gdGhpcy5oYW5kbGVUcmFuc2Zvcm0oZSwgJ3ZlcnRpY2FsJywgdGhpcy5yb3RhdGUpKTtcbiAgICAgICAgaG9yaXpvbnRhbE1pcnJvckJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB0aGlzLmhhbmRsZVRyYW5zZm9ybShlLCAnaG9yaXpvbnRhbCcsIHRoaXMucm90YXRlKSk7XG4gICAgICAgIG1pcnJvckRpdi5hcHBlbmRDaGlsZCh2ZXJ0aWNhbE1pcnJvckJ1dHRvbik7XG4gICAgICAgIG1pcnJvckRpdi5hcHBlbmRDaGlsZChob3Jpem9udGFsTWlycm9yQnV0dG9uKTtcblxuICAgICAgICAvLyBGaWx0ZXJzIHRpdGxlXG4gICAgICAgIGxldCBmaWx0ZXJzVGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZmlsdGVyc1RpdGxlLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnbWFyZ2luOiAxZW0gMDsnKTtcblxuICAgICAgICBsZXQgdGl0bGVUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDMnKTtcbiAgICAgICAgdGl0bGVUZXh0LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnbWFyZ2luOiAwOycpO1xuICAgICAgICB0aXRsZVRleHQuY2xhc3NMaXN0LmFkZCgnbWFuaXB1bGF0aW9uLXRvb2xzLXRleHQnKTtcbiAgICAgICAgdGl0bGVUZXh0LmlubmVyVGV4dCA9ICdGaWx0ZXJzJztcbiAgICAgICAgdGl0bGVUZXh0LmlkID0gJ2ZpbHRlcnMtdGl0bGUnO1xuXG4gICAgICAgIC8vIFNlbGVjdGlvbiBvcHRpb25zIChjb2xvciBmaWx0ZXJzIG9yIHRocmVzaG9sZClcbiAgICAgICAgbGV0IHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICAgICAgICBzZWxlY3QuaWQgPSAnZmlsdGVyLXNlbGVjdCc7XG4gICAgICAgIHNlbGVjdC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnd2hpdGUnO1xuICAgICAgICBzZWxlY3Quc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsbGVkYnknLCAnZmlsdGVycy10aXRsZScpO1xuXG4gICAgICAgIGxldCBjb2xvckZpbHRlcnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgICAgY29sb3JGaWx0ZXJzLnZhbHVlID0gJ2NvbG91cnMnO1xuICAgICAgICBjb2xvckZpbHRlcnMuaW5uZXJUZXh0ID0gJ0NvbG9yIEZpbHRlcnMnO1xuXG4gICAgICAgIGxldCBvdGhlckZpbHRlcnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgICAgb3RoZXJGaWx0ZXJzLnZhbHVlID0gJ3RocmVzaG9sZCc7XG4gICAgICAgIG90aGVyRmlsdGVycy5pbm5lclRleHQgPSAnVGhyZXNob2xkJztcblxuICAgICAgICBzZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgc3dpdGNoVmlzaWJsZUZpbHRlcnMpO1xuICAgICAgICBzZWxlY3QuYXBwZW5kQ2hpbGQoY29sb3JGaWx0ZXJzKTtcbiAgICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKG90aGVyRmlsdGVycyk7XG4gICAgICAgIGZpbHRlcnNUaXRsZS5hcHBlbmRDaGlsZCh0aXRsZVRleHQpO1xuICAgICAgICBmaWx0ZXJzVGl0bGUuYXBwZW5kQ2hpbGQoc2VsZWN0KTtcblxuICAgICAgICAvLyBHcmF5c2NhbGUgZmlsdGVyXG4gICAgICAgIGxldCBid0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBid0Rpdi5jbGFzc0xpc3QuYWRkKCdjb2xvci1maWx0ZXJzJyk7XG4gICAgICAgIGxldCBibGFja1doaXRlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGJsYWNrV2hpdGVCdXR0b24udGV4dENvbnRlbnQgPSBcIkdyYXlzY2FsZVwiO1xuICAgICAgICBibGFja1doaXRlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHRoaXMuX2FwcGx5VHJhbnNmb3JtYXRpb25Ub0ltYWdlRGF0YShlLCBncmF5c2NhbGUpKTtcbiAgICAgICAgYndEaXYuYXBwZW5kQ2hpbGQoYmxhY2tXaGl0ZUJ1dHRvbik7XG5cbiAgICAgICAgLy8gU2F0dXJhdGlvbiBmaWx0ZXJcbiAgICAgICAgbGV0IHNhdHVyYXRpb25EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc2F0dXJhdGlvbkRpdi5jbGFzc0xpc3QuYWRkKCdjb2xvci1maWx0ZXJzJyk7XG4gICAgICAgIHNhdHVyYXRpb25EaXYuY2xhc3NMaXN0LmFkZCgnbWFuaXB1bGF0aW9uLXRvb2xzLXRleHQnKTtcbiAgICAgICAgbGV0IHNhdHVyYXRpb25BZGp1c3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBsZXQgc2F0dXJhdGlvblRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICBzYXR1cmF0aW9uVGV4dC50ZXh0Q29udGVudCA9ICdTYXR1cmF0aW9uJztcbiAgICAgICAgc2F0dXJhdGlvblRleHQuc2V0QXR0cmlidXRlKCdmb3InLCAnc2F0dXJhdGlvbi1zbGlkZXInKTtcbiAgICAgICAgc2F0dXJhdGlvbkFkanVzdC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAncmFuZ2UnKTtcbiAgICAgICAgc2F0dXJhdGlvbkFkanVzdC5zZXRBdHRyaWJ1dGUoJ21heCcsIDEwMCk7XG4gICAgICAgIHNhdHVyYXRpb25BZGp1c3Quc2V0QXR0cmlidXRlKCdtaW4nLCAtMTAwKTtcbiAgICAgICAgc2F0dXJhdGlvbkFkanVzdC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgMCk7XG4gICAgICAgIHNhdHVyYXRpb25BZGp1c3QuaWQgPSAnc2F0dXJhdGlvbi1zbGlkZXInO1xuXG4gICAgICAgIHNhdHVyYXRpb25BZGp1c3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZGVib3VuY2UoKGUpID0+IHRoaXMuX2FwcGx5VHJhbnNmb3JtYXRpb25Ub0ltYWdlRGF0YShlLCBzYXR1cmF0aW9uLCBlLnRhcmdldC52YWx1ZSksIDI1MCkpO1xuICAgICAgICBzYXR1cmF0aW9uRGl2LmFwcGVuZENoaWxkKHNhdHVyYXRpb25BZGp1c3QpO1xuICAgICAgICBzYXR1cmF0aW9uRGl2LmFwcGVuZENoaWxkKHNhdHVyYXRpb25UZXh0KTtcblxuICAgICAgICAvLyBWaWJyYW5jZSBmaWx0ZXJcbiAgICAgICAgbGV0IHZpYkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB2aWJEaXYuY2xhc3NMaXN0LmFkZCgnY29sb3ItZmlsdGVycycpO1xuICAgICAgICB2aWJEaXYuY2xhc3NMaXN0LmFkZCgnbWFuaXB1bGF0aW9uLXRvb2xzLXRleHQnKTtcbiAgICAgICAgbGV0IHZpYnJhbmNlQWRqdXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgbGV0IHZpYnJhbmNlVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIHZpYnJhbmNlVGV4dC50ZXh0Q29udGVudCA9ICdWaWJyYW5jZSc7XG4gICAgICAgIHZpYnJhbmNlVGV4dC5zZXRBdHRyaWJ1dGUoJ2ZvcicsICd2aWJyYW5jZS1zbGlkZXInKTtcbiAgICAgICAgdmlicmFuY2VBZGp1c3Quc2V0QXR0cmlidXRlKCd0eXBlJywgJ3JhbmdlJyk7XG4gICAgICAgIHZpYnJhbmNlQWRqdXN0LnNldEF0dHJpYnV0ZSgnbWF4JywgMTAwKTtcbiAgICAgICAgdmlicmFuY2VBZGp1c3Quc2V0QXR0cmlidXRlKCdtaW4nLCAtMTAwKTtcbiAgICAgICAgdmlicmFuY2VBZGp1c3Quc2V0QXR0cmlidXRlKCd2YWx1ZScsIDApO1xuICAgICAgICB2aWJyYW5jZUFkanVzdC5pZCA9ICd2aWJyYW5jZS1zbGlkZXInO1xuXG4gICAgICAgIHZpYnJhbmNlQWRqdXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGRlYm91bmNlKChlKSA9PiB0aGlzLl9hcHBseVRyYW5zZm9ybWF0aW9uVG9JbWFnZURhdGEoZSwgdmlicmFuY2UsIGUudGFyZ2V0LnZhbHVlKSwgMjUwKSk7XG4gICAgICAgIHZpYkRpdi5hcHBlbmRDaGlsZCh2aWJyYW5jZUFkanVzdCk7XG4gICAgICAgIHZpYkRpdi5hcHBlbmRDaGlsZCh2aWJyYW5jZVRleHQpO1xuXG4gICAgICAgIC8vIEJyaWdodG5lc3MgZmlsdGVyXG4gICAgICAgIGxldCBicmlnaHREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYnJpZ2h0RGl2LmNsYXNzTGlzdC5hZGQoJ2NvbG9yLWZpbHRlcnMnKTtcbiAgICAgICAgYnJpZ2h0RGl2LmNsYXNzTGlzdC5hZGQoJ21hbmlwdWxhdGlvbi10b29scy10ZXh0Jyk7XG4gICAgICAgIGxldCBicmlnaHRuZXNzQWRqdXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgbGV0IGJyaWdodG5lc3NUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgYnJpZ2h0bmVzc1RleHQuc2V0QXR0cmlidXRlKCdmb3InLCAnYnJpZ2h0bmVzcy1zbGlkZXInKTtcbiAgICAgICAgYnJpZ2h0bmVzc1RleHQudGV4dENvbnRlbnQgPSAnQnJpZ2h0bmVzcyc7XG4gICAgICAgIGJyaWdodG5lc3NBZGp1c3Quc2V0QXR0cmlidXRlKCd0eXBlJywgJ3JhbmdlJyk7XG4gICAgICAgIGJyaWdodG5lc3NBZGp1c3Quc2V0QXR0cmlidXRlKCdtYXgnLCAxMDApO1xuICAgICAgICBicmlnaHRuZXNzQWRqdXN0LnNldEF0dHJpYnV0ZSgnbWluJywgLTEwMCk7XG4gICAgICAgIGJyaWdodG5lc3NBZGp1c3Quc2V0QXR0cmlidXRlKCd2YWx1ZScsIDApO1xuICAgICAgICBicmlnaHRuZXNzQWRqdXN0LmlkID0gJ2JyaWdodG5lc3Mtc2xpZGVyJztcblxuICAgICAgICBicmlnaHRuZXNzQWRqdXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGRlYm91bmNlKChlKSA9PiB0aGlzLl9hcHBseVRyYW5zZm9ybWF0aW9uVG9JbWFnZURhdGEoZSwgYnJpZ2h0bmVzcywgZS50YXJnZXQudmFsdWUpLCAyNTApKTtcbiAgICAgICAgYnJpZ2h0RGl2LmFwcGVuZENoaWxkKGJyaWdodG5lc3NBZGp1c3QpO1xuICAgICAgICBicmlnaHREaXYuYXBwZW5kQ2hpbGQoYnJpZ2h0bmVzc1RleHQpO1xuXG4gICAgICAgIC8vIENvbnRyYXN0IGZpbHRlclxuICAgICAgICBsZXQgY29udHJhc3REaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udHJhc3REaXYuY2xhc3NMaXN0LmFkZCgnY29sb3ItZmlsdGVycycpO1xuICAgICAgICBjb250cmFzdERpdi5jbGFzc0xpc3QuYWRkKCdtYW5pcHVsYXRpb24tdG9vbHMtdGV4dCcpO1xuICAgICAgICBsZXQgY29udHJhc3RBZGp1c3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBsZXQgY29udHJhc3RUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgY29udHJhc3RUZXh0LnRleHRDb250ZW50ID0gJ0NvbnRyYXN0JztcbiAgICAgICAgY29udHJhc3RUZXh0LnNldEF0dHJpYnV0ZSgnZm9yJywgJ2NvbnRyYXN0LXNsaWRlcicpO1xuICAgICAgICBjb250cmFzdEFkanVzdC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAncmFuZ2UnKTtcbiAgICAgICAgY29udHJhc3RBZGp1c3Quc2V0QXR0cmlidXRlKCdtYXgnLCAxMDApO1xuICAgICAgICBjb250cmFzdEFkanVzdC5zZXRBdHRyaWJ1dGUoJ21pbicsIC0xMDApO1xuICAgICAgICBjb250cmFzdEFkanVzdC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgMCk7XG4gICAgICAgIGNvbnRyYXN0QWRqdXN0LmlkID0gJ2NvbnRyYXN0LXNsaWRlcic7XG5cbiAgICAgICAgY29udHJhc3RBZGp1c3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZGVib3VuY2UoKGUpID0+IHRoaXMuX2FwcGx5VHJhbnNmb3JtYXRpb25Ub0ltYWdlRGF0YShlLCBjb250cmFzdCwgZS50YXJnZXQudmFsdWUpLCAyNTApKTtcbiAgICAgICAgY29udHJhc3REaXYuYXBwZW5kQ2hpbGQoY29udHJhc3RBZGp1c3QpO1xuICAgICAgICBjb250cmFzdERpdi5hcHBlbmRDaGlsZChjb250cmFzdFRleHQpO1xuXG4gICAgICAgIC8vIEludmVydCBjb2xvdXJzIGZpbHRlclxuICAgICAgICBsZXQgaW52RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGludkRpdi5jbGFzc0xpc3QuYWRkKCdjb2xvci1maWx0ZXJzJyk7XG4gICAgICAgIGxldCBpbnZlcnRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgaW52ZXJ0QnV0dG9uLnRleHRDb250ZW50ID0gXCJJbnZlcnQgQ29sb3Vyc1wiO1xuICAgICAgICBpbnZlcnRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4gdGhpcy5fYXBwbHlUcmFuc2Zvcm1hdGlvblRvSW1hZ2VEYXRhKGUsIGludmVydCkpO1xuICAgICAgICBpbnZEaXYuYXBwZW5kQ2hpbGQoaW52ZXJ0QnV0dG9uKTtcblxuICAgICAgICAvLyBTaGFycG5lc3MgZmlsdGVyXG4gICAgICAgIGxldCBzaGFycERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzaGFycERpdi5jbGFzc0xpc3QuYWRkKCdjb2xvci1maWx0ZXJzJyk7XG4gICAgICAgIHNoYXJwRGl2LmNsYXNzTGlzdC5hZGQoJ21hbmlwdWxhdGlvbi10b29scy10ZXh0Jyk7XG4gICAgICAgIGxldCBzaGFycGVuQWRqdXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgbGV0IHNoYXJwZW5UZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgc2hhcnBlblRleHQudGV4dENvbnRlbnQgPSAnU2hhcnBuZXNzJztcbiAgICAgICAgc2hhcnBlblRleHQuc2V0QXR0cmlidXRlKCdmb3InLCAnc2hhcnBuZXNzLXNsaWRlcicpO1xuICAgICAgICBzaGFycGVuQWRqdXN0LnNldEF0dHJpYnV0ZSgndHlwZScsICdyYW5nZScpO1xuICAgICAgICBzaGFycGVuQWRqdXN0LnNldEF0dHJpYnV0ZSgnbWF4JywgMTAwKTtcbiAgICAgICAgc2hhcnBlbkFkanVzdC5zZXRBdHRyaWJ1dGUoJ21pbicsIDApO1xuICAgICAgICBzaGFycGVuQWRqdXN0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCAwKTtcbiAgICAgICAgc2hhcnBlbkFkanVzdC5pZCA9ICdzaGFycG5lc3Mtc2xpZGVyJztcblxuICAgICAgICBzaGFycGVuQWRqdXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGRlYm91bmNlKChlKSA9PiB0aGlzLl9hcHBseVRyYW5zZm9ybWF0aW9uVG9JbWFnZURhdGEoZSwgc2hhcnBlbiwgZS50YXJnZXQudmFsdWUpLCAyNTApKTtcbiAgICAgICAgc2hhcnBEaXYuYXBwZW5kQ2hpbGQoc2hhcnBlbkFkanVzdCk7XG4gICAgICAgIHNoYXJwRGl2LmFwcGVuZENoaWxkKHNoYXJwZW5UZXh0KTtcblxuICAgICAgICAvLyBIdWUgZmlsdGVyXG4gICAgICAgIGxldCBodWVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgaHVlRGl2LmNsYXNzTGlzdC5hZGQoJ2NvbG9yLWZpbHRlcnMnKTtcbiAgICAgICAgaHVlRGl2LmNsYXNzTGlzdC5hZGQoJ21hbmlwdWxhdGlvbi10b29scy10ZXh0Jyk7XG4gICAgICAgIGxldCBodWVBZGp1c3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBsZXQgaHVlVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIGh1ZVRleHQudGV4dENvbnRlbnQgPSAnSHVlJztcbiAgICAgICAgaHVlVGV4dC5zZXRBdHRyaWJ1dGUoJ2ZvcicsICdodWUtc2xpZGVyJyk7XG4gICAgICAgIGh1ZUFkanVzdC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAncmFuZ2UnKTtcbiAgICAgICAgaHVlQWRqdXN0LnNldEF0dHJpYnV0ZSgnbWF4JywgMTAwKTtcbiAgICAgICAgaHVlQWRqdXN0LnNldEF0dHJpYnV0ZSgnbWluJywgMCk7XG4gICAgICAgIGh1ZUFkanVzdC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgMCk7XG4gICAgICAgIGh1ZUFkanVzdC5pZCA9ICdodWUtc2xpZGVyJztcblxuICAgICAgICBodWVBZGp1c3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZGVib3VuY2UoKGUpID0+IHRoaXMuX2FwcGx5VHJhbnNmb3JtYXRpb25Ub0ltYWdlRGF0YShlLCBodWUsIGUudGFyZ2V0LnZhbHVlKSwgMjUwKSk7XG4gICAgICAgIGh1ZURpdi5hcHBlbmRDaGlsZChodWVBZGp1c3QpO1xuICAgICAgICBodWVEaXYuYXBwZW5kQ2hpbGQoaHVlVGV4dCk7XG5cbiAgICAgICAgLy8gR2FtbWEgZmlsdGVyXG4gICAgICAgIGxldCBnYW1tYURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBnYW1tYURpdi5jbGFzc0xpc3QuYWRkKCdjb2xvci1maWx0ZXJzJyk7XG4gICAgICAgIGdhbW1hRGl2LmNsYXNzTGlzdC5hZGQoJ21hbmlwdWxhdGlvbi10b29scy10ZXh0Jyk7XG4gICAgICAgIGxldCBnYW1tYUFkanVzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGxldCBnYW1tYVRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICBnYW1tYVRleHQudGV4dENvbnRlbnQgPSAnR2FtbWEnO1xuICAgICAgICBnYW1tYVRleHQuc2V0QXR0cmlidXRlKCdmb3InLCAnZ2FtbWEtc2xpZGVyJyk7XG4gICAgICAgIGdhbW1hQWRqdXN0LnNldEF0dHJpYnV0ZSgndHlwZScsICdyYW5nZScpO1xuICAgICAgICBnYW1tYUFkanVzdC5zZXRBdHRyaWJ1dGUoJ21heCcsIDMwMCk7XG4gICAgICAgIGdhbW1hQWRqdXN0LnNldEF0dHJpYnV0ZSgnbWluJywgLTEwMCk7XG4gICAgICAgIGdhbW1hQWRqdXN0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCAwKTtcbiAgICAgICAgZ2FtbWFBZGp1c3QuaWQgPSAnZ2FtbWEtc2xpZGVyJztcblxuICAgICAgICBnYW1tYUFkanVzdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBkZWJvdW5jZSgoZSkgPT4gdGhpcy5fYXBwbHlUcmFuc2Zvcm1hdGlvblRvSW1hZ2VEYXRhKGUsIGdhbW1hLCBlLnRhcmdldC52YWx1ZSksIDI1MCkpO1xuICAgICAgICBnYW1tYURpdi5hcHBlbmRDaGlsZChnYW1tYUFkanVzdCk7XG4gICAgICAgIGdhbW1hRGl2LmFwcGVuZENoaWxkKGdhbW1hVGV4dCk7XG5cbiAgICAgICAgLy8gQ29sb3VyIGNoYW5uZWwgUkdCIHNsaWRlc1xuICAgICAgICBsZXQgY2NSZWREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY2NSZWREaXYuY2xhc3NMaXN0LmFkZCgnY29sb3ItZmlsdGVycycpO1xuICAgICAgICBjY1JlZERpdi5jbGFzc0xpc3QuYWRkKCdtYW5pcHVsYXRpb24tdG9vbHMtdGV4dCcpO1xuICAgICAgICBsZXQgY2NSZWRBZGp1c3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBsZXQgY2NSZWRUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgY2NSZWRUZXh0LnRleHRDb250ZW50ID0gJ0NDIFJlZCc7XG4gICAgICAgIGNjUmVkVGV4dC5zZXRBdHRyaWJ1dGUoJ2ZvcicsICdjYy1yZWQtc2xpZGVyJyk7XG4gICAgICAgIGNjUmVkQWRqdXN0LnNldEF0dHJpYnV0ZSgndHlwZScsICdyYW5nZScpO1xuICAgICAgICBjY1JlZEFkanVzdC5zZXRBdHRyaWJ1dGUoJ21heCcsIDEwMCk7XG4gICAgICAgIGNjUmVkQWRqdXN0LnNldEF0dHJpYnV0ZSgnbWluJywgLTEwMCk7XG4gICAgICAgIGNjUmVkQWRqdXN0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCAwKTtcbiAgICAgICAgY2NSZWRBZGp1c3QuaWQgPSAnY2MtcmVkLXNsaWRlcic7XG5cbiAgICAgICAgbGV0IGNjR3JlZW5EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY2NHcmVlbkRpdi5jbGFzc0xpc3QuYWRkKCdjb2xvci1maWx0ZXJzJyk7XG4gICAgICAgIGNjR3JlZW5EaXYuY2xhc3NMaXN0LmFkZCgnbWFuaXB1bGF0aW9uLXRvb2xzLXRleHQnKTtcbiAgICAgICAgbGV0IGNjR3JlZW5BZGp1c3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBsZXQgY2NHcmVlblRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICBjY0dyZWVuVGV4dC50ZXh0Q29udGVudCA9ICdDQyBHcmVlbic7XG4gICAgICAgIGNjR3JlZW5UZXh0LnNldEF0dHJpYnV0ZSgnZm9yJywgJ2NjLWdyZWVuLXNsaWRlcicpO1xuICAgICAgICBjY0dyZWVuQWRqdXN0LnNldEF0dHJpYnV0ZSgndHlwZScsICdyYW5nZScpO1xuICAgICAgICBjY0dyZWVuQWRqdXN0LnNldEF0dHJpYnV0ZSgnbWF4JywgMTAwKTtcbiAgICAgICAgY2NHcmVlbkFkanVzdC5zZXRBdHRyaWJ1dGUoJ21pbicsIC0xMDApO1xuICAgICAgICBjY0dyZWVuQWRqdXN0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCAwKTtcbiAgICAgICAgY2NHcmVlbkFkanVzdC5pZCA9ICdjYy1ncmVlbi1zbGlkZXInO1xuXG4gICAgICAgIGxldCBjY0JsdWVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY2NCbHVlRGl2LmNsYXNzTGlzdC5hZGQoJ2NvbG9yLWZpbHRlcnMnKTtcbiAgICAgICAgY2NCbHVlRGl2LmNsYXNzTGlzdC5hZGQoJ21hbmlwdWxhdGlvbi10b29scy10ZXh0Jyk7XG4gICAgICAgIGxldCBjY0JsdWVBZGp1c3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBsZXQgY2NCbHVlVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIGNjQmx1ZVRleHQudGV4dENvbnRlbnQgPSAnQ0MgQmx1ZSc7XG4gICAgICAgIGNjQmx1ZVRleHQuc2V0QXR0cmlidXRlKCdmb3InLCAnY2MtYmx1ZS1zbGlkZXInKTtcbiAgICAgICAgY2NCbHVlQWRqdXN0LnNldEF0dHJpYnV0ZSgndHlwZScsICdyYW5nZScpO1xuICAgICAgICBjY0JsdWVBZGp1c3Quc2V0QXR0cmlidXRlKCdtYXgnLCAxMDApO1xuICAgICAgICBjY0JsdWVBZGp1c3Quc2V0QXR0cmlidXRlKCdtaW4nLCAtMTAwKTtcbiAgICAgICAgY2NCbHVlQWRqdXN0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCAwKTtcbiAgICAgICAgY2NCbHVlQWRqdXN0LmlkID0gJ2NjLWJsdWUtc2xpZGVyJztcblxuICAgICAgICBjY1JlZEFkanVzdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBkZWJvdW5jZSgoZSkgPT4gdGhpcy5fYXBwbHlUcmFuc2Zvcm1hdGlvblRvSW1hZ2VEYXRhKGUsIGNjUmVkLCBlLnRhcmdldC52YWx1ZSksIDI1MCkpO1xuICAgICAgICBjY0dyZWVuQWRqdXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGRlYm91bmNlKChlKSA9PiB0aGlzLl9hcHBseVRyYW5zZm9ybWF0aW9uVG9JbWFnZURhdGEoZSwgY2NHcmVlbiwgZS50YXJnZXQudmFsdWUpLCAyNTApKTtcbiAgICAgICAgY2NCbHVlQWRqdXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGRlYm91bmNlKChlKSA9PiB0aGlzLl9hcHBseVRyYW5zZm9ybWF0aW9uVG9JbWFnZURhdGEoZSwgY2NCbHVlLCBlLnRhcmdldC52YWx1ZSksIDI1MCkpO1xuXG4gICAgICAgIGNjUmVkRGl2LmFwcGVuZENoaWxkKGNjUmVkQWRqdXN0KTtcbiAgICAgICAgY2NSZWREaXYuYXBwZW5kQ2hpbGQoY2NSZWRUZXh0KTtcbiAgICAgICAgY2NHcmVlbkRpdi5hcHBlbmRDaGlsZChjY0dyZWVuQWRqdXN0KTtcbiAgICAgICAgY2NHcmVlbkRpdi5hcHBlbmRDaGlsZChjY0dyZWVuVGV4dCk7XG4gICAgICAgIGNjQmx1ZURpdi5hcHBlbmRDaGlsZChjY0JsdWVBZGp1c3QpO1xuICAgICAgICBjY0JsdWVEaXYuYXBwZW5kQ2hpbGQoY2NCbHVlVGV4dCk7XG5cbiAgICAgICAgLy8gVGhyZXNob2xkIGZpbHRlclxuICAgICAgICBsZXQgdGhyZXNoRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRocmVzaERpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBsZXQgdGhyZXNob2xkQWRqdXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgbGV0IHRocmVzaG9sZFRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICB0aHJlc2hvbGRUZXh0LnRleHRDb250ZW50ID0gJ1RocmVzaG9sZCc7XG4gICAgICAgIHRocmVzaG9sZFRleHQuc2V0QXR0cmlidXRlKCdmb3InLCAndGhyZXNob2xkLXNsaWRlcicpO1xuICAgICAgICB0aHJlc2hEaXYuY2xhc3NMaXN0LmFkZCgnbWFuaXB1bGF0aW9uLXRvb2xzLXRleHQnKTtcbiAgICAgICAgdGhyZXNob2xkQWRqdXN0LnNldEF0dHJpYnV0ZSgndHlwZScsICdyYW5nZScpO1xuICAgICAgICB0aHJlc2hvbGRBZGp1c3Quc2V0QXR0cmlidXRlKCdtYXgnLCAyNTUpO1xuICAgICAgICB0aHJlc2hvbGRBZGp1c3Quc2V0QXR0cmlidXRlKCdtaW4nLCA2NCk7XG4gICAgICAgIHRocmVzaG9sZEFkanVzdC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgMCk7XG4gICAgICAgIHRocmVzaG9sZEFkanVzdC5pZCA9ICd0aHJlc2hvbGQtc2xpZGVyJztcblxuICAgICAgICB0aHJlc2hvbGRBZGp1c3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZGVib3VuY2UoKGUpID0+IHRoaXMuX2FwcGx5VHJhbnNmb3JtYXRpb25Ub0ltYWdlRGF0YShlLCB0aHJlc2hvbGQsIGUudGFyZ2V0LnZhbHVlKSwgMjUwKSk7XG4gICAgICAgIHRocmVzaERpdi5hcHBlbmRDaGlsZCh0aHJlc2hvbGRBZGp1c3QpO1xuICAgICAgICB0aHJlc2hEaXYuYXBwZW5kQ2hpbGQodGhyZXNob2xkVGV4dCk7XG5cbiAgICAgICAgLy8gUmVzZXQgYnV0dG9uXG4gICAgICAgIGxldCByZXNldEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICByZXNldEJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ21hcmdpbi10b3A6IDFlbTsnKTtcbiAgICAgICAgbGV0IGJ1dHRvblRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnUmVzZXQnKTtcbiAgICAgICAgcmVzZXRCdXR0b24uYXBwZW5kQ2hpbGQoYnV0dG9uVGV4dCk7XG4gICAgICAgIHJlc2V0QnV0dG9uLm9uY2xpY2sgPSAoZSkgPT4geyB0aGlzLl9sb2FkSW1hZ2VJbk1haW5BcmVhKGUsIHRoaXMuY3VycmVudEltYWdlVVJMKTsgfTtcblxuICAgICAgICAvLyBMb2cgdG8ga2VlcCB0cmFjayBvZiB0aGUgb3JkZXIgb2YgZmlsdGVyIGFwcGxpY2F0aW9uXG4gICAgICAgIGxldCBmaWx0ZXJMb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZmlsdGVyTG9nLmNsYXNzTGlzdC5hZGQoJ21hbmlwdWxhdGlvbi10b29scy10ZXh0Jyk7XG4gICAgICAgIGZpbHRlckxvZy5pbm5lckhUTUwgPSBcIjxoMz4gRmlsdGVyIEFwcGxpY2F0aW9uIE9yZGVyIDxoMz5cIjtcbiAgICAgICAgZmlsdGVyTG9nLmlkID0gJ2ZpbHRlci1sb2cnO1xuXG4gICAgICAgIHRoaXMuX3Rvb2xzLmFwcGVuZENoaWxkKGNsb3NlQnV0dG9uKTtcbiAgICAgICAgdGhpcy5fdG9vbHMuYXBwZW5kQ2hpbGQoaGVhZGVyKTtcbiAgICAgICAgdGhpcy5fdG9vbHMuYXBwZW5kQ2hpbGQoem9vbURpdik7XG4gICAgICAgIHRoaXMuX3Rvb2xzLmFwcGVuZENoaWxkKHJvdGF0ZURpdik7XG4gICAgICAgIHRoaXMuX3Rvb2xzLmFwcGVuZENoaWxkKG1pcnJvckRpdik7XG4gICAgICAgIHRoaXMuX3Rvb2xzLmFwcGVuZENoaWxkKGZpbHRlcnNUaXRsZSk7XG4gICAgICAgIHRoaXMuX3Rvb2xzLmFwcGVuZENoaWxkKGJ3RGl2KTtcbiAgICAgICAgdGhpcy5fdG9vbHMuYXBwZW5kQ2hpbGQoaW52RGl2KTtcbiAgICAgICAgdGhpcy5fdG9vbHMuYXBwZW5kQ2hpbGQoc2F0dXJhdGlvbkRpdik7XG4gICAgICAgIHRoaXMuX3Rvb2xzLmFwcGVuZENoaWxkKHZpYkRpdik7XG4gICAgICAgIHRoaXMuX3Rvb2xzLmFwcGVuZENoaWxkKGJyaWdodERpdik7XG4gICAgICAgIHRoaXMuX3Rvb2xzLmFwcGVuZENoaWxkKGNvbnRyYXN0RGl2KTtcbiAgICAgICAgdGhpcy5fdG9vbHMuYXBwZW5kQ2hpbGQoc2hhcnBEaXYpO1xuICAgICAgICB0aGlzLl90b29scy5hcHBlbmRDaGlsZChodWVEaXYpO1xuICAgICAgICB0aGlzLl90b29scy5hcHBlbmRDaGlsZChnYW1tYURpdik7XG4gICAgICAgIHRoaXMuX3Rvb2xzLmFwcGVuZENoaWxkKGNjUmVkRGl2KTtcbiAgICAgICAgdGhpcy5fdG9vbHMuYXBwZW5kQ2hpbGQoY2NHcmVlbkRpdik7XG4gICAgICAgIHRoaXMuX3Rvb2xzLmFwcGVuZENoaWxkKGNjQmx1ZURpdik7XG4gICAgICAgIHRoaXMuX3Rvb2xzLmFwcGVuZENoaWxkKHRocmVzaERpdik7XG4gICAgICAgIHRoaXMuX3Rvb2xzLmFwcGVuZENoaWxkKHJlc2V0QnV0dG9uKTtcbiAgICAgICAgdGhpcy5fdG9vbHMuYXBwZW5kQ2hpbGQoZmlsdGVyTG9nKTtcblxuICAgICAgICB0aGlzLl90b29scy5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3BhZGRpbmc6IDAgMWVtOycpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHN3aXRjaFZpc2libGVGaWx0ZXJzICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY29sb3ItZmlsdGVycycpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gJ3RocmVzaG9sZCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGZpbHRlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJzW2ldLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyZXNoRGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBmaWx0ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyc1tpXS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJlc2hEaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9yZXNldFNsaWRlcnMgKClcbiAgICB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGVsZW1lbnQgaXMgYSBzbGlkZXIsIGlmIHNvIHRoZW4gcmVzZXRcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuX3Rvb2xzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgdG9vbCA9IHRoaXMuX3Rvb2xzLmNoaWxkcmVuW2ldLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgaWYgKHRvb2wgJiYgdG9vbC50eXBlID09PSAncmFuZ2UnKVxuICAgICAgICAgICAgICAgIHRvb2wudmFsdWUgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbHRlci1sb2cnKS5pbm5lckhUTUwgPSBcIjxoMz4gRmlsdGVyIEFwcGxpY2F0aW9uIE9yZGVyIDxoMz5cIjtcblxuICAgICAgICAvLyByZXNldCBjb3VudGVyc1xuICAgICAgICB0aGlzLnpvb20gPSAxO1xuICAgICAgICB0aGlzLnJvdGF0ZSA9IDA7XG5cbiAgICAgICAgLy8gcmVzZXQgbWlycm9yXG4gICAgICAgIHRoaXMubWlycm9ySG9yaXpvbnRhbCA9IDE7XG4gICAgICAgIHRoaXMubWlycm9yVmVydGljYWwgPSAxO1xuICAgICAgICB0aGlzLmhhbmRsZVRyYW5zZm9ybShudWxsLCBudWxsLCB0aGlzLnJvdGF0ZSk7XG5cbiAgICAgICAgcmVzZXRGaWx0ZXJzKCk7XG4gICAgfVxuXG4gICAgX2xvYWRJbWFnZUluTWFpbkFyZWEgKGV2ZW50LCBpbWFnZVVSTClcbiAgICB7XG4gICAgICAgIHRoaXMuY3VycmVudEltYWdlVVJMID0gaW1hZ2VVUkw7IC8vIGZvciByZXNldHRpbmdcblxuICAgICAgICBsZXQgdXJsID0gYCR7aW1hZ2VVUkx9ZnVsbC9mdWxsLzAvZGVmYXVsdC5qcGdgO1xuXG4gICAgICAgIHRoaXMuX21haW5JbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICB0aGlzLl9tYWluSW1hZ2UuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuXG4gICAgICAgIHRoaXMuX21haW5JbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSAoc3F1YXJlKSBjYW52YXMgYmFzZWQgb24gdGhlIGh5cG90ZW5ldXNlXG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc2l6ZSA9IE1hdGguc3FydCh0aGlzLl9tYWluSW1hZ2Uud2lkdGggKiB0aGlzLl9tYWluSW1hZ2Uud2lkdGggKyB0aGlzLl9tYWluSW1hZ2UuaGVpZ2h0ICogdGhpcy5fbWFpbkltYWdlLmhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMud2lkdGggPSB0aGlzLl9jYW52YXMuc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSB0aGlzLl9jYW52YXMuc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5jb3JuZXJYID0gKHRoaXMuX2NhbnZhcy5zaXplIC0gdGhpcy5fbWFpbkltYWdlLndpZHRoKSAvIDI7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuY29ybmVyWSA9ICh0aGlzLl9jYW52YXMuc2l6ZSAtIHRoaXMuX21haW5JbWFnZS5oZWlnaHQpIC8gMjtcblxuICAgICAgICAgICAgdGhpcy5fY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5fY3R4LmRyYXdJbWFnZSh0aGlzLl9tYWluSW1hZ2UsIHRoaXMuX2NhbnZhcy5jb3JuZXJYLCB0aGlzLl9jYW52YXMuY29ybmVyWSwgdGhpcy5fbWFpbkltYWdlLndpZHRoLCB0aGlzLl9tYWluSW1hZ2UuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsRGF0YSA9IHRoaXMuX2N0eC5nZXRJbWFnZURhdGEodGhpcy5fY2FudmFzLmNvcm5lclgsIHRoaXMuX2NhbnZhcy5jb3JuZXJZLCB0aGlzLl9tYWluSW1hZ2Uud2lkdGgsIHRoaXMuX21haW5JbWFnZS5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5fYWx0ZXJlZERhdGEgPSB0aGlzLl9vcmlnaW5hbERhdGE7XG5cbiAgICAgICAgICAgIC8vIHRvIHByZXNlcnZlIHByZS16b29tIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIHRoaXMuZGltcyA9IHtcbiAgICAgICAgICAgICAgICB3OiB0aGlzLl9jYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgaDogdGhpcy5fY2FudmFzLmhlaWdodFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gY2xlYW4gdXAgdGhlIGltYWdlIGRhdGEgc2luY2UgaXQncyBiZWVuIHBhaW50ZWQgdG8gdGhlIGNhbnZhc1xuICAgICAgICAgICAgdGhpcy5fbWFpbkltYWdlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gY2VudGVyIHRoZSB2aWV3cG9ydFxuICAgICAgICAgICAgdGhpcy5jZW50ZXJWaWV3KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX21haW5JbWFnZS5zcmMgPSB1cmw7XG5cbiAgICAgICAgdGhpcy5fcmVzZXRTbGlkZXJzKCk7XG4gICAgfVxuXG4gICAgX2FwcGx5VHJhbnNmb3JtYXRpb25Ub0ltYWdlRGF0YSAoZXZlbnQsIGZ1bmMsIHZhbHVlKVxuICAgIHtcbiAgICAgICAgbGV0IGN3ID0gdGhpcy5fY2FudmFzLndpZHRoO1xuICAgICAgICBsZXQgY2ggPSB0aGlzLl9jYW52YXMuaGVpZ2h0O1xuICAgICAgICBsZXQgYWRqdXN0bWVudDtcblxuICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFkanVzdG1lbnQgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5ld0RhdGEgPSBmdW5jKHRoaXMuX29yaWdpbmFsRGF0YSwgYWRqdXN0bWVudCk7XG4gICAgICAgIHRoaXMuX2FsdGVyZWREYXRhID0gbmV3RGF0YTtcblxuICAgICAgICB0aGlzLl9jdHguY2xlYXJSZWN0KDAsIDAsIGN3LCBjaCk7XG4gICAgICAgIHRoaXMuX2N0eC5wdXRJbWFnZURhdGEobmV3RGF0YSwgdGhpcy5fY2FudmFzLmNvcm5lclgsIHRoaXMuX2NhbnZhcy5jb3JuZXJZKTtcblxuICAgICAgICAvLyBuZWNlc3NhcnkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCAoc2luY2UgSW1hZ2VEYXRhIGdldHMgYWx0ZXJlZCBhdCB6b29tIDEpXG4gICAgICAgIHRoaXMuaGFuZGxlWm9vbShldmVudCwgdGhpcy56b29tLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlWm9vbSAoZXZlbnQsIHZhbHVlLCByZWNlbnRlcilcbiAgICB7XG4gICAgICAgIGxldCBzY2FsZSA9IHZhbHVlICogMC41ICsgMC41O1xuXG4gICAgICAgIGxldCB3ID0gdGhpcy5kaW1zLnc7XG4gICAgICAgIGxldCBoID0gdGhpcy5kaW1zLmg7XG5cbiAgICAgICAgLy8gdGVtcCBjYW52YXMgZm9yIGRyYXdpbmcgYXQgb3JpZ2luYWwgem9vbSBsZXZlbFxuICAgICAgICBsZXQgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBsZXQgdGVtcEN0eCA9IHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHc7XG4gICAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gaDtcbiAgICAgICAgdGVtcEN0eC5wdXRJbWFnZURhdGEodGhpcy5fYWx0ZXJlZERhdGEsIHRoaXMuX2NhbnZhcy5jb3JuZXJYLCB0aGlzLl9jYW52YXMuY29ybmVyWSk7XG5cbiAgICAgICAgdGhpcy5fY2FudmFzLndpZHRoID0gdyAqIHNjYWxlO1xuICAgICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gaCAqIHNjYWxlO1xuICAgICAgICB0aGlzLl9jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7XG4gICAgICAgIHRoaXMuX2N0eC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgICAgICB0aGlzLl9jdHguZHJhd0ltYWdlKHRlbXBDYW52YXMsIDAsIDApO1xuXG4gICAgICAgIC8vIGRldGVybWluZSBpZiB6b29taW5nIGluIG9yIG5vdFxuICAgICAgICBsZXQgem9vbWluZ0luID0gdmFsdWUgPiB0aGlzLnpvb20gPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgdGhpcy56b29tID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcblxuICAgICAgICBpZiAocmVjZW50ZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gZXZlbnQudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgbGV0IHggPSBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgbGV0IHkgPSBldmVudC5jbGllbnRZIC0gcmVjdC50b3A7XG5cbiAgICAgICAgICAgIGlmICghem9vbWluZ0luKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIHggJiB5IGFyZSBpbiB0ZXJtcyBvZiBwcmUtem9vbS1vdXQgZGltZW5zaW9ucywgc28gc2NhbGUgZG93biBhY2NvcmRpbmdseVxuICAgICAgICAgICAgICAgIGxldCBzY2FsZU91dCA9ICh0aGlzLnpvb20gKiAwLjUgKyAwLjUpIC8gKCh0aGlzLnpvb20gKyAxKSAqIDAuNSArIDAuNSk7XG4gICAgICAgICAgICAgICAgeCAqPSBzY2FsZU91dDtcbiAgICAgICAgICAgICAgICB5ICo9IHNjYWxlT3V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNlbnRlclZpZXcoeCwgeSwgem9vbWluZ0luKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNlbnRlclZpZXcgKHgsIHksIHpvb21pbmdJbilcbiAgICB7XG4gICAgICAgIGxldCB2aWV3ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbWFuaXB1bGF0aW9uLW1haW4tYXJlYScpWzBdO1xuICAgICAgICBpZiAoIXZpZXcpXG4gICAgICAgICAgICB2aWV3ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbWFuaXB1bGF0aW9uLW1haW4tYXJlYS1tb2JpbGUnKVswXTtcblxuICAgICAgICBpZiAoem9vbWluZ0luKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyB4ICYgeSBhcmUgaW4gdGVybXMgb2YgcHJlLXpvb20taW4gZGltZW5zaW9ucywgc28gc2NhbGUgdXAgYWNjb3JkaW5nbHlcbiAgICAgICAgICAgIGxldCBzY2FsZUluID0gKHRoaXMuem9vbSAqIDAuNSArIDAuNSkgLyAoKHRoaXMuem9vbSAtIDEpICogMC41ICsgMC41KTtcbiAgICAgICAgICAgIHggKj0gc2NhbGVJbjtcbiAgICAgICAgICAgIHkgKj0gc2NhbGVJbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRpc3RhbmNlIGZyb20gY2VudGVyXG4gICAgICAgIGxldCBjZW50ZXIgPSB0aGlzLl9jYW52YXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgbGV0IGRpc3RZID0geSAtIGNlbnRlcjtcbiAgICAgICAgbGV0IGRpc3RYID0geCAtIGNlbnRlcjtcblxuICAgICAgICBsZXQgaCA9IHRoaXMuX2NhbnZhcy5oZWlnaHQ7XG4gICAgICAgIGxldCB3ID0gdGhpcy5fY2FudmFzLndpZHRoO1xuXG4gICAgICAgIGxldCB0b3BDZW50ZXJlZCA9IChoIC0gdmlldy5jbGllbnRIZWlnaHQpIC8gMjtcbiAgICAgICAgbGV0IGxlZnRDZW50ZXJlZCA9ICh3IC0gdmlldy5jbGllbnRXaWR0aCkgLyAyO1xuXG4gICAgICAgIGxldCB0b3AgPSB5ID8gdG9wQ2VudGVyZWQgKyBkaXN0WSA6IHRvcENlbnRlcmVkO1xuICAgICAgICBsZXQgbGVmdCA9IHggPyBsZWZ0Q2VudGVyZWQgKyBkaXN0WCA6IGxlZnRDZW50ZXJlZDtcblxuICAgICAgICB2aWV3LnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgICAgdmlldy5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICB9XG5cbiAgICBoYW5kbGVUcmFuc2Zvcm0gKGV2ZW50LCB0eXBlLCB2YWx1ZSlcbiAgICB7XG4gICAgICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdtYW5pcHVsYXRpb24tbWFpbi1hcmVhJylbMF0uY2hpbGRyZW5bMF07XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICd2ZXJ0aWNhbCcpXG4gICAgICAgICAgICB0aGlzLm1pcnJvclZlcnRpY2FsICo9IC0xO1xuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnaG9yaXpvbnRhbCcpXG4gICAgICAgICAgICB0aGlzLm1pcnJvckhvcml6b250YWwgKj0gLTE7XG5cbiAgICAgICAgY2FudmFzLnN0eWxlLnRyYW5zZm9ybSA9IFwic2NhbGUoXCIrdGhpcy5taXJyb3JIb3Jpem9udGFsK1wiLFwiK3RoaXMubWlycm9yVmVydGljYWwrXCIpIHJvdGF0ZShcIit2YWx1ZStcImRlZylcIjtcblxuICAgICAgICB0aGlzLnJvdGF0ZSA9IHZhbHVlO1xuICAgIH1cbn1cblxuTWFuaXB1bGF0aW9uUGx1Z2luLnByb3RvdHlwZS5wbHVnaW5OYW1lID0gXCJtYW5pcHVsYXRpb25cIjtcbk1hbmlwdWxhdGlvblBsdWdpbi5wcm90b3R5cGUuaXNQYWdlVG9vbCA9IHRydWU7XG5cbi8qKlxuICogTWFrZSB0aGlzIHBsdWdpbiBhdmFpbGFibGUgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG4gKiBhcyBwYXJ0IG9mIHRoZSAnRGl2YScgbmFtZXNwYWNlLlxuICoqL1xuKGZ1bmN0aW9uIChnbG9iYWwpXG57XG4gICAgZ2xvYmFsLkRpdmEuTWFuaXB1bGF0aW9uUGx1Z2luID0gTWFuaXB1bGF0aW9uUGx1Z2luO1xufSkod2luZG93KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./source/js/plugins/manipulation.js\n");

/***/ })

/******/ });