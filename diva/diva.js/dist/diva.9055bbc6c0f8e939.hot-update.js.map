{"version":3,"file":"diva.9055bbc6c0f8e939.hot-update.js","sources":["webpack://diva.js/./source/js/viewer-core.ts"],"sourcesContent":["import { elt } from './utils/elt';\nimport getScrollbarWidth from './utils/get-scrollbar-width';\nimport gestureEvents from './gesture-events';\nimport globalDiva from './diva-global';\nimport DocumentHandler from './document-handler';\nimport GridHandler from './grid-handler';\nimport PageOverlayManager from './page-overlay-manager';\nimport Renderer from './renderer';\nimport getPageLayouts from './page-layouts';\nimport ValidationRunner from './validation-runner';\nimport Viewport from './viewport';\nimport {\n    ViewerSettings,\n    Options,\n    MergedConfiguration,\n    RendererSettings,\n    RendererLoadConfig,\n    RendererViewportPosition, OptionsValidator, PageRegionOptions, ActiveViewOptions\n} from \"./options-settings\";\nimport {\n    Dimension,\n    DivaTiledPage,\n    Offset,\n    PaddingDefinitions,\n    PageInfo,\n    PagePosition, Region,\n    SourceProvider, ViewportSize\n} from \"./viewer-type-definitions\";\nimport PageToolsOverlay from \"./page-tools-overlay\";\nimport ImageManifest from \"./image-manifest\";\nimport divaGlobal from \"./diva-global\";\n\n\n\nconst debug = require('debug')('diva:ViewerCore');\n\nfunction generateId(): number {\n    return generateId.counter++;\n}\ngenerateId.counter = 1;\n\nfunction createSettingsView(sources: Array<object>): MergedConfiguration\n{\n    const obj = {};\n\n    sources.forEach( (source) =>\n    {\n        registerMixin(obj, source);\n    });\n\n    // @ts-ignore\n    return obj;\n}\n\nfunction registerMixin(obj: {}, mixin: Record<string, any>)\n{\n    Object.keys(mixin).forEach( (key: string) =>\n    {\n        Object.defineProperty(obj, key, {\n            get: () =>\n            {\n                return mixin[key];\n            },\n            set: () =>\n            {\n                // TODO: Make everything strict mode so this isn't needed\n                throw new TypeError('Cannot set settings.' + key);\n            }\n        });\n    });\n}\n\nfunction arraysEqual (a: Array<any>, b:Array<any>): boolean\n{\n    if (a.length !== b.length)\n    {\n        return false;\n    }\n\n    for (let i = 0, len = a.length; i < len; i++)\n    {\n        if (a[i] !== b[i])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Define validations\nconst optionsValidations: OptionsValidator[] = [\n    {\n        key: 'goDirectlyTo',\n        validate: (value: number, settings: MergedConfiguration) =>\n        {\n            if (value < 0 || value >= settings.manifest!.pages.length)\n            {\n                return 0;\n            }\n            return value;\n        }\n    },\n    {\n        key: 'minPagesPerRow',\n        validate: (value: number) =>\n        {\n            return Math.max(2, value);\n        }\n    },\n    {\n        key: 'maxPagesPerRow',\n        validate: (value: number, settings: MergedConfiguration) =>\n        {\n            return Math.max(value, settings.minPagesPerRow);\n        }\n    },\n    {\n        key: 'pagesPerRow',\n        validate: (value: number, settings: MergedConfiguration) =>\n        {\n            // Default to the maximum\n            if (value < settings.minPagesPerRow || value > settings.maxPagesPerRow)\n            {\n                return settings.maxPagesPerRow;\n            }\n            return value\n        }\n    },\n    {\n        key: 'maxZoomLevel',\n        validate: (value: number, settings: MergedConfiguration, config: any) =>\n        {\n            // Changing this value isn't really an error, it just depends on the\n            // source manifest\n            config.suppressWarning();\n\n            if (value < 0 || value > settings.manifest!.maxZoom)\n            {\n                return settings.manifest!.maxZoom;\n            }\n            return value;\n        }\n    },\n    {\n        key: 'minZoomLevel',\n        validate: (value: number, settings: MergedConfiguration, config: any) =>\n        {\n            // Changes based on the manifest value shouldn't trigger a\n            // warning\n            if (value > settings.manifest!.maxZoom)\n            {\n                config.suppressWarning();\n                return 0;\n            }\n\n            if (value < 0 || value > settings.maxZoomLevel)\n            {\n                return 0;\n            }\n            return value;\n        }\n    },\n    {\n        key: 'zoomLevel',\n        validate: (value: number, settings: MergedConfiguration, config: any) =>\n        {\n            if (value > settings.manifest!.maxZoom)\n            {\n                config.suppressWarning();\n                return 0;\n            }\n\n            if (value < settings.minZoomLevel || value > settings.maxZoomLevel)\n            {\n                return settings.minZoomLevel;\n            }\n            return value;\n        }\n    }\n];\n\nexport default class ViewerCore\n{\n    parentObject: HTMLElement;\n    publicInstance: any;\n    viewerState: ViewerSettings;\n    settings: MergedConfiguration;\n    optionsValidator: ValidationRunner;\n    boundScrollFunction: any;\n    boundEscapeListener: any;\n\n    constructor (element: HTMLElement, options: Options, publicInstance: any)\n    {\n        this.parentObject = element;\n        this.publicInstance = publicInstance;\n\n        // Things that cannot be changed because of the way they are used by the script\n        // Many of these are declared with arbitrary values that are changed later on\n        this.viewerState = {\n            currentPageIndices: [],    // The visible pages in the viewport\n            activePageIndex: 0,         // The current 'active' page in the viewport\n            horizontalOffset: 0,        // Distance from the center of the diva element to the top of the current page\n            horizontalPadding: 0,       // Either the fixed padding or adaptive padding\n            ID: null,                   // The prefix of the IDs of the elements (usually 1-diva-)\n            initialKeyScroll: false,    // Holds the initial state of enableKeyScroll\n            initialSpaceScroll: false,  // Holds the initial state of enableSpaceScroll\n            innerElement: null,         // The native .diva-outer DOM object\n            innerObject: null,            // document.getElementById(settings.ID + 'inner'), for selecting the .diva-inner element\n            isActiveDiva: true,         // In the case that multiple diva panes exist on the same page, this should have events funneled to it.\n            isScrollable: true,         // Used in enable/disableScrollable public methods\n            isZooming: false,           // Flag to keep track of whether zooming is still in progress, for handleZoom\n            loaded: false,              // A flag for when everything is loaded and ready to go.\n            manifest: null,\n            mobileWebkit: false,        // Checks if the user is on a touch device (iPad/iPod/iPhone/Android)\n            numPages: 0,                // Number of pages in the array\n            oldZoomLevel: -1,           // Holds the previous zoom level after zooming in or out\n            options: options,\n            outerElement: null,         // The native .diva-outer DOM object\n            outerObject: null,            // document.getElementById(settings.ID + 'outer'), for selecting the .diva-outer element\n            pageOverlays: new PageOverlayManager(),\n            pageTools: [],              // The plugins which are enabled as page tools\n            parentObject: this.parentObject, // JQuery object referencing the parent element\n            pendingManifestRequest: null, // Reference to the xhr request retrieving the manifest. Used to cancel the request on destroy()\n            pluginInstances: [],                // Filled with the enabled plugins from the registry\n            renderer: null,\n            resizeTimer: null,            // Holds the ID of the timeout used when resizing the window (for clearing)\n            scrollbarWidth: 0,          // Set to the actual scrollbar width in init()\n            selector: '',               // Uses the generated ID prefix to easily select elements\n            throbberTimeoutID: null,      // Holds the ID of the throbber loading timeout\n            toolbar: null,              // Holds an object with some toolbar-related functions\n            verticalOffset: 0,          // Distance from the center of the diva element to the left side of the current page\n            verticalPadding: 0,         // Either the fixed padding or adaptive padding\n            viewHandler: null,\n            viewport: null,             // Object caching the viewport dimensions\n            viewportElement: null,\n            viewportObject: null,\n            zoomDuration: 400\n        };\n\n        this.settings = createSettingsView([options, this.viewerState]);\n\n        // Generate an ID that can be used as a prefix for all the other IDs\n        const idNumber = generateId();\n        this.viewerState.ID = 'diva-' + idNumber + '-';\n        this.viewerState.selector = this.settings.ID;\n\n        // Aliases for compatibility\n        Object.defineProperties(this.settings, {\n            // Height of the document viewer pane\n            panelHeight: {\n                get: (): number =>\n                {\n                    return this.viewerState.viewport.height;\n                }\n            },\n            // Width of the document viewer pane\n            panelWidth: {\n                get: (): number =>\n                {\n                    return this.viewerState.viewport.width;\n                }\n            }\n        });\n\n        this.optionsValidator = new ValidationRunner({\n            additionalProperties: [\n                {\n                    key: 'manifest',\n                    get: () =>\n                    {\n                        return this.viewerState.manifest;\n                    }\n                }\n            ],\n\n            validations: optionsValidations\n        });\n\n        this.viewerState.scrollbarWidth = getScrollbarWidth();\n\n        // If window.orientation is defined, then it's probably mobileWebkit\n        this.viewerState.mobileWebkit = window.screen.orientation !== undefined;\n\n        if (options.hashParamSuffix === null)\n        {\n            // Omit the suffix from the first instance\n            if (idNumber === 1)\n            {\n                options.hashParamSuffix = '';\n            }\n            else\n            {\n                options.hashParamSuffix = idNumber + '';\n            }\n        }\n\n        // Create the inner and outer panels\n        const innerElem = elt('div', this.elemAttrs('inner', { class: 'diva-inner' }));\n        const viewportElem = elt('div', this.elemAttrs('viewport'), innerElem);\n        const outerElem = elt('div', this.elemAttrs('outer'),\n            viewportElem,\n            elt('div', this.elemAttrs('throbber'),\n                [\n                    elt('div', { class: 'cube cube1' }),\n                    elt('div', { class: 'cube cube2' }),\n                    elt('div', { class: 'cube cube3' }),\n                    elt('div', { class: 'cube cube4' }),\n                    elt('div', { class: 'cube cube5' }),\n                    elt('div', { class: 'cube cube6' }),\n                    elt('div', { class: 'cube cube7' }),\n                    elt('div', { class: 'cube cube8' }),\n                    elt('div', { class: 'cube cube9' }),\n                ]\n            ));\n\n        this.viewerState.innerElement = innerElem;\n        this.viewerState.viewportElement = viewportElem;\n        this.viewerState.outerElement = outerElem;\n\n        this.viewerState.innerObject = innerElem;\n        this.viewerState.viewportObject = viewportElem;\n        this.viewerState.outerObject = outerElem;\n\n        this.settings.parentObject.append(outerElem);\n\n        this.viewerState.viewport = new Viewport(this.viewerState.viewportElement, {\n            intersectionTolerance: this.settings.viewportMargin\n        });\n\n        this.boundScrollFunction = this.scrollFunction.bind(this);\n        this.boundEscapeListener = this.escapeListener.bind(this);\n\n        // Do all the plugin initialisation\n        this.initPlugins();\n        this.handleEvents();\n\n        // Show the throbber while waiting for the manifest to load\n        this.showThrobber();\n    }\n\n    isValidOption (key: string, value: number)\n    {\n        return this.optionsValidator.isValid(key, value, this.viewerState.options);\n    }\n\n    elemAttrs (ident: string, base?: any)\n    {\n        const attrs = {\n            id: this.settings.ID + ident,\n            class: 'diva-' + ident\n        };\n\n        if (base)\n        {\n            return Object.assign(attrs, base);\n        }\n        else\n        {\n            return attrs;\n        }\n    }\n\n    getPageData (pageIndex: number, attribute: string)\n    {\n        return this.settings.manifest!.pages[pageIndex].d[this.settings.zoomLevel][attribute];\n    }\n\n    // Reset some settings and empty the viewport\n    clearViewer ()\n    {\n        this.viewerState.viewport.top = 0;\n\n        // Clear all the timeouts to prevent undesired pages from loading\n        clearTimeout(this.viewerState.resizeTimer);\n    }\n\n    hasChangedOption (options: Record<string, any>, key: string): boolean\n    {\n        return key in options && options[key] !== this.settings[key];\n    }\n\n    //Shortcut for closing fullscreen with the escape key\n    escapeListener (e: KeyboardEvent)\n    {\n        if (e.code === 'Escape')\n        {\n            this.publicInstance.leaveFullscreenMode();\n        }\n    }\n\n    /**\n     * Update settings to match the specified options. Load the viewer,\n     * fire appropriate events for changed options.\n     */\n    reloadViewer (newOptions: ActiveViewOptions): boolean\n    {\n        const queuedEvents = [];\n\n        newOptions = this.optionsValidator.getValidatedOptions(this.settings, newOptions);\n\n        // Set the zoom level if valid and fire a ZoomLevelDidChange event\n        if (this.hasChangedOption(newOptions, 'zoomLevel'))\n        {\n            this.viewerState.oldZoomLevel = this.settings.zoomLevel;\n            this.viewerState.options.zoomLevel = newOptions.zoomLevel;\n            queuedEvents.push([\"ZoomLevelDidChange\", newOptions.zoomLevel]);\n        }\n\n        // Set the pages per row if valid and fire an event\n        if (this.hasChangedOption(newOptions, 'pagesPerRow'))\n        {\n            this.viewerState.options.pagesPerRow = newOptions.pagesPerRow;\n            queuedEvents.push([\"GridRowNumberDidChange\", newOptions.pagesPerRow]);\n        }\n\n        // Update verticallyOriented (no event fired)\n        if (this.hasChangedOption(newOptions, 'verticallyOriented'))\n            this.viewerState.options.verticallyOriented = newOptions.verticallyOriented;\n\n        // Show/Hide non-paged pages\n        if (this.hasChangedOption(newOptions, 'showNonPagedPages'))\n        {\n            this.viewerState.options.showNonPagedPages = newOptions.showNonPagedPages;\n        }\n\n        // Update page position (no event fired here)\n        if ('goDirectlyTo' in newOptions)\n        {\n            this.viewerState.options.goDirectlyTo = newOptions.goDirectlyTo;\n\n            if ('verticalOffset' in newOptions)\n            {\n                this.viewerState.verticalOffset = newOptions.verticalOffset;\n            }\n\n            if ('horizontalOffset' in newOptions)\n            {\n                this.viewerState.horizontalOffset = newOptions.horizontalOffset;\n            }\n        }\n        else\n        {\n            // Otherwise the default is to remain on the current page\n            this.viewerState.options.goDirectlyTo = this.settings.activePageIndex;\n        }\n\n        if (this.hasChangedOption(newOptions, 'inGrid') || this.hasChangedOption(newOptions, 'inBookLayout'))\n        {\n            if ('inGrid' in newOptions)\n            {\n                this.viewerState.options.inGrid = newOptions.inGrid!;\n            }\n\n            if ('inBookLayout' in newOptions)\n            {\n                this.viewerState.options.inBookLayout = newOptions.inBookLayout!;\n            }\n\n            queuedEvents.push([\"ViewDidSwitch\", this.settings.inGrid]);\n        }\n\n        // Note: prepareModeChange() depends on inGrid and the vertical/horizontalOffset (for now)\n        if (this.hasChangedOption(newOptions, 'inFullscreen'))\n        {\n            this.viewerState.options.inFullscreen = newOptions.inFullscreen!;\n            this.prepareModeChange(newOptions);\n            queuedEvents.push([\"ModeDidSwitch\", this.settings.inFullscreen]);\n        }\n\n        this.clearViewer();\n        this.updateViewHandlerAndRendering();\n\n        if (this.viewerState.renderer)\n        {\n            // TODO: The usage of padding variables is still really\n            // messy and inconsistent\n            const rendererConfig: RendererLoadConfig = {\n                pageLayouts: getPageLayouts(this.settings),\n                padding: this.getPadding(),\n                maxZoomLevel: this.settings.inGrid ? null : this.viewerState.manifest!.maxZoom,\n                verticallyOriented: this.settings.verticallyOriented || this.settings.inGrid,\n            };\n\n            const viewportPosition = {\n                zoomLevel: this.settings.inGrid ? null : this.settings.zoomLevel,\n                anchorPage: this.settings.goDirectlyTo,\n                verticalOffset: this.viewerState.verticalOffset,\n                horizontalOffset: this.viewerState.horizontalOffset\n            };\n\n            const sourceProvider = this.getCurrentSourceProvider();\n\n            if (debug.enabled)\n            {\n                const serialized = Object.keys(rendererConfig)\n                    .filter(function (key)\n                    {\n                        // Too long\n                        return key !== 'pageLayouts' && key !== 'padding';\n                    })\n                    .map(function (key)\n                    {\n                        const value = rendererConfig[key];\n                        return key + ': ' + JSON.stringify(value);\n                    })\n                    .join(', ');\n\n                debug('reload with %s', serialized);\n            }\n\n            this.viewerState.renderer.load(rendererConfig, viewportPosition, sourceProvider);\n        }\n\n        queuedEvents.forEach( (params) =>\n        {\n            this.publish.apply(this, params);\n        });\n\n        return true;\n    }\n\n    // Handles switching in and out of fullscreen mode\n    prepareModeChange (options)\n    {\n        // Toggle the classes\n        const changeClass: 'add' | 'remove' = options.inFullscreen ? 'add' : 'remove';\n        this.viewerState.outerObject!.classList[changeClass]('diva-fullscreen');\n        document.body.classList[changeClass]('diva-hide-scrollbar');\n        this.settings.parentObject.classList[changeClass]('diva-full-width');\n\n        // Adjust Diva's internal panel size, keeping the old values\n        const storedHeight = this.settings.panelHeight;\n        const storedWidth = this.settings.panelWidth;\n        this.viewerState.viewport.invalidate();\n\n        // If this isn't the original load, the offsets matter, and the position isn't being changed...\n        if (!this.viewerState.loaded && !this.settings.inGrid && !('verticalOffset' in options))\n        {\n            //get the updated panel size\n            const newHeight = this.settings.panelHeight;\n            const newWidth = this.settings.panelWidth;\n\n            //and re-center the new panel on the same point\n            this.viewerState.verticalOffset += ((storedHeight - newHeight) / 2);\n            this.viewerState.horizontalOffset += ((storedWidth - newWidth) / 2);\n        }\n\n        //turn on/off escape key listener\n        if (options.inFullscreen)\n            document.addEventListener('keyup', this.boundEscapeListener);\n        else\n            document.removeEventListener('keyup', this.boundEscapeListener);\n    }\n\n    // Update the view handler and the view rendering for the current view\n    updateViewHandlerAndRendering ()\n    {\n        const Handler = this.settings.inGrid ? GridHandler : DocumentHandler;\n\n        if (this.viewerState.viewHandler && !(this.viewerState.viewHandler instanceof Handler))\n        {\n            this.viewerState.viewHandler.destroy();\n            this.viewerState.viewHandler = null;\n        }\n\n        if (!this.viewerState.viewHandler)\n        {\n            this.viewerState.viewHandler = new Handler(this);\n        }\n\n        if (!this.viewerState.renderer)\n        {\n            this.initializeRenderer();\n        }\n    }\n\n    // TODO: This could probably be done upon ViewerCore initialization\n    initializeRenderer ()\n    {\n        const compatErrors = Renderer.getCompatibilityErrors();\n\n        if (compatErrors)\n        {\n            this.showError(compatErrors);\n        }\n        else\n        {\n            const options: RendererSettings = {\n                viewport: this.viewerState.viewport,\n                outerElement: this.viewerState.outerElement!,\n                innerElement: this.viewerState.innerElement!,\n                settings: this.settings\n            };\n\n            const hooks = {\n                onViewWillLoad: () =>\n                {\n                    this.viewerState.viewHandler.onViewWillLoad();\n                },\n                onViewDidLoad: () =>\n                {\n                    this.updatePageOverlays();\n                    this.viewerState.viewHandler.onViewDidLoad();\n                },\n                onViewDidUpdate: (pages, targetPage) =>\n                {\n                    this.updatePageOverlays();\n                    this.viewerState.viewHandler.onViewDidUpdate(pages, targetPage);\n                },\n                onViewDidTransition: () =>\n                {\n                    this.updatePageOverlays();\n                },\n                onPageWillLoad: (pageIndex: number) =>\n                {\n                    this.publish('PageWillLoad', pageIndex);\n                },\n                onZoomLevelWillChange: (zoomLevel: number) =>\n                {\n                    this.publish('ZoomLevelWillChange', zoomLevel);\n                }\n            };\n\n            this.viewerState.renderer = new Renderer(options, hooks);\n        }\n    }\n\n    getCurrentSourceProvider (): SourceProvider\n    {\n        if (this.settings.inGrid)\n        {\n            const gridSourceProvider: SourceProvider = {\n                getAllZoomLevelsForPage: (page: PageInfo): DivaTiledPage[] =>\n                {\n                    return [gridSourceProvider.getBestZoomLevelForPage(page)];\n                },\n                getBestZoomLevelForPage: (page: PageInfo): DivaTiledPage =>\n                {\n                    const url = this.settings.manifest.getPageImageURL(page.index, {\n                        width: page.dimensions.width\n                    });\n\n                    return {\n                        zoomLevel: 1, // FIXME\n                        rows: 1,\n                        cols: 1,\n                        tiles: [{\n                            url: url,\n                            zoomLevel: 1, // FIXME\n                            row: 0,\n                            col: 0,\n                            dimensions: page.dimensions,\n                            offset: {\n                                top: 0,\n                                left: 0\n                            }\n                        }]\n                    };\n                }\n            };\n\n            return gridSourceProvider;\n        }\n\n        const tileDimensions: Dimension = {\n            width: this.settings.tileWidth,\n            height: this.settings.tileHeight\n        };\n\n        return {\n            getBestZoomLevelForPage: (page: PageInfo): DivaTiledPage =>\n            {\n                return this.settings.manifest.getPageImageTiles(page.index, Math.ceil(this.settings.zoomLevel), tileDimensions);\n            },\n            getAllZoomLevelsForPage: (page: PageInfo): DivaTiledPage[] =>\n            {\n                const levels = [];\n                const levelCount = this.viewerState.manifest.maxZoom;\n\n                for (let level=0; level <= levelCount; level++)\n                {\n                    levels.push(this.settings.manifest.getPageImageTiles(page.index, level, tileDimensions));\n                }\n\n                levels.reverse();\n\n                return levels;\n            }\n        };\n    }\n\n    getPadding (): PaddingDefinitions\n    {\n        let topPadding, leftPadding;\n        let docVPadding, docHPadding;\n\n        if (this.settings.inGrid)\n        {\n            docVPadding = this.settings.fixedPadding;\n            topPadding = leftPadding = docHPadding = 0;\n        }\n        else\n        {\n            topPadding = this.settings.verticallyOriented ? this.viewerState.verticalPadding : 0;\n            leftPadding = this.settings.verticallyOriented ? 0 : this.viewerState.horizontalPadding;\n\n            docVPadding = this.settings.verticallyOriented ? 0 : this.viewerState.verticalPadding;\n            docHPadding = this.settings.verticallyOriented ? this.viewerState.horizontalPadding : 0;\n        }\n\n        return {\n            document: {\n                top: docVPadding,\n                bottom: docVPadding,\n                left: docHPadding,\n                right: docHPadding\n            },\n            page: {\n                top: topPadding,\n                bottom: 0,\n                left: leftPadding,\n                right: 0\n            }\n        };\n    }\n\n    updatePageOverlays ()\n    {\n        this.viewerState.pageOverlays.updateOverlays(\n            this.viewerState.renderer.getRenderedPages()\n        );\n    }\n\n    // Called to handle any zoom level\n    handleZoom (newZoomLevel: number, focalPoint?: PagePosition): boolean\n    {\n        // If the zoom level provided is invalid, return false\n        if (!this.isValidOption('zoomLevel', newZoomLevel))\n        {\n            return false;\n        }\n\n        // While zooming, don't update scroll offsets based on the scaled version of diva-inner\n        this.viewerState.viewportObject.removeEventListener('scroll', this.boundScrollFunction);\n\n        // If no focal point was given, zoom on the center of the viewport\n        if (!focalPoint)\n        {\n            const viewport = this.viewerState.viewport;\n            const currentRegion = this.viewerState.renderer.layout.getPageRegion(this.settings.activePageIndex);\n\n            focalPoint = {\n                anchorPage: this.settings.activePageIndex,\n                offset: {\n                    left: (viewport.width / 2) - (currentRegion.left - viewport.left),\n                    top: (viewport.height / 2) - (currentRegion.top - viewport.top)\n                }\n            };\n        }\n\n        const pageRegion = this.viewerState.renderer.layout.getPageRegion(focalPoint.anchorPage);\n\n        // calculate distance from cursor coordinates to center of viewport\n        const focalXToCenter = (pageRegion.left + focalPoint.offset.left) -\n            (this.settings.viewport.left + (this.settings.viewport.width / 2));\n        const focalYToCenter = (pageRegion.top + focalPoint.offset.top) -\n            (this.settings.viewport.top + (this.settings.viewport.height / 2));\n\n        const getPositionForZoomLevel =  (zoomLevel: number, initZoom: number): RendererViewportPosition =>\n        {\n            const zoomRatio = Math.pow(2, zoomLevel - initZoom);\n\n            //TODO(jeromepl): Calculate position from page top left to viewport top left\n            // calculate horizontal/verticalOffset: distance from viewport center to page upper left corner\n            const horizontalOffset = (focalPoint.offset.left * zoomRatio) - focalXToCenter;\n            const verticalOffset = (focalPoint.offset.top * zoomRatio) - focalYToCenter;\n\n            return {\n                zoomLevel: zoomLevel,\n                anchorPage: focalPoint.anchorPage,\n                verticalOffset: verticalOffset,\n                horizontalOffset: horizontalOffset\n            };\n        };\n\n        this.viewerState.options.zoomLevel = newZoomLevel;\n        let initialZoomLevel = this.viewerState.oldZoomLevel;\n        this.viewerState.oldZoomLevel = this.settings.zoomLevel;\n        const endPosition = getPositionForZoomLevel(newZoomLevel, initialZoomLevel);\n        this.viewerState.options.goDirectlyTo = endPosition.anchorPage;\n        this.viewerState.verticalOffset = endPosition.verticalOffset;\n        this.viewerState.horizontalOffset = endPosition.horizontalOffset;\n\n        this.viewerState.renderer.transitionViewportPosition({\n            duration: this.settings.zoomDuration,\n            parameters: {\n                zoomLevel: {\n                    from: initialZoomLevel,\n                    to: newZoomLevel\n                }\n            },\n            getPosition: (parameters: any): RendererViewportPosition =>\n            {\n                return getPositionForZoomLevel(parameters.zoomLevel, initialZoomLevel);\n            },\n            onEnd: (info: any): void =>\n            {\n                this.viewerState.viewportObject.addEventListener('scroll', this.boundScrollFunction);\n\n                if (info.interrupted)\n                {\n                    this.viewerState.oldZoomLevel = newZoomLevel;\n                }\n            }\n        });\n\n        // Deactivate zoom buttons while zooming\n        let zoomInButton: HTMLButtonElement = document.getElementById(this.settings.selector + 'zoom-in-button')! as HTMLButtonElement;\n        let zoomOutButton: HTMLButtonElement = document.getElementById(this.settings.selector + 'zoom-out-button')! as HTMLButtonElement;\n        zoomInButton.disabled = true;\n        zoomOutButton.disabled = true;\n        setTimeout(() =>\n        {\n            zoomInButton.disabled = false;\n            zoomOutButton.disabled = false;\n        }, this.settings.zoomDuration);\n\n        // Send off the zoom level did change event.\n        this.publish(\"ZoomLevelDidChange\", newZoomLevel);\n\n        return true;\n    }\n\n    /*\n     Gets the Y-offset for a specific point on a specific page\n     Acceptable values for \"anchor\":\n     \"top\" (default) - will anchor top of the page to the top of the diva-outer element\n     \"bottom\" - top, s/top/bottom\n     \"center\" - will center the page on the diva element\n     Returned value will be the distance from the center of the diva-outer element to the top of the current page for the specified anchor\n     */\n    getYOffset (pageIndex?: number, anchor?: string): number\n    {\n        let pidx = (typeof(pageIndex) === \"undefined\" ? this.settings.activePageIndex : pageIndex);\n\n        if (anchor === \"center\" || anchor === \"centre\") //how you can tell an American coded this\n        {\n            return Math.floor(this.getPageData(pidx, \"h\") / 2);\n        }\n        else if (anchor === \"bottom\")\n        {\n            return Math.floor(this.getPageData(pidx, \"h\") - this.settings.panelHeight / 2);\n        }\n        else\n        {\n            return Math.floor(this.settings.panelHeight / 2);\n        }\n    }\n\n    //Same as getYOffset with \"left\" and \"right\" as acceptable values instead of \"top\" and \"bottom\"\n    getXOffset (pageIndex?: number, anchor?: string): number\n    {\n        let pidx = (typeof(pageIndex) === \"undefined\" ? this.settings.activePageIndex : pageIndex);\n\n        if (anchor === \"left\")\n        {\n            return Math.floor(this.settings.panelWidth / 2);\n        }\n        else if (anchor === \"right\")\n        {\n            return Math.floor(this.getPageData(pidx, \"w\") - this.settings.panelWidth / 2);\n        }\n        else\n        {\n            return Math.floor(this.getPageData(pidx, \"w\") / 2);\n        }\n    }\n\n    // updates panelHeight/panelWidth on resize\n    updatePanelSize ()\n    {\n        this.viewerState.viewport.invalidate();\n\n        // FIXME(wabain): This should really only be called after initial load\n        if (this.viewerState.renderer)\n        {\n            this.updateOffsets();\n            this.viewerState.renderer.goto(this.settings.activePageIndex, this.viewerState.verticalOffset, this.viewerState.horizontalOffset);\n        }\n\n        return true;\n    }\n\n    updateOffsets ()\n    {\n        const pageOffset = this.viewerState.renderer.layout.getPageToViewportCenterOffset(this.settings.activePageIndex, this.viewerState.viewport);\n\n        if (pageOffset)\n        {\n            this.viewerState.horizontalOffset = pageOffset.x;\n            this.viewerState.verticalOffset = pageOffset.y;\n        }\n    }\n\n    // Bind mouse events (drag to scroll, double-click)\n    bindMouseEvents ()\n    {\n        // Set drag scroll on the viewport object\n        this.viewerState.viewportObject.classList.add('dragscroll');\n\n        gestureEvents.onDoubleClick(this.viewerState.viewportObject, (event, coords) =>\n        {\n            debug('Double click at %s, %s', coords.left, coords.top);\n            this.viewerState.viewHandler.onDoubleClick(event, coords);\n        });\n    }\n\n    onResize ()\n    {\n        this.updatePanelSize();\n        // Cancel any previously-set resize timeouts\n        clearTimeout(this.viewerState.resizeTimer);\n\n        this.viewerState.resizeTimer = setTimeout( () =>\n        {\n            const pageOffset = this.viewerState.renderer.layout.getPageToViewportCenterOffset(this.settings.activePageIndex, this.viewerState.viewport);\n\n            if (pageOffset)\n            {\n                this.reloadViewer({\n                    goDirectlyTo: this.settings.activePageIndex,\n                    verticalOffset: pageOffset.y,\n                    horizontalOffset: pageOffset.x\n                });\n            }\n            else\n            {\n                this.reloadViewer({\n                    goDirectlyTo: this.settings.activePageIndex\n                });\n            }\n        }, 200);\n    }\n\n    // Bind touch and orientation change events\n    bindTouchEvents ()\n    {\n        // Block the user from moving the window only if it's not integrated\n        if (this.settings.blockMobileMove)\n        {\n            document.body.addEventListener('touchmove', (event) =>\n            {\n                event.preventDefault();\n                return false;\n            });\n        }\n\n        // Touch events for swiping in the viewport to scroll pages\n        // this.viewerState.viewportObject.addEventListener('scroll', this.scrollFunction.bind(this));\n\n        gestureEvents.onPinch(this.viewerState.viewportObject,  (event, coords, start, end) =>\n        {\n            debug('Pinch %s at %s, %s', end - start, coords.left, coords.top);\n            this.viewerState.viewHandler.onPinch(event, coords, start, end);\n        });\n\n        gestureEvents.onDoubleTap(this.viewerState.viewportObject,  (event, coords) =>\n        {\n            debug('Double tap at %s, %s', coords.left, coords.top);\n            this.viewerState.viewHandler.onDoubleClick(event, coords);\n        });\n    }\n\n    // Handle the scroll\n    scrollFunction ()\n    {\n        const previousTopScroll = this.viewerState.viewport.top;\n        const previousLeftScroll = this.viewerState.viewport.left;\n\n        let direction;\n\n        this.viewerState.viewport.invalidate();\n\n        const newScrollTop = this.viewerState.viewport.top;\n        const newScrollLeft = this.viewerState.viewport.left;\n\n        if (this.settings.verticallyOriented || this.settings.inGrid)\n        {\n            direction = newScrollTop - previousTopScroll;\n        }\n        else\n        {\n            direction = newScrollLeft - previousLeftScroll;\n        }\n\n        this.viewerState.renderer.adjust();\n\n        const primaryScroll = (this.settings.verticallyOriented || this.settings.inGrid) ? newScrollTop : newScrollLeft;\n\n        this.publish(\"ViewerDidScroll\", primaryScroll);\n\n        if (direction > 0)\n        {\n            this.publish(\"ViewerDidScrollDown\", primaryScroll);\n        }\n        else if (direction < 0)\n        {\n            this.publish(\"ViewerDidScrollUp\", primaryScroll);\n        }\n\n        this.updateOffsets();\n    }\n\n    // Binds most of the event handlers (some more in createToolbar)\n    handleEvents ()\n    {\n        // Change the cursor for dragging\n        this.viewerState.innerObject.addEventListener('mousedown', () =>\n        {\n            this.viewerState.innerObject.classList.add('diva-grabbing');\n        });\n\n        this.viewerState.innerObject.addEventListener('mouseup', () =>\n        {\n            this.viewerState.innerObject.classList.remove('diva-grabbing');\n        });\n\n        this.bindMouseEvents();\n        this.viewerState.viewportObject.addEventListener('scroll', this.boundScrollFunction);\n\n        const upArrowKey = 38,\n            downArrowKey = 40,\n            leftArrowKey = 37,\n            rightArrowKey = 39,\n            spaceKey = 32,\n            pageUpKey = 33,\n            pageDownKey = 34,\n            homeKey = 36,\n            endKey = 35;\n\n        // Catch the key presses in document\n        document.addEventListener('keydown.diva', (event: KeyboardEvent): boolean =>\n        {\n            if (!this.viewerState.isActiveDiva)\n            {\n                return true;\n            }\n\n            // Space or page down - go to the next page\n            if ((this.settings.enableSpaceScroll && !event.shiftKey && event.keyCode === spaceKey) || (this.settings.enableKeyScroll && event.keyCode === pageDownKey))\n            {\n                this.viewerState.viewport.top += this.settings.panelHeight;\n                return false;\n            }\n            else if (!this.settings.enableSpaceScroll && event.keyCode === spaceKey)\n            {\n                event.preventDefault();\n            }\n\n            if (this.settings.enableKeyScroll)\n            {\n                // Don't steal keyboard shortcuts (metaKey = command [OS X], super [Win/Linux])\n                if (event.shiftKey || event.ctrlKey || event.metaKey)\n                {\n                    return true;\n                }\n\n                switch (event.keyCode)\n                {\n                    case pageUpKey:\n                        // Page up - go to the previous page\n                        this.viewerState.viewport.top -= this.settings.panelHeight;\n                        return false;\n\n                    case upArrowKey:\n                        // Up arrow - scroll up\n                        this.viewerState.viewport.top -= this.settings.arrowScrollAmount;\n                        return false;\n\n                    case downArrowKey:\n                        // Down arrow - scroll down\n                        this.viewerState.viewport.top += this.settings.arrowScrollAmount;\n                        return false;\n\n                    case leftArrowKey:\n                        // Left arrow - scroll left\n                        this.viewerState.viewport.left -= this.settings.arrowScrollAmount;\n                        return false;\n\n                    case rightArrowKey:\n                        // Right arrow - scroll right\n                        this.viewerState.viewport.left += this.settings.arrowScrollAmount;\n                        return false;\n\n                    case homeKey:\n                        // Home key - go to the beginning of the document\n                        this.viewerState.viewport.top = 0;\n                        return false;\n\n                    case endKey:\n                        // End key - go to the end of the document\n                        // Count on the viewport coordinate value being normalized\n                        if (this.settings.verticallyOriented)\n                        {\n                            this.viewerState.viewport.top = Infinity;\n                        }\n                        else\n                        {\n                            this.viewerState.viewport.left = Infinity;\n                        }\n\n                        return false;\n\n                    default:\n                        return true;\n                }\n            }\n            return true;\n        });\n\n        divaGlobal.Events.subscribe('ViewerDidTerminate', () =>\n        {\n            document.removeEventListener('keydown.diva');\n        }, this.settings.ID);\n\n        // this.bindTouchEvents();\n\n        // Handle window resizing events\n        window.addEventListener('resize', this.onResize.bind(this), false);\n\n        divaGlobal.Events.subscribe('ViewerDidTerminate', function()\n        {\n            window.removeEventListener('resize', this.onResize, false);\n        }, this.settings.ID);\n\n        // Handle orientation change separately\n        if ('onorientationchange' in window)\n        {\n            window.addEventListener('orientationchange', this.onResize, false);\n\n            divaGlobal.Events.subscribe('ViewerDidTerminate', function()\n            {\n                window.removeEventListener('orientationchange', this.onResize, false);\n            }, this.settings.ID);\n        }\n\n        divaGlobal.Events.subscribe('PanelSizeDidChange', this.updatePanelSize, this.settings.ID);\n\n        // Clear page and resize timeouts when the viewer is destroyed\n        divaGlobal.Events.subscribe('ViewerDidTerminate', () =>\n        {\n            if (this.viewerState.renderer)\n            {\n                this.viewerState.renderer.destroy();\n            }\n\n            clearTimeout(this.viewerState.resizeTimer);\n        }, this.settings.ID);\n    }\n\n    initPlugins ()\n    {\n        if (!this.settings.hasOwnProperty('plugins'))\n        {\n            return null;\n        }\n\n        this.viewerState.pluginInstances = this.settings.plugins.map( (plugin) =>\n        {\n            const p = new plugin(this);\n\n            if (p.isPageTool)\n            {\n                this.viewerState.pageTools.push(p);\n            }\n\n            return p;\n        });\n    }\n\n    showThrobber ()\n    {\n        this.hideThrobber();\n\n        this.viewerState.throbberTimeoutID = setTimeout( () =>\n        {\n            let thb = document.getElementById(this.settings.selector + 'throbber');\n            if (thb) thb.style.display = 'block';\n        }, this.settings.throbberTimeout);\n    }\n\n    hideThrobber ()\n    {\n        // Clear the timeout, if it hasn't executed yet\n        clearTimeout(this.viewerState.throbberTimeoutID);\n\n        let thb = document.getElementById(this.settings.selector + 'throbber');\n        // Hide the throbber if it has already executed\n        if (thb)\n        {\n            thb.style.display = 'none';\n        }\n    }\n\n    showError (message)\n    {\n        const errorElement = elt('div', this.elemAttrs('error'), [\n            elt('button', this.elemAttrs('error-close', {'aria-label': 'Close dialog'})),\n            elt('p',\n                elt('strong', 'Error')\n            ),\n            elt('div', message)\n        ]);\n\n        this.viewerState.outerObject.appendChild(errorElement);\n\n        // Bind dialog close button\n        document.getElementById(this.settings.selector + 'error-close').addEventListener('click', () =>\n        {\n            errorElement.parentNode.removeChild(errorElement);\n        });\n    }\n\n    setManifest (manifest: ImageManifest, loadOptions: any)\n    {\n        this.viewerState.manifest = manifest;\n\n        this.hideThrobber();\n\n        // Convenience value\n        this.viewerState.numPages = this.settings.manifest.pages.length;\n\n        this.optionsValidator.validate(this.viewerState.options);\n\n        this.publish('NumberOfPagesDidChange', this.settings.numPages);\n\n        // Calculate the horizontal and vertical inter-page padding based on the dimensions of the average zoom level\n        if (this.settings.adaptivePadding > 0)\n        {\n            const z: number = Math.floor((this.settings.minZoomLevel + this.settings.maxZoomLevel) / 2);\n            this.viewerState.horizontalPadding = Math.floor(this.settings.manifest.getAverageWidth(z) * this.settings.adaptivePadding);\n            this.viewerState.verticalPadding = Math.floor(this.settings.manifest.getAverageHeight(z) * this.settings.adaptivePadding);\n        }\n        else\n        {\n            // It's less than or equal to 0; use fixedPadding instead\n            this.viewerState.horizontalPadding = this.settings.fixedPadding;\n            this.viewerState.verticalPadding = this.settings.fixedPadding;\n        }\n\n        // Make sure the vertical padding is at least 40, if plugin icons are enabled\n        if (this.viewerState.pageTools.length)\n        {\n            this.viewerState.verticalPadding = Math.max(40, this.viewerState.verticalPadding);\n        }\n\n        // If we detect a viewingHint of 'paged' in the manifest or sequence, enable book view by default\n        if (this.settings.manifest.paged)\n        {\n            this.viewerState.options.inBookLayout = true;\n        }\n\n        // Plugin setup hooks should be bound to the ObjectDidLoad event\n        this.publish('ObjectDidLoad', this.settings);\n\n        // Adjust the document panel dimensions\n        this.updatePanelSize();\n\n        let needsXCoord, needsYCoord;\n\n        let anchoredVertically = false;\n        let anchoredHorizontally = false;\n\n        // NB: `==` here will check both null and undefined\n        if (loadOptions.goDirectlyTo == null)\n        {\n            loadOptions.goDirectlyTo = this.settings.goDirectlyTo;\n            needsXCoord = needsYCoord = true;\n        }\n        else\n        {\n            needsXCoord = loadOptions.horizontalOffset == null || isNaN(loadOptions.horizontalOffset);\n            needsYCoord = loadOptions.verticalOffset == null || isNaN(loadOptions.verticalOffset);\n        }\n\n        // Set default values for the horizontal and vertical offsets\n        if (needsXCoord)\n        {\n            // FIXME: What if inBookLayout/verticallyOriented is changed by loadOptions?\n            if (loadOptions.goDirectlyTo === 0 && this.settings.inBookLayout && this.settings.verticallyOriented)\n            {\n                // if in book layout, center the first opening by default\n                loadOptions.horizontalOffset = this.viewerState.horizontalPadding;\n            }\n            else\n            {\n                anchoredHorizontally = true;\n                loadOptions.horizontalOffset = this.getXOffset(loadOptions.goDirectlyTo, \"center\");\n            }\n        }\n\n        if (needsYCoord)\n        {\n            anchoredVertically = true;\n            loadOptions.verticalOffset = this.getYOffset(loadOptions.goDirectlyTo, \"top\");\n        }\n\n        this.reloadViewer(loadOptions);\n\n        //prep dimensions one last time now that pages have loaded\n        this.updatePanelSize();\n\n        if (this.settings.enableAutoTitle)\n        {\n            let title = document.getElementById(this.settings.selector + 'title');\n\n            if (title)\n            {\n                title.innerHTML = this.settings.manifest.itemTitle;\n            }\n            else\n            {\n                this.settings.parentObject.insertBefore(\n                    elt('div', this.elemAttrs('title'), [this.settings.manifest.itemTitle]),\n                    this.settings.parentObject.firstChild\n                );\n            }\n        }\n\n        // FIXME: This is a hack to ensure that the outerElement scrollbars are taken into account\n        if (this.settings.verticallyOriented)\n        {\n            this.viewerState.innerElement.style.minWidth = this.settings.panelWidth + 'px';\n        }\n        else\n        {\n            this.viewerState.innerElement.style.minHeight = this.settings.panelHeight + 'px';\n        }\n\n        // FIXME: If the page was supposed to be positioned relative to the viewport we need to\n        // recalculate it to take into account the scrollbars\n        if (anchoredVertically || anchoredHorizontally)\n        {\n            if (anchoredVertically)\n            {\n                this.viewerState.verticalOffset = this.getYOffset(this.settings.activePageIndex, \"top\");\n            }\n\n            if (anchoredHorizontally)\n            {\n                this.viewerState.horizontalOffset = this.getXOffset(this.settings.activePageIndex, \"center\");\n            }\n\n            this.viewerState.renderer.goto(this.settings.activePageIndex, this.viewerState.verticalOffset, this.viewerState.horizontalOffset);\n        }\n\n        // signal that everything should be set up and ready to go.\n        this.viewerState.loaded = true;\n\n        this.publish(\"ViewerDidLoad\", this.settings);\n    }\n\n    publish (event: string, ...args: any[])\n    {\n        // const args = Array.prototype.slice.call(arguments, 1);\n        globalDiva.Events.publish(event, args, this.publicInstance);\n    }\n\n    getSettings ()\n    {\n        return this.settings;\n    }\n\n    // Temporary accessor for the state of the viewer core\n    // TODO: Replace this with a more restricted view of whatever needs\n    // be exposed through settings for backwards compat\n    getInternalState ()\n    {\n        return this.viewerState;\n    }\n\n    getPublicInstance ()\n    {\n        return this.publicInstance;\n    }\n\n    getPageTools ()\n    {\n        return this.viewerState.pageTools;\n    }\n\n    getCurrentLayout ()\n    {\n        return this.viewerState.renderer ? this.viewerState.renderer.layout : null;\n    }\n\n    /** Get a copy of the current viewport dimensions */\n    getViewport (): ViewportSize\n    {\n        const viewport = this.viewerState.viewport;\n\n        return {\n            top: viewport.top,\n            left: viewport.left,\n            bottom: viewport.bottom,\n            right: viewport.right,\n\n            width: viewport.width,\n            height: viewport.height\n        };\n    }\n\n    addPageOverlay (overlay: PageToolsOverlay): void\n    {\n        this.viewerState.pageOverlays.addOverlay(overlay);\n    }\n\n    removePageOverlay (overlay: PageToolsOverlay): void\n    {\n        this.viewerState.pageOverlays.removeOverlay(overlay);\n    }\n\n    getPageRegion (pageIndex: number, options: PageRegionOptions): Region | null\n    {\n        const layout = this.viewerState.renderer!.layout!;\n        const region = layout.getPageRegion(pageIndex, options)!;\n\n        if (options && options.incorporateViewport)\n        {\n            const secondaryDim = this.settings.verticallyOriented ? 'width' : 'height';\n\n            if (this.viewerState.viewport[secondaryDim] > layout.dimensions[secondaryDim])\n            {\n                const docOffset = (this.viewerState.viewport[secondaryDim] - layout.dimensions[secondaryDim]) / 2;\n\n                if (this.settings.verticallyOriented)\n                {\n                    return {\n                        top: region.top,\n                        bottom: region.bottom,\n\n                        left: region.left + docOffset,\n                        right: region.right + docOffset\n                    };\n                }\n                else\n                {\n                    return {\n                        top: region.top + docOffset,\n                        bottom: region.bottom + docOffset,\n\n                        left: region.left,\n                        right: region.right\n                    };\n                }\n            }\n        }\n\n        return region;\n    }\n\n    getPagePositionAtViewportOffset (coords: Offset): PagePosition\n    {\n        const docCoords = {\n            left: coords.left + this.viewerState.viewport.left,\n            top: coords.top + this.viewerState.viewport.top\n        };\n        const renderer = this.viewerState.renderer!;\n\n        const renderedPages: number[] = renderer.getRenderedPages();\n        const pageCount = renderedPages.length;\n\n        // Find the page on which the coords occur\n        for (let i=0; i < pageCount; i++)\n        {\n            const pageIndex: number = renderedPages[i];\n            const region = renderer.layout!.getPageRegion(pageIndex)!;\n\n            if (region.left <= docCoords.left && region.right >= docCoords.left &&\n                region.top <= docCoords.top && region.bottom >= docCoords.top)\n            {\n                return {\n                    anchorPage: pageIndex,\n                    offset: {\n                        left: docCoords.left - region.left,\n                        top: docCoords.top - region.top\n                    }\n                };\n            }\n        }\n\n        // Fall back to current page\n        // FIXME: Would be better to use the closest page or something\n        const currentRegion = renderer.layout!.getPageRegion(this.settings.activePageIndex)!;\n\n        return {\n            anchorPage: this.settings.activePageIndex,\n            offset: {\n                left: docCoords.left - currentRegion.left,\n                top: docCoords.top - currentRegion.top\n            }\n        };\n    }\n\n    // setManifest (manifest, loadOptions)\n    // {\n    //     setManifest(manifest, loadOptions || {});\n    // }\n\n    /**\n     * Set the current page to the given index, firing VisiblePageDidChange\n     *\n     * @param activePage\n     * @param visiblePages\n     */\n    setCurrentPages (activePage: number, visiblePages: number[])\n    {\n        if (!arraysEqual(this.viewerState.currentPageIndices, visiblePages))\n        {\n            this.viewerState.currentPageIndices = visiblePages;\n            if (this.viewerState.activePageIndex !== activePage)\n            {\n                this.viewerState.activePageIndex = activePage;\n                this.publish(\"ActivePageDidChange\", activePage);\n            }\n            this.publish(\"VisiblePageDidChange\", visiblePages);\n\n            // Publish an event if the page we're switching to has other images.\n            if (this.viewerState.manifest.pages[activePage].otherImages.length > 0)\n            {\n                this.publish('VisiblePageHasAlternateViews', activePage);\n            }\n        }\n        else if (this.viewerState.activePageIndex !== activePage)\n        {\n            this.viewerState.activePageIndex = activePage;\n            this.publish(\"ActivePageDidChange\", activePage);\n        }\n    }\n\n    getPageName (pageIndex: number)\n    {\n        return this.viewerState.manifest!.pages[pageIndex].f;\n    }\n\n    reload (newOptions: ActiveViewOptions): boolean\n    {\n        return this.reloadViewer(newOptions);\n    }\n\n    zoom (zoomLevel: number, focalPoint?: PagePosition): boolean\n    {\n        return this.handleZoom(zoomLevel, focalPoint);\n    }\n\n    enableScrollable ()\n    {\n        if (!this.viewerState.isScrollable)\n        {\n            this.bindMouseEvents();\n            this.enableDragScrollable();\n            this.viewerState.options.enableKeyScroll = this.viewerState.initialKeyScroll;\n            this.viewerState.options.enableSpaceScroll = this.viewerState.initialSpaceScroll;\n            this.viewerState.viewportElement.style.overflow = 'auto';\n            this.viewerState.isScrollable = true;\n        }\n    }\n\n    enableDragScrollable ()\n    {\n        if (this.viewerState.viewportObject!.hasAttribute('nochilddrag'))\n        {\n            this.viewerState.viewportObject!.removeAttribute('nochilddrag');\n        }\n    }\n\n    disableScrollable ()\n    {\n        if (this.viewerState.isScrollable)\n        {\n            // block dragging\n            this.disableDragScrollable();\n\n            // block double-click zooming\n            this.viewerState.outerObject!.ondblclick = null;\n            this.viewerState.outerObject!.oncontextmenu = null;\n\n            // disable all other scrolling actions\n            this.viewerState.viewportElement!.style.overflow = 'hidden';\n\n            // block scrolling keys behavior, respecting initial scroll settings\n            this.viewerState.initialKeyScroll = this.settings.enableKeyScroll;\n            this.viewerState.initialSpaceScroll = this.settings.enableSpaceScroll;\n            this.viewerState.options.enableKeyScroll = false;\n            this.viewerState.options.enableSpaceScroll = false;\n\n            this.viewerState.isScrollable = false;\n        }\n    }\n\n    disableDragScrollable ()\n    {\n        if (!this.viewerState.viewportObject.hasAttribute('nochilddrag'))\n        {\n            this.viewerState.viewportObject.setAttribute('nochilddrag', \"\");\n        }\n    }\n\n    // isValidOption (key, value)\n    // {\n    //     return isValidOption(key, value);\n    // }\n\n    // getXOffset (pageIndex, xAnchor)\n    // {\n    //     return getXOffset(pageIndex, xAnchor);\n    // }\n\n    // getYOffset (pageIndex, yAnchor)\n    // {\n    //     return getYOffset(pageIndex, yAnchor);\n    // }\n\n    // this.publish = publish;\n\n    clear ()\n    {\n        this.clearViewer();\n    }\n\n    setPendingManifestRequest (pendingManifestRequest: Promise<void>)\n    {\n        this.viewerState.pendingManifestRequest = pendingManifestRequest;\n    }\n\n    destroy ()\n    {\n        // Useful event to access elements in diva before they get destroyed. Used by the highlight plugin.\n        this.publish('ViewerWillTerminate', this.settings);\n\n        // Cancel any pending request retrieving a manifest\n        if (this.settings.pendingManifestRequest)\n        {\n            this.settings.pendingManifestRequest.abort();\n        }\n\n        // Removes the hide-scrollbar class from the body\n        document.body.classList.remove('diva-hide-scrollbar');\n\n        // Empty the parent container and remove any diva-related data\n        this.settings.parentObject.parentElement.replaceChildren();\n\n        // Remove any additional styling on the parent element\n        this.settings.parentObject.parentElement.removeAttribute('style');\n        this.settings.parentObject.parentElement.removeAttribute('class');\n\n        this.publish('ViewerDidTerminate', this.settings);\n\n        // Clear the Events cache\n        globalDiva.Events.unsubscribeAll(this.settings.ID);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAoBA;AAIA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AA+JA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;;;AAGA;AAGA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;AAOA;AAGA;AAEA;AAEA;AACA;AAGA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAUA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AAAA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AA77CA;AARA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AA2yCA;AAx8CA"}