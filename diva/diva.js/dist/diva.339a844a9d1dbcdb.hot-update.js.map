{"version":3,"file":"diva.339a844a9d1dbcdb.hot-update.js","sources":["webpack://diva.js/./source/js/document-handler.ts"],"sourcesContent":["import { maxBy } from './utils/maxby';\nimport PageToolsOverlay from './page-tools-overlay';\nimport ViewerCore from \"./viewer-core\";\nimport {ViewerSettings} from \"./options-settings\";\nimport {Offset} from \"./viewer-type-definitions\";\nimport type Viewport from \"./viewport\";\nimport DocumentLayout from './document-layout';\n\n\nexport default class DocumentHandler\n{\n    _viewerCore: ViewerCore\n    _viewerState: ViewerSettings;\n    _overlays: PageToolsOverlay[]\n\n    constructor(viewerCore: ViewerCore)\n    {\n        this._viewerCore = viewerCore;\n        this._viewerState = viewerCore.getInternalState();\n        this._overlays = [];\n\n        if (this._viewerCore.getPageTools().length)\n        {\n            const numPages = viewerCore.getSettings().numPages;\n\n            for (let i = 0; i < numPages; i++)\n            {\n                const overlay = new PageToolsOverlay(i, viewerCore);\n                this._overlays.push(overlay);\n                this._viewerCore.addPageOverlay(overlay);\n\n                // create dummy label for width calculation\n                // this is necessary because the _pageToolsElem is only created on mount\n                // so there's no other way to get its width before the pages are loaded\n                // (which we need to avoid their width temporarily being 0 while loading)\n                let dummyLabel = document.createElement('span');\n                dummyLabel.innerHTML = viewerCore.settings.manifest.pages[i].l;\n                dummyLabel.classList.add('diva-page-labels');\n                dummyLabel.setAttribute('style', 'display: inline-block;');\n                document.body.appendChild(dummyLabel);\n                let labelWidth = dummyLabel.clientWidth;\n                document.body.removeChild(dummyLabel);\n\n                overlay.labelWidth = labelWidth;\n            }\n        }\n    }\n\n    // USER EVENTS\n    onDoubleClick(event: KeyboardEvent, coords: Offset)\n    {\n        const settings = this._viewerCore.getSettings();\n        const newZoomLevel = event.ctrlKey ? settings.zoomLevel - 1 : settings.zoomLevel + 1;\n\n        const position = this._viewerCore.getPagePositionAtViewportOffset(coords);\n        this._viewerCore.zoom(newZoomLevel, position);\n    }\n\n    onPinch(_event: TouchEvent, coords: Offset, startDistance: number, endDistance: number)\n    {\n        // FIXME: Do this check in a way which is less spaghetti code-y\n        const viewerState = this._viewerCore.getInternalState();\n        const settings = this._viewerCore.getSettings();\n\n        let newZoomLevel = Math.log(Math.pow(2, settings.zoomLevel) * endDistance / (startDistance * Math.log(2))) / Math.log(2);\n        newZoomLevel = Math.max(settings.minZoomLevel, newZoomLevel);\n        newZoomLevel = Math.min(settings.maxZoomLevel, newZoomLevel);\n\n        if (newZoomLevel === settings.zoomLevel)\n        {\n            return;\n        }\n\n        const position = this._viewerCore.getPagePositionAtViewportOffset(coords);\n\n        const layout = this._viewerCore.getCurrentLayout();\n        const centerOffset = layout.getPageToViewportCenterOffset(position.anchorPage, viewerState.viewport);\n        const scaleRatio = 1 / Math.pow(2, settings.zoomLevel - newZoomLevel);\n\n        this._viewerCore.reload({\n            zoomLevel: newZoomLevel,\n            goDirectlyTo: position.anchorPage,\n            horizontalOffset: (centerOffset.x - position.offset.left) + position.offset.left * scaleRatio,\n            verticalOffset: (centerOffset.y - position.offset.top) + position.offset.top * scaleRatio\n        });\n    }\n\n    // VIEW EVENTS\n    onViewWillLoad()\n    {\n        this._viewerCore.publish('DocumentWillLoad', this._viewerCore.getSettings());\n    }\n\n    onViewDidLoad()\n    {\n        // TODO: Should only be necessary to handle changes on view update, not\n        // initial load\n        this._handleZoomLevelChange();\n\n        const currentPageIndex = this._viewerCore.getSettings().activePageIndex;\n        const fileName = this._viewerCore.getPageName(currentPageIndex);\n        this._viewerCore.publish(\"DocumentDidLoad\", currentPageIndex, fileName);\n    }\n\n    onViewDidUpdate(renderedPages: any, targetPage: any)\n    {\n        const currentPage = (targetPage !== null) ?\n            targetPage :\n            getCentermostPage(renderedPages, this._viewerCore.getCurrentLayout(), this._viewerCore.getViewport());\n\n        // calculate the visible pages from the rendered pages\n        let temp = this._viewerState.viewport.intersectionTolerance;\n        // without setting to 0, isPageVisible returns true for pages out of viewport by intersectionTolerance\n        this._viewerState.viewport.intersectionTolerance = 0;\n        let visiblePages = renderedPages.filter((index: number) => this._viewerState.renderer.isPageVisible(index));\n        // reset back to original value after getting true visible pages\n        this._viewerState.viewport.intersectionTolerance = temp;\n\n        // Don't change the current page if there is no page in the viewport\n        // FIXME: Would be better to fall back to the page closest to the viewport\n        if (currentPage !== null)\n        {\n            this._viewerCore.setCurrentPages(currentPage, visiblePages);\n        }\n\n        if (targetPage !== null)\n        {\n            this._viewerCore.publish(\"ViewerDidJump\", targetPage);\n        }\n\n        this._handleZoomLevelChange();\n    }\n\n    _handleZoomLevelChange()\n    {\n        const viewerState = this._viewerState;\n        const zoomLevel = viewerState.options.zoomLevel;\n\n        // If this is not the initial load, trigger the zoom events\n        if (viewerState.oldZoomLevel !== zoomLevel && viewerState.oldZoomLevel >= 0)\n        {\n            if (viewerState.oldZoomLevel < zoomLevel)\n            {\n                this._viewerCore.publish(\"ViewerDidZoomIn\", zoomLevel);\n            }\n            else\n            {\n                this._viewerCore.publish(\"ViewerDidZoomOut\", zoomLevel);\n            }\n\n            this._viewerCore.publish(\"ViewerDidZoom\", zoomLevel);\n        }\n\n        viewerState.oldZoomLevel = zoomLevel;\n    }\n\n    destroy()\n    {\n        this._overlays.forEach((overlay) =>\n        {\n            this._viewerCore.removePageOverlay(overlay);\n        }, this);\n    }\n}\n\nfunction getCentermostPage(renderedPages: number[], layout: DocumentLayout, viewport: Viewport)\n{\n    const centerY = viewport.top + (viewport.height / 2);\n    const centerX = viewport.left + (viewport.width / 2);\n\n    // Find the minimum distance from the viewport center to a page.\n    // Compute minus the squared distance from viewport center to the page's border.\n    // http://gamedev.stackexchange.com/questions/44483/how-do-i-calculate-distance-between-a-point-and-an-axis-aligned-rectangle\n    const centerPage = maxBy(renderedPages, pageIndex =>\n    {\n        const dims = layout.getPageDimensions(pageIndex)!;\n        const imageOffset = layout.getPageOffset(pageIndex, {includePadding: true})!;\n\n        const midX = imageOffset.left + (dims.width / 2);\n        const midY = imageOffset.top + (dims.height / 2);\n\n        const dx = Math.max(Math.abs(centerX - midX) - (dims.width / 2), 0);\n        const dy = Math.max(Math.abs(centerY - midY) - (dims.height / 2), 0);\n\n        return -(dx * dx + dy * dy);\n    });\n\n    return centerPage != null ? centerPage : null;\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAAA;AACA;AAQA;AAuCA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAnJA;AAJA;AACA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAqHA;AA1JA;AA4JA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA"}