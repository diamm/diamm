{"version":3,"file":"static/js/diva.js","sources":["webpack://diva.js/./source/css/diva.scss","webpack://diva.js/./source/js/composite-image.ts","webpack://diva.js/./source/js/diva-global.ts","webpack://diva.js/./source/js/diva.ts","webpack://diva.js/./source/js/document-handler.ts","webpack://diva.js/./source/js/document-layout.ts","webpack://diva.js/./source/js/exceptions.ts","webpack://diva.js/./source/js/gesture-events.ts","webpack://diva.js/./source/js/grid-handler.ts","webpack://diva.js/./source/js/iiif-source-adapter.ts","webpack://diva.js/./source/js/image-cache.ts","webpack://diva.js/./source/js/image-manifest.ts","webpack://diva.js/./source/js/image-request-handler.ts","webpack://diva.js/./source/js/interpolate-animation.ts","webpack://diva.js/./source/js/page-layouts/book-layout.ts","webpack://diva.js/./source/js/page-layouts/grid-layout.ts","webpack://diva.js/./source/js/page-layouts/index.ts","webpack://diva.js/./source/js/page-layouts/page-dimensions.ts","webpack://diva.js/./source/js/page-layouts/singles-layout.ts","webpack://diva.js/./source/js/page-overlay-manager.ts","webpack://diva.js/./source/js/page-tools-overlay.ts","webpack://diva.js/./source/js/parse-iiif-manifest.ts","webpack://diva.js/./source/js/renderer.ts","webpack://diva.js/./source/js/tile-coverage-map.ts","webpack://diva.js/./source/js/toolbar.ts","webpack://diva.js/./source/js/utils/dragscroll.js","webpack://diva.js/./source/js/utils/elt.ts","webpack://diva.js/./source/js/utils/events.ts","webpack://diva.js/./source/js/utils/get-scrollbar-width.ts","webpack://diva.js/./source/js/utils/hash-params.ts","webpack://diva.js/./source/js/utils/maxby.ts","webpack://diva.js/./source/js/utils/parse-label-value.ts","webpack://diva.js/./source/js/utils/vanilla.kinetic.ts","webpack://diva.js/./source/js/validation-runner.ts","webpack://diva.js/./source/js/viewer-core.ts","webpack://diva.js/./source/js/viewport.ts"],"sourcesContent":["// extracted by css-extract-rspack-plugin\nexport {};\n    if(module.hot) {\n      (function() {\n        var localsJsonString = undefined;\n        // 1745419584194\n        var cssReload = require(\"../../node_modules/@rspack/core/dist/cssExtractHmr.js\").cssReload(module.id, {});\n        // only invalidate when locals change\n        if (\n          module.hot.data &&\n          module.hot.data.value &&\n          module.hot.data.value !== localsJsonString\n        ) {\n          module.hot.invalidate();\n        } else {\n          module.hot.accept();\n        }\n        module.hot.dispose(function(data) {\n          data.value = localsJsonString;\n          cssReload();\n        });\n      })();\n    }\n  ","import TileCoverageMap from \"./tile-coverage-map\";\nimport {DivaTileAlt, DivaTiledPage, DivaTileSource} from \"./viewer-type-definitions\";\nimport ImageCache from \"./image-cache\";\n\n/**\n * @class CompositeImage\n * @private\n *\n * Utility class to composite tiles into a complete image\n * and track the rendered state of an image as new tiles\n * load.\n */\n\nexport default class CompositeImage\n{\n    _levels: DivaTiledPage[];\n    _urlsToTiles: Record<string, DivaTileAlt>;\n    _loadedByLevel: Record<number, TileCoverageMap>;\n\n    constructor(levels: DivaTiledPage[])\n    {\n        this._levels = levels;  // Assume levels sorted high-res first\n        const urlsToTiles: Record<string, DivaTileAlt> = this._urlsToTiles = {};\n\n        levels.forEach(level =>\n        {\n            level.tiles.forEach((tile: DivaTileSource) =>\n            {\n                urlsToTiles[tile.url] = {\n                    zoomLevel: level.zoomLevel,\n                    row: tile.row,\n                    col: tile.col\n                };\n            });\n        });\n\n        this.clear();\n    }\n\n    clear ()\n    {\n        const loadedByLevel: Record<number, TileCoverageMap> = this._loadedByLevel = {};\n\n        this._levels.forEach((level) => {\n            loadedByLevel[level.zoomLevel] = new TileCoverageMap(level.rows, level.cols);\n        });\n    }\n\n    getTiles (baseZoomLevel: number | null): DivaTileSource[]\n    {\n        const toRenderByLevel: DivaTileSource[][] = [];\n        const highestZoomLevel = this._levels[0].zoomLevel;\n        const covered = new TileCoverageMap(this._levels[0].rows, this._levels[0].cols);\n\n        let bestLevelIndex;\n\n        // Default to the lowest zoom level\n        if (baseZoomLevel === null)\n        {\n            bestLevelIndex = 0;\n        }\n        else\n        {\n            const ceilLevel = Math.ceil(baseZoomLevel);\n            bestLevelIndex = findIndex(this._levels, (level: DivaTiledPage): boolean => level.zoomLevel <= ceilLevel);\n            // bestLevelIndex = this._levels.findIndex((level) => level.zoomLevel <= ceilLevel);\n        }\n\n\n        // The best level, followed by higher-res levels in ascending order of resolution,\n        // followed by lower-res levels in descending order of resolution\n        const levelsByPreference = this._levels.slice(0, bestLevelIndex + 1).reverse()\n            .concat(this._levels.slice(bestLevelIndex + 1));\n\n        levelsByPreference.forEach( (level: DivaTiledPage) =>\n        {\n            const loaded: TileCoverageMap = this._loadedByLevel[level.zoomLevel];\n\n            let additionalTiles: DivaTileSource[] = level.tiles.filter(tile => loaded.isLoaded(tile.row, tile.col));\n\n            // Filter out entirely covered tiles\n\n            // FIXME: Is it better to draw all of a partially covered tile,\n            // with some of it ultimately covered, or to pick out the region\n            // which needs to be drawn?\n            // See https://github.com/DDMAL/diva.js/issues/358\n            const scaleRatio = Math.pow(2, highestZoomLevel - level.zoomLevel);\n\n            additionalTiles = additionalTiles.filter(tile => {\n                let isNeeded = false;\n\n                const highResRow = tile.row * scaleRatio;\n                const highResCol = tile.col * scaleRatio;\n\n                for (let i=0; i < scaleRatio; i++)\n                {\n                    for (let j=0; j < scaleRatio; j++)\n                    {\n                        if (!covered.isLoaded(highResRow + i, highResCol + j))\n                        {\n                            isNeeded = true;\n                            covered.set(highResRow + i, highResCol + j, true);\n                        }\n                    }\n                }\n\n                return isNeeded;\n            });\n\n            toRenderByLevel.push(additionalTiles);\n        });\n\n        // Less-preferred tiles should come first\n        toRenderByLevel.reverse();\n\n        const tiles: DivaTileSource[] = [];\n\n        toRenderByLevel.forEach((byLevel: DivaTileSource[]) => {\n            tiles.push.apply(tiles, byLevel);\n        });\n\n        return tiles;\n    }\n\n    /**\n     * Update the composite image to take into account all the URLs\n     * loaded in an image cache.\n     *\n     * @param cache {ImageCache}\n     */\n    updateFromCache (cache: ImageCache)\n    {\n        this.clear();\n\n        this._levels.forEach( (level: DivaTiledPage) =>\n        {\n            const loaded: TileCoverageMap = this._loadedByLevel[level.zoomLevel];\n\n            level.tiles.forEach(tile => {\n                if (cache.has(tile.url))\n                {\n                    loaded.set(tile.row, tile.col, true);\n                }\n            });\n        }, this);\n    }\n\n    updateWithLoadedUrls (urls: string[])\n    {\n        urls.forEach( (url: string) =>\n        {\n            const entry = this._urlsToTiles[url];\n            this._loadedByLevel[entry.zoomLevel].set(entry.row, entry.col, true);\n        });\n    }\n}\n\n// function fill (count, value)\n// {\n//     const arr = new Array(count);\n//\n//     for (let i=0; i < count; i++)\n//         arr[i] = value;\n//\n//     return arr;\n// }\n\nfunction findIndex (array: any[], predicate: ((a: any, b: any) => boolean)): number\n{\n    const length = array.length;\n    for (let i = 0; i < length; i++)\n    {\n        if (predicate(array[i], i))\n        {\n            return i;\n        }\n    }\n\n    return -1;\n}\n","import { Events } from './utils/events';\n\nconst diva = {\n    Events: Events,\n};\n\nexport default diva;\n","import './utils/vanilla.kinetic';\nimport './utils/dragscroll';\nimport { elt } from \"./utils/elt\";\nimport {\n    DivaParentElementNotFoundException,\n    NotAnIIIFManifestException,\n    ObjectDataNotSuppliedException\n} from \"./exceptions\";\nimport globalDiva from \"./diva-global\";\nimport ViewerCore from \"./viewer-core\";\nimport ImageManifest from \"./image-manifest\";\nimport Toolbar from \"./toolbar\";\nimport HashParams from \"./utils/hash-params\";\nimport {ActiveViewOptions, DivaState, Options, HashParameters, PageRegionOptions} from \"./options-settings\";\nimport {Dimension, DivaPage, Offset, OptionalDimension} from \"./viewer-type-definitions\";\n\n/**\n * The top-level class for Diva objects. This is instantiated by passing in an HTML element\n * ID or HTML Element node and an object containing a list of options, of which the 'objectData'\n * option is required and which must point to a IIIF Presentation API Manifest:\n *\n * var diva = new Diva('element-id', {\n *     objectData: \"http://example.com/iiif-manifest.json\"\n * });\n *\n * This class also serves as the entry point for the Events system, in which applications can subscribe\n * to notifications sent from Diva instances:\n *\n * Diva.Events.subscribe('VisiblePageDidChange', function () { console.log(\"Visible Page Changed\"); });\n *\n *\n *\n **/\nclass Diva\n{\n    element: HTMLElement | null;\n    options: Options;\n    viewerState: any;\n    settings: any;\n    toolbar: any;\n    hashState: any;\n    divaState: DivaState;\n\n    constructor (element: HTMLElement, options: Options)\n    {\n        /*\n         * If a string is passed in, convert that to an element.\n         * */\n        if (!(element instanceof HTMLElement))\n        {\n            this.element = document.getElementById(element);\n\n            if (this.element === null)\n            {\n                throw new DivaParentElementNotFoundException(\"The parent element was not found.\");\n            }\n        }\n\n        if (!options.objectData)\n        {\n            throw new ObjectDataNotSuppliedException('You must supply either a URL or a literal object to the `objectData` key.');\n        }\n\n        this.options = Object.assign({\n            adaptivePadding: 0.05,      // The ratio of padding to the page dimension\n            arrowScrollAmount: 40,      // The amount (in pixels) to scroll by when using arrow keys\n            blockMobileMove: false,     // Prevent moving or scrolling the page on mobile devices\n            objectData: '',             // A IIIF Manifest or a JSON file generated by process.py that provides the object dimension data, or a URL pointing to such data - *REQUIRED*\n            enableAutoTitle: true,      // Shows the title within a div of id diva-title\n            enableFilename: true,       // Uses filenames and not page numbers for links (i=bm_001.tif, not p=1)\n            enableFullscreen: true,     // Enable or disable fullscreen icon (mode still available)\n            enableGotoPage: true,       // A \"go to page\" jump box\n            enableGotoSuggestions: true, // Controls whether suggestions are shown under the input field when the user is typing in the 'go to page' form\n            enableGridIcon: true,       // A grid view of all the pages\n            enableGridControls: 'buttons',  // Specify control of pages per grid row in Grid view. Possible values: 'buttons' (+/-), 'slider'. Any other value disables the controls.\n            enableImageTitles: true,    // Adds \"Page {n}\" title to page images if true\n            enableIndexAsLabel: false,  // Use index numbers instead of page labels in the page n-m display.\n            enableKeyScroll: true,      // Captures scrolling using the arrow and page up/down keys regardless of page focus. When off, defers to default browser scrolling behavior.\n            enableLinkIcon: true,       // Controls the visibility of the link icon\n            enableNonPagedVisibilityIcon: true, // Controls the visibility of the icon to toggle the visibility of non-paged pages. (Automatically hidden if no 'non-paged' pages).\n            enableSpaceScroll: false,   // Scrolling down by pressing the space key\n            enableToolbar: true,        // Enables the toolbar. Note that disabling this means you have to handle all controls yourself.\n            enableZoomControls: 'buttons', // Specify controls for zooming in and out. Possible values: 'buttons' (+/-), 'slider'. Any other value disables the controls.\n            fillParentHeight: true,     // Use a flexbox layout to allow Diva to fill its parent's height\n            fixedPadding: 10,           // Fallback if adaptive padding is set to 0\n            fixedHeightGrid: true,      // So each page in grid view has the same height (only widths differ)\n            goDirectlyTo: 0,            // Default initial page to show (0-indexed)\n            hashParamSuffix: null,      // Used when there are multiple document viewers on a page\n            imageCrossOrigin: 'anonymous', // Set crossOrigin property for image requests\n            inFullscreen: false,        // Set to true to load fullscreen mode initially\n            inBookLayout: false,       // Set to true to view the document with facing pages in document mode\n            inGrid: false,              // Set to true to load grid view initially\n            maxPagesPerRow: 8,          // Maximum number of pages per row in grid view\n            maxZoomLevel: -1,           // Optional; defaults to the max zoom returned in the JSON response\n            minPagesPerRow: 2,          // Minimum pages per row in grid view. Recommended default.\n            minZoomLevel: 0,            // Defaults to 0 (the minimum zoom)\n            onGotoSubmit: null,         // When set to a function that takes a string and returns a page index, this will override the default behaviour of the 'go to page' form submission\n            pageAliases: {},            // An object mapping specific page indices to aliases (has priority over 'pageAliasFunction'\n            pageAliasFunction: function(){return false;},  // A function mapping page indices to an alias. If false is returned, default page number is displayed\n            pageLoadTimeout: 200,       // Number of milliseconds to wait before loading pages\n            pagesPerRow: 5,             // The default number of pages per row in grid view\n            requestHeaders: {\"Accept\": \"application/json\"}, // Default header sent off to the server in content negotiation\n            showNonPagedPages: false,   // Whether pages tagged as 'non-paged' (in IIIF manifests only) should be visible after initial load\n            throbberTimeout: 100,       // Number of milliseconds to wait before showing throbber\n            tileHeight: 256,            // The height of each tile, in pixels; usually 256\n            tileWidth: 256,             // The width of each tile, in pixels; usually 256\n            toolbarParentObject: null,  // The toolbar parent object.\n            verticallyOriented: true,   // Determines vertical vs. horizontal orientation\n            viewportMargin: 200,        // Pretend tiles +/- 200px away from viewport are in\n            zoomLevel: 2                // The initial zoom level (used to store the current zoom level)\n        }, options);\n\n        // In order to fill the height, use a wrapper div displayed using a flexbox layout\n        const wrapperElement = elt('div', {\n            class: `diva-wrapper${this.options.fillParentHeight ? \" diva-wrapper-flexbox\" : \"\"}`\n        });\n\n        this.element.appendChild(wrapperElement);\n\n        this.options.toolbarParentObject = this.options.toolbarParentObject || wrapperElement;\n\n        const viewerCore = new ViewerCore(wrapperElement, this.options, this);\n\n        this.viewerState = viewerCore.getInternalState();\n        this.settings = viewerCore.getSettings();\n        this.toolbar = this.settings.enableToolbar ? new Toolbar(this) : null;\n\n        wrapperElement.id = this.settings.ID + 'wrapper';\n\n        this.divaState = {\n            viewerCore: viewerCore,\n            toolbar: this.toolbar\n        };\n\n        // only render the toolbar after the object has been loaded\n        let handle = globalDiva.Events.subscribe('ObjectDidLoad', () =>\n        {\n            if (this.toolbar !== null)\n            {\n                this.toolbar.render();\n            }\n\n            globalDiva.Events.unsubscribe(handle);\n        });\n\n        this.hashState = this._getHashParamState();\n\n        this._loadOrFetchObjectData();\n    }\n\n    /**\n     * @private\n     **/\n    _loadOrFetchObjectData ()\n    {\n        if (typeof this.settings.objectData === 'object')\n        {\n            // Defer execution until initialization has completed\n            setTimeout(() =>\n            {\n                this._loadObjectData(this.settings.objectData, this.hashState);\n            }, 0);\n        }\n        else\n        {\n            const pendingManifestRequest: Promise<void> = fetch(this.settings.objectData, {\n                headers: this.settings.requestHeaders\n            }).then( (response) =>\n            {\n                if (!response.ok)\n                {\n                    // trigger manifest load error event\n                    globalDiva.Events.publish('ManifestFetchError', [response], this);\n\n                    this._ajaxError(response);\n\n                    let error = new Error(response.statusText);\n                    error.response = response;\n                    throw error;\n                }\n                return response.json();\n\n            }).then( (data) =>\n            {\n                this._loadObjectData(data, this.hashState);\n            });\n\n            // Store the pending request so that it can be cancelled in the event that Diva needs to be destroyed\n            this.divaState.viewerCore.setPendingManifestRequest(pendingManifestRequest);\n        }\n    }\n\n    /**\n     * @private\n     **/\n    _showError (message)\n    {\n        this.divaState.viewerCore.showError(message);\n    }\n\n    /**\n     * @private\n     * */\n    _ajaxError (response)\n    {\n        // Show a basic error message within the document viewer pane\n        const errorMessage = ['Invalid objectData setting. Error code: ' + response.status + ' ' + response.statusText];\n\n        // Detect and handle CORS errors\n        const dataHasAbsolutePath = this.settings.objectData.lastIndexOf('http', 0) === 0;\n\n        if (dataHasAbsolutePath)\n        {\n            const jsonHost = this.settings.objectData.replace(/https?:\\/\\//i, \"\").split(/[/?#]/)[0];\n\n            if (window.location.hostname !== jsonHost)\n            {\n                errorMessage.push(\n                    elt('p', 'Attempted to access cross-origin data without CORS.'),\n                    elt('p',\n                        'You may need to update your server configuration to support CORS. For help, see the ',\n                        elt('a', {\n                            href: 'https://github.com/DDMAL/diva.js/wiki/Installation#a-note-about-cross-site-requests',\n                            target: '_blank'\n                        }, 'cross-site request documentation.')\n                    )\n                );\n            }\n        }\n\n        this._showError(errorMessage);\n    }\n\n    /**\n     * @private\n     **/\n    _loadObjectData (responseData: Record<string, any>, hashState: HashParameters)\n    {\n        let manifest: ImageManifest;\n\n        // TODO improve IIIF detection method\n        if (!responseData.hasOwnProperty('@context') && (responseData['@context'].indexOf('iiif') === -1 || responseData['@context'].indexOf('shared-canvas') === -1))\n        {\n            throw new NotAnIIIFManifestException('This does not appear to be a IIIF Manifest.');\n        }\n\n        // trigger ManifestDidLoad event\n        globalDiva.Events.publish('ManifestDidLoad', [responseData], this);\n        manifest = ImageManifest.fromIIIF(responseData);\n        const loadOptions = hashState ? this._getLoadOptionsForState(hashState, manifest) : {};\n\n        this.divaState.viewerCore.setManifest(manifest, loadOptions);\n    }\n\n    /**\n     * Parse the hash parameters into the format used by getState and setState\n     *\n     * @private\n     **/\n    _getHashParamState ()\n    {\n        const state: HashParameters = {};\n\n        ['f', 'v', 'z', 'n', 'i', 'p', 'y', 'x'].forEach( (param) =>\n        {\n            const value = HashParams.get(param + this.settings.hashParamSuffix);\n\n            // `false` is returned if the value is missing\n            if (value !== false)\n            {\n                state[param] = value;\n            }\n        });\n\n        // Do some awkward special-casing, since this format is kind of weird.\n\n        // For inFullscreen (f), true and false strings should be interpreted\n        // as booleans.\n        if (state.f === 'true')\n        {\n            state.f = true;\n        }\n        else if (state.f === 'false')\n        {\n            state.f = false;\n        }\n\n        // Convert numerical values to integers, if provided\n        ['z', 'n', 'p', 'x', 'y'].forEach( (param) =>\n        {\n            if (param in state)\n            {\n                state[param] = parseInt(state[param], 10);\n            }\n\n        });\n\n        return state;\n    }\n\n    /**\n     * @private\n     **/\n    _getLoadOptionsForState (state: HashParameters, manifest?: ImageManifest): ActiveViewOptions\n    {\n        manifest = manifest || this.settings.manifest;\n\n        const options: ActiveViewOptions = ('v' in state) ? this._getViewState(state.v as string) : {};\n\n        if ('f' in state)\n        {\n            options.inFullscreen = state.f as boolean;\n        }\n\n        if ('z' in state)\n        {\n            options.zoomLevel = state.z as number;\n        }\n\n        if ('n' in state)\n        {\n            options.pagesPerRow = state.n as number;\n        }\n\n        // Only change specify the page if state.i or state.p is valid\n        let pageIndex: number = this._getPageIndexForManifest(manifest, state.i);\n\n        if (!(pageIndex >= 0 && pageIndex < manifest.pages.length))\n        {\n            pageIndex = (state.p as number) - 1;\n\n            // Possibly NaN\n            if (!(pageIndex >= 0 && pageIndex < manifest.pages.length))\n            {\n                pageIndex = -1;\n            }\n        }\n\n        if (pageIndex >= 0)\n        {\n            const horizontalOffset = parseInt((state.x as string), 10);\n            const verticalOffset = parseInt((state.y as string), 10);\n\n            options.goDirectlyTo = pageIndex;\n            options.horizontalOffset = horizontalOffset;\n            options.verticalOffset = verticalOffset;\n        }\n\n        return options;\n    }\n\n    /**\n     * @private\n     * */\n    _getViewState (view: string): ActiveViewOptions\n    {\n        switch (view)\n        {\n            case 'd':\n                return {\n                    inGrid: false,\n                    inBookLayout: false\n                };\n\n            case 'b':\n                return {\n                    inGrid: false,\n                    inBookLayout: true\n                };\n\n            case 'g':\n                return {\n                    inGrid: true,\n                    inBookLayout: false\n                };\n\n            default:\n                return {};\n        }\n    }\n\n    /**\n     * @private\n     * */\n    _getPageIndexForManifest (manifest: ImageManifest, filename: string): number\n    {\n        const np: number = manifest.pages.length;\n\n        for (let i: number = 0; i < np; i++)\n        {\n            if (manifest.pages[i].f === filename)\n            {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * @private\n     * */\n    _getState (): HashParameters\n    {\n        let view: string;\n\n        if (this.settings.inGrid)\n        {\n            view = 'g';\n        }\n        else if (this.settings.inBookLayout)\n        {\n            view = 'b';\n        }\n        else\n        {\n            view = 'd';\n        }\n\n        const layout = this.divaState.viewerCore.getCurrentLayout();\n        const pageOffset = layout.getPageToViewportCenterOffset(this.settings.activePageIndex, this.viewerState.viewport);\n\n        return {\n            'f': this.settings.inFullscreen,\n            'v': view,\n            'z': this.settings.zoomLevel,\n            'n': this.settings.pagesPerRow,\n            'i': this.settings.enableFilename ? this.settings.manifest.pages[this.settings.activePageIndex].f : false,\n            'p': this.settings.enableFilename ? false : this.settings.activePageIndex + 1,\n            'y': pageOffset ? pageOffset.y : 0,\n            'x': pageOffset ? pageOffset.x : 0\n        };\n    }\n\n    /**\n     * @private\n     **/\n    _getURLHash (): string\n    {\n        const hashParams: HashParameters = this._getState();\n        const hashStringBuilder = [];\n\n        for (const param in hashParams)\n        {\n            if (hashParams[param] !== false)\n            {\n                hashStringBuilder.push(param + this.settings.hashParamSuffix + '=' + encodeURIComponent(hashParams[param]));\n            }\n        }\n\n        return hashStringBuilder.join('&');\n    }\n\n    /**\n     * Returns the page index associated with the given filename; must called after setting settings.manifest\n     *\n     * @private\n     **/\n    _getPageIndex (filename: string): number\n    {\n        return this._getPageIndexForManifest(this.settings.manifest, filename);\n    }\n\n    /**\n     * @private\n     * */\n    _checkLoaded (): boolean\n    {\n        if (!this.viewerState.loaded)\n        {\n            console.warn(\"The viewer is not completely initialized. This is likely because it is still downloading data. To fix this, only call this function if the isReady() method returns true.\");\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Called when the fullscreen icon is clicked\n     *\n     * @private\n     **/\n    _toggleFullscreen ()\n    {\n        this._reloadViewer({\n            inFullscreen: !this.settings.inFullscreen\n        });\n\n        let hover: boolean = false;\n        let tools: HTMLElement | null = document.getElementById(this.settings.selector + 'tools');\n        if (!tools)\n        {\n            return;\n        }\n\n        const TIMEOUT: number = 2000;\n\n        if (this.settings.inFullscreen)\n        {\n            tools.classList.add(\"diva-fullscreen-tools\");\n\n            document.addEventListener('mousemove', toggleOpacity.bind(this));\n            document.getElementsByClassName('diva-viewport')[0].addEventListener('scroll', toggleOpacity.bind(this));\n            tools.addEventListener('mouseenter', function () {\n                hover = true;\n            });\n            tools.addEventListener('mouseleave', function () {\n                hover = false;\n            });\n        }\n        else\n        {\n            tools.classList.remove(\"diva-fullscreen-tools\");\n        }\n\n        let t: number;\n        function toggleOpacity ()\n        {\n            tools.style.opacity = \"1\";\n            clearTimeout(t);\n            if (!hover && this.settings.inFullscreen) {\n                t = setTimeout(function ()\n                {\n                    tools.style.opacity = \"0\";\n                }, TIMEOUT);\n            }\n        }\n    }\n\n    /**\n     * Toggles between orientations\n     *\n     * @private\n     * */\n    _togglePageLayoutOrientation (): boolean\n    {\n        const verticallyOriented = !this.settings.verticallyOriented;\n\n        //if in grid, switch out of grid\n        this._reloadViewer({\n            inGrid: false,\n            verticallyOriented: verticallyOriented,\n            goDirectlyTo: this.settings.activePageIndex,\n            verticalOffset: this.divaState.viewerCore.getYOffset(),\n            horizontalOffset: this.divaState.viewerCore.getXOffset()\n        });\n\n        return verticallyOriented;\n    }\n\n    /**\n     * Called when the change view icon is clicked\n     *\n     * @private\n     **/\n    _changeView (destinationView: string): boolean\n    {\n        switch (destinationView)\n        {\n            case 'document':\n                return this._reloadViewer({\n                    inGrid: false,\n                    inBookLayout: false\n                });\n\n            case 'book':\n                return this._reloadViewer({\n                    inGrid: false,\n                    inBookLayout: true\n                });\n\n            case 'grid':\n                return this._reloadViewer({\n                    inGrid: true\n                });\n\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * @private\n     *\n     * @param {Number} pageIndex - 0-based page index.\n     * @param {Number} xAnchor - x coordinate to jump to on resulting page.\n     * @param {Number} yAnchor - y coordinate to jump to on resulting page.\n     * @returns {Boolean} - Whether the jump was successful.\n     **/\n    _gotoPageByIndex (pageIndex: number, xAnchor?: string, yAnchor?: string): boolean\n    {\n        if (this._isPageIndexValid(pageIndex))\n        {\n            const xOffset = this.divaState.viewerCore.getXOffset(pageIndex, xAnchor);\n            const yOffset = this.divaState.viewerCore.getYOffset(pageIndex, yAnchor);\n\n            this.viewerState.renderer.goto(pageIndex, yOffset, xOffset);\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if a page index is valid\n     *\n     * @private\n     * @param {Number} pageIndex - Numeric (0-based) page index\n     * @return {Boolean} whether the page index is valid or not.\n     */\n    _isPageIndexValid (pageIndex: number): boolean\n    {\n        return this.settings.manifest.isPageValid(pageIndex, this.settings.showNonPagedPages);\n    }\n\n    /**\n     * Given a pageX and pageY value, returns either the page visible at that (x,y)\n     * position or -1 if no page is.\n     *\n     * @private\n     */\n    _getPageIndexForPageXYValues (pageX: number, pageY: number): number\n    {\n        //get the four edges of the outer element\n        const outerOffset = this.viewerState.outerElement.getBoundingClientRect();\n        const outerTop = outerOffset.top;\n        const outerLeft = outerOffset.left;\n        const outerBottom = outerOffset.bottom;\n        const outerRight = outerOffset.right;\n\n        //if the clicked position was outside the diva-outer object, it was not on a visible portion of a page\n        if (pageX < outerLeft || pageX > outerRight)\n        {\n            return -1;\n        }\n\n        if (pageY < outerTop || pageY > outerBottom)\n        {\n            return -1;\n        }\n\n        //navigate through all diva page objects\n        const pages = document.getElementsByClassName('diva-page');\n        let curPageIdx = pages.length;\n        while (curPageIdx--)\n        {\n            //get the offset for each page\n            const curPage = pages[curPageIdx];\n            const curOffset = curPage.getBoundingClientRect();\n\n            //if this point is outside the horizontal boundaries of the page, continue\n            if (pageX < curOffset.left || pageX > curOffset.right)\n            {\n                continue;\n            }\n\n            //same with vertical boundaries\n            if (pageY < curOffset.top || pageY > curOffset.bottom)\n            {\n                continue;\n            }\n\n            //if we made it through the above two, we found the page we're looking for\n            return parseInt(curPage.getAttribute('data-index'), 10);\n        }\n\n        //if we made it through that entire while loop, we didn't click on a page\n        return -1;\n    }\n\n    /**\n     * @private\n     **/\n    _reloadViewer (newOptions: ActiveViewOptions): boolean\n    {\n        return this.divaState.viewerCore.reload(newOptions);\n    }\n\n    /**\n     * @private\n     */\n    _getCurrentURL (): string\n    {\n        return location.protocol + '//' + location.host + location.pathname + location.search + '#' + this._getURLHash();\n    }\n\n    /**\n     * ===============================================\n     *                PUBLIC FUNCTIONS\n     * ===============================================\n     **/\n\n    /**\n     *  Activate this instance of diva via the active Diva controller.\n     *\n     *  @public\n     */\n    activate (): void\n    {\n        this.viewerState.isActiveDiva = true;\n    }\n\n    /**\n     * Change the object (objectData) parameter currently being rendered by Diva.\n     *\n     * @public\n     * @params {object} objectData - An IIIF Manifest object OR a URL to a IIIF manifest.\n     */\n    changeObject (objectData)\n    {\n        this.viewerState.loaded = false;\n        this.divaState.viewerCore.clear();\n\n        if (this.viewerState.renderer)\n        {\n            this.viewerState.renderer.destroy();\n        }\n\n        this.viewerState.options.objectData = objectData;\n\n        this._loadOrFetchObjectData();\n    }\n\n    /**\n     * Change views. Takes 'document', 'book', or 'grid' to specify which view to switch into\n     *\n     * @public\n     * @params {string} destinationView - the destination view to change to.\n     */\n    changeView (destinationView: string): boolean\n    {\n        return this._changeView(destinationView);\n    }\n\n    /**\n     *  Deactivate this diva instance through the active Diva controller.\n     *\n     *  @public\n     **/\n    deactivate (): void\n    {\n        this.viewerState.isActiveDiva = false;\n    }\n\n    /**\n     * Destroys this instance, tells plugins to do the same\n     *\n     * @public\n     **/\n    destroy (): void\n    {\n        this.divaState.viewerCore.destroy();\n    }\n\n    /**\n     * Disables document dragging, scrolling (by keyboard if set), and zooming by double-clicking\n     *\n     * @public\n     **/\n    disableScrollable (): void\n    {\n        this.divaState.viewerCore.disableScrollable();\n    }\n\n    /**\n     * Re-enables document dragging, scrolling (by keyboard if set), and zooming by double-clicking\n     *\n     * @public\n     **/\n    enableScrollable (): void\n    {\n        this.divaState.viewerCore.enableScrollable();\n    }\n\n    /**\n     * Disables document drag scrolling\n     *\n     * @public\n     */\n    disableDragScrollable (): void\n    {\n        this.divaState.viewerCore.disableDragScrollable();\n    }\n\n    /**\n     * Enables document drag scrolling\n     *\n     * @public\n     */\n    enableDragScrollable (): void\n    {\n        this.divaState.viewerCore.enableDragScrollable();\n    }\n\n    /**\n     * Enter fullscreen mode if currently not in fullscreen mode. If currently in fullscreen\n     * mode this will have no effect.\n     *\n     * This function will work even if enableFullscreen is set to false in the options.\n     *\n     * @public\n     * @returns {boolean} - Whether the switch to fullscreen was successful or not.\n     **/\n    enterFullscreenMode (): boolean\n    {\n        if (!this.settings.inFullscreen)\n        {\n            this._toggleFullscreen();\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Enter grid view if currently not in grid view. If currently in grid view mode\n     * this will have no effect.\n     *\n     * @public\n     * @returns {boolean} - Whether the switch to grid view was successful or not.\n     **/\n    enterGridView (): boolean\n    {\n        if (!this.settings.inGrid)\n        {\n            this._changeView('grid');\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns an array of all page image URIs in the document.\n     *\n     * @public\n     * @returns {Array} - An array of all the URIs in the document.\n     * */\n    getAllPageURIs (): string[]\n    {\n        return this.settings.manifest.pages.map( (pg: DivaPage) =>\n        {\n            return pg.f;\n        });\n    }\n\n    /**\n     * Get the canvas identifier for the currently visible page.\n     *\n     * @public\n     * @returns {string} - The URI of the currently visible canvas.\n     **/\n    getCurrentCanvas (): string\n    {\n        return this.settings.manifest.pages[this.settings.activePageIndex].canvas;\n    }\n\n    /**\n     * Get the canvas label for the currently visible page.\n     *\n     * @public\n     * @returns {string} - The label of the currently visible canvas.\n     **/\n    getCurrentCanvasLabel (): string\n    {\n        return this.settings.manifest.pages[this.settings.activePageIndex].l;\n    }\n\n    /**\n     * Returns the dimensions of the current page at the current zoom level. Also works in\n     * grid view.\n     *\n     * @public\n     * @returns {object} - An object containing the current page dimensions at the current zoom level.\n     **/\n    getCurrentPageDimensionsAtCurrentZoomLevel (): Dimension | null\n    {\n        return this.getPageDimensionsAtCurrentZoomLevel(this.settings.activePageIndex);\n    }\n\n    /**\n     * Returns an array of page indices that are visible in the viewport.\n     *\n     * @public\n     * @returns {array} - The 0-based indices array for the currently visible pages.\n     **/\n    getCurrentPageIndices (): number[]\n    {\n        return this.settings.currentPageIndices;\n    }\n\n    /**\n     * Returns the 0-based index for the current page.\n     *\n     * @public\n     * @returns {number} - The 0-based index for the currently visible page.\n     **/\n     getActivePageIndex (): number\n     {\n        return this.settings.activePageIndex;\n     }\n\n    /**\n     * Shortcut to getPageOffset for current page.\n     *\n     * @public\n     * @returns {object} - The offset between the upper left corner and the page.\n     * */\n    getCurrentPageOffset (): object\n    {\n        return this.getPageOffset(this.settings.activePageIndex);\n    }\n\n    /**\n     * Returns the current URI for the visible page.\n     *\n     * @public\n     * @returns {string} - The URI for the current page image.\n     **/\n    getCurrentPageURI (): string\n    {\n        return this.settings.manifest.pages[this.settings.activePageIndex].f;\n    }\n\n    /**\n     * Return the current URL for the viewer, including the hash parameters reflecting\n     * the current state of the viewer.\n     *\n     * @public\n     * @returns {string} - The URL for the current view state.\n     * */\n    getCurrentURL (): string\n    {\n        return this._getCurrentURL();\n    }\n\n    /**\n     * Get the number of grid pages per row.\n     *\n     * @public\n     * @returns {number} - The number of grid pages per row.\n     **/\n    getGridPagesPerRow (): number\n    {\n        // TODO(wabain): Add test case\n        return this.settings.pagesPerRow;\n    }\n\n    /**\n     * Get the instance ID number.\n     *\n     * @public\n     * @returns {number} - The instance ID.\n     * */\n    //\n    getInstanceId (): number\n    {\n        return this.settings.ID;\n    }\n\n    /**\n     * Get the instance selector for this instance. This is the selector for the parent\n     * div.\n     *\n     * @public\n     * @returns {string} - The viewport selector.\n     * */\n    getInstanceSelector (): string | null\n    {\n        return this.divaState.viewerCore.viewerState.selector;\n    }\n\n    /**\n     * Returns the title of the document, based on the label in the IIIF manifest.\n     *\n     * @public\n     * @returns {string} - The current title of the object from the label key in the IIIF Manifest.\n     **/\n    getItemTitle (): string\n    {\n        return this.settings.manifest.itemTitle;\n    }\n\n    /**\n     * Gets the maximum zoom level for the entire document.\n     *\n     * @public\n     * @returns {number} - The maximum zoom level for the document\n     * */\n    getMaxZoomLevel (): number\n    {\n        return this.settings.maxZoomLevel;\n    }\n\n    /**\n     * Gets the max zoom level for a given page.\n     *\n     * @public\n     * @param {number} pageIdx - The 0-based index number for the page.\n     * @returns {number} - The maximum zoom level for that page.\n     * */\n    getMaxZoomLevelForPage (pageIdx: number): number | null\n    {\n        if (!this._checkLoaded())\n        {\n            return null;\n        }\n\n        return this.settings.manifest.pages[pageIdx].m;\n    }\n\n    /**\n     * Gets the minimum zoom level for the entire document.\n     *\n     * @public\n     * @returns {number} - The minimum zoom level for the document\n     * */\n    getMinZoomLevel (): number\n    {\n        return this.settings.minZoomLevel;\n    }\n\n    /**\n     * Gets the number of pages in the document.\n     *\n     * @public\n     * @returns {number} - The number of pages in the document.\n     * */\n    getNumberOfPages (): number | boolean\n    {\n        if (!this._checkLoaded())\n        {\n            return false;\n        }\n\n        return this.settings.numPages;\n    }\n\n    /**\n     * If a canvas has multiple images defined, returns the non-primary image.\n     *\n     * @public\n     * @params {number} pageIndex - The page index for which to return the other images.\n     * @returns {object} An object containing the other images.\n     **/\n    getOtherImages (pageIndex: number): object\n    {\n        return this.settings.manifest.pages[pageIndex].otherImages;\n    }\n\n    /**\n     * Get page dimensions in the current view and zoom level\n     *\n     * @public\n     * @params {number} pageIndex - A valid 0-based page index\n     * @returns {object} - An object containing the dimensions of the page\n     * */\n    getPageDimensions (pageIndex: number): Dimension | null\n    {\n        if (!this._checkLoaded())\n        {\n            return null;\n        }\n\n        return this.divaState.viewerCore.getCurrentLayout().getPageDimensions(pageIndex);\n    }\n\n    /**\n     * Returns the dimensions of a given page at the current zoom level.\n     * Also works in Grid view\n     *\n     * @public\n     * @param {number} pageIndex - The 0-based page index\n     * @returns {object} - An object containing the page dimensions at the current zoom level.\n     * */\n    getPageDimensionsAtCurrentZoomLevel (pageIndex: number): Dimension | null\n    {\n        if (!this._isPageIndexValid(pageIndex))\n        {\n            throw new Error('Invalid Page Index');\n        }\n\n        return this.divaState.viewerCore.getCurrentLayout().getPageDimensions(pageIndex);\n    }\n\n    /**\n     * Get page dimensions at a given zoom level\n     *\n     * @public\n     * @params {number} pageIdx - A valid 0-based page index\n     * @params {number} zoomLevel - A candidate zoom level.\n     * @returns {object} - An object containing the dimensions of the page at the given zoom level.\n     **/\n    getPageDimensionsAtZoomLevel (pageIdx: number, zoomLevel: number): Dimension | null\n    {\n        if (!this._checkLoaded())\n        {\n            return null;\n        }\n\n        if (zoomLevel > this.settings.maxZoomLevel)\n        {\n            zoomLevel = this.settings.maxZoomLevel;\n        }\n\n        const pg = this.settings.manifest.pages[pageIdx];\n        const pgAtZoom = pg.d[zoomLevel];\n\n        return {\n            width: pgAtZoom.w,\n            height: pgAtZoom.h\n        };\n    }\n\n    /**\n     * Returns a URL for the image of the page at the given index. The\n     * optional size parameter supports setting the image width or height\n     * (default is full-sized).\n     *\n     * @public\n     * @params {number} pageIndex - 0-based page index\n     * @params {?object} size - an object containing width and height information\n     * @returns {string} - The IIIF URL for a given page at an optional size\n     */\n    getPageImageURL (pageIndex: number, size: OptionalDimension): string\n    {\n        return this.settings.manifest.getPageImageURL(pageIndex, size);\n    }\n\n    /**\n     * Given a set of co-ordinates (e.g., from a mouse click), return the 0-based page index\n     * for which it matches.\n     *\n     * @public\n     * @params {number} pageX - The x co-ordinate\n     * @params {number} pageY - The y co-ordinate\n     * @returns {number} - The page index matching the co-ordinates.\n     * */\n    getPageIndexForPageXYValues (pageX: number, pageY: number): number\n    {\n        return this._getPageIndexForPageXYValues(pageX, pageY);\n    }\n\n    /**\n     * Returns distance between the northwest corners of diva-inner and page index.\n     *\n     * @public\n     * @params {number} pageIndex - The 0-based page index\n     * @params {?options} options - A set of options to pass in.\n     * @returns {object} - The offset between the upper left corner and the page.\n     *\n     * */\n    getPageOffset (pageIndex: number, options?: PageRegionOptions): Offset\n    {\n        const region = this.divaState.viewerCore.getPageRegion(pageIndex, options)!;\n\n        return {\n            top: region.top,\n            left: region.left\n        };\n    }\n\n    /**\n     * Get the instance settings.\n     *\n     * @public\n     * @returns {object} - The current instance settings.\n     * */\n    getSettings (): object\n    {\n        return this.settings;\n    }\n\n    /**\n     * Get an object representing the complete state of the viewer.\n     *\n     * @public\n     * @returns {object} - The current instance state.\n     * */\n    getState (): HashParameters\n    {\n        return this._getState();\n    }\n\n    /**\n     * Get the current zoom level.\n     *\n     * @public\n     * @returns {number} - The current zoom level.\n     * */\n    getZoomLevel (): number\n    {\n        return this.settings.zoomLevel;\n    }\n\n    /**\n     *  Go to a particular page (with indexing starting at 0).\n     *  The (xAnchor) side of the page will be anchored to the (xAnchor) side of the diva-outer element\n     *\n     *  @public\n     *  @params {number} pageIndex - 0-based page index.\n     *  @params {?string} xAnchor - may either be \"left\", \"right\", or default \"center\"\n     *  @params {?string} yAnchor - may either be \"top\", \"bottom\", or default \"center\"; same process as xAnchor.\n     *  @returns {boolean} - True if the page index is valid; false if it is not.\n     * */\n    gotoPageByIndex (pageIndex: number, xAnchor: string, yAnchor: string): boolean\n    {\n        return this._gotoPageByIndex(pageIndex, xAnchor, yAnchor);\n    }\n\n    /**\n     * Given a canvas label, attempt to go to that page. If no label was found.\n     * the label will be attempted to match against the page index.\n     *\n     * @public\n     * @params {string} label - The label to search on.\n     * @params {?string} xAnchor - may either be \"left\", \"right\", or default \"center\"\n     * @params {?string} yAnchor - may either be \"top\", \"bottom\", or default \"center\"\n     * @returns {boolean} - True if the page index is valid; false if it is not.\n     * */\n    gotoPageByLabel (label: string, xAnchor?: string, yAnchor?: string): boolean\n    {\n        const pages = this.settings.manifest.pages;\n        let llc = label.toLowerCase();\n\n        for (let i = 0, len = pages.length; i < len; i++)\n        {\n            if (pages[i].l.toLowerCase().indexOf(llc) > -1)\n            {\n                return this._gotoPageByIndex(i, xAnchor, yAnchor);\n            }\n        }\n\n        const pageIndex = parseInt(label, 10) - 1;\n        return this._gotoPageByIndex(pageIndex, xAnchor, yAnchor);\n    }\n\n    /**\n     * Jump to a page based on its URI.\n     *\n     * @public\n     * @params {string} uri - The URI of the image to jump to.\n     * @params {?string} xAnchor - may either be \"left\", \"right\", or default \"center\"\n     * @params {?string} yAnchor - may either be \"top\", \"bottom\", or default \"center\"\n     * @returns {boolean} true if successful and false if the URI is not found.\n     */\n    gotoPageByURI (uri: string, xAnchor?: string, yAnchor?: string): boolean\n    {\n        const pageIndex = this._getPageIndex(uri);\n        return this._gotoPageByIndex(pageIndex, xAnchor, yAnchor);\n    }\n\n    /**\n     * Whether the page has other images to display.\n     *\n     * @public\n     * @params {number} pageIndex - The 0-based page index\n     * @returns {boolean} Whether the page has other images to display.\n     **/\n    hasOtherImages (pageIndex: number): boolean\n    {\n        return this.settings.manifest.pages[pageIndex].otherImages === true;\n    }\n\n    /**\n     * Hides the pages that are marked \"non-paged\" in the IIIF manifest.\n     *\n     * @public\n     **/\n    hideNonPagedPages ()\n    {\n        this._reloadViewer({ showNonPagedPages: false });\n    }\n\n    /**\n     * Is the viewer currently in full-screen mode?\n     *\n     * @public\n     * @returns {boolean} - Whether the viewer is in fullscreen mode.\n     **/\n    isInFullscreen (): boolean\n    {\n        return this.settings.inFullscreen;\n    }\n\n    /**\n     * Check if a page index is within the range of the document\n     *\n     * @public\n     * @returns {boolean} - Whether the page index is valid.\n     **/\n    isPageIndexValid (pageIndex: number): boolean\n    {\n        return this._isPageIndexValid(pageIndex);\n    }\n\n    /**\n     * Determines if a page is currently in the viewport\n     *\n     * @public\n     * @params {number} pageIndex - The 0-based page index\n     * @returns {boolean} - Whether the page is currently in the viewport.\n     **/\n    isPageInViewport (pageIndex: number): boolean\n    {\n        return this.viewerState.renderer.isPageVisible(pageIndex);\n    }\n\n    /**\n     * Whether the Diva viewer has been fully initialized.\n     *\n     * @public\n     * @returns {boolean} - True if the viewer is initialized; false otherwise.\n     **/\n    isReady (): boolean\n    {\n        return this.viewerState.loaded;\n    }\n\n    /**\n     * Check if something (e.g. a highlight box on a particular page) is visible\n     *\n     * @public\n     * @params {number} pageIndex - The 0-based page index\n     * @params {number} leftOffset - The distance of the region from the left of the viewport\n     * @params {number} topOffset - The distance of the region from the top of the viewport\n     * @params {number} width - The width of the region\n     * @params {number} height - The height of the region\n     * @returns {boolean} - Whether the region is in the viewport.\n     **/\n    isRegionInViewport (pageIndex: number, leftOffset: number, topOffset: number, width: number, height: number): boolean\n    {\n        const layout = this.divaState.viewerCore.getCurrentLayout();\n\n        if (!layout)\n        {\n            return false;\n        }\n\n        const offset: Offset = layout.getPageOffset(pageIndex)!;\n\n        const top = offset.top + topOffset;\n        const left = offset.left + leftOffset;\n\n        return this.viewerState.viewport.intersectsRegion({\n            top: top,\n            bottom: top + height,\n            left: left,\n            right: left + width\n        });\n    }\n\n    /**\n     * Whether the page layout is vertically or horizontally oriented.\n     *\n     * @public\n     * @returns {boolean} - True if vertical; false if horizontal.\n     **/\n    isVerticallyOriented (): boolean\n    {\n        return this.settings.verticallyOriented;\n    }\n\n    /**\n     * Leave fullscreen mode if currently in fullscreen mode.\n     *\n     * @public\n     * @returns {boolean} - true if in fullscreen mode intitially, false otherwise\n     **/\n    leaveFullscreenMode (): boolean\n    {\n        if (this.settings.inFullscreen)\n        {\n            this._toggleFullscreen();\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Leave grid view if currently in grid view.\n     *\n     * @public\n     * @returns {boolean} - true if in grid view initially, false otherwise\n     **/\n    leaveGridView (): boolean\n    {\n        if (this.settings.inGrid)\n        {\n            this._reloadViewer({ inGrid: false });\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Set the number of grid pages per row.\n     *\n     * @public\n     * @params {number} pagesPerRow - The number of pages per row\n     * @returns {boolean} - True if the operation was successful.\n     **/\n    setGridPagesPerRow (pagesPerRow: number): boolean\n    {\n        // TODO(wabain): Add test case\n        if (!this.divaState.viewerCore.isValidOption('pagesPerRow', pagesPerRow))\n        {\n            return false;\n        }\n\n        return this._reloadViewer({\n            inGrid: true,\n            pagesPerRow: pagesPerRow\n        });\n    }\n\n    /**\n     * Align this diva instance with a state object (as returned by getState)\n     *\n     * @public\n     * @params {object} state - A Diva state object.\n     * @returns {boolean} - True if the operation was successful.\n     **/\n    setState (state: HashParameters): boolean\n    {\n        return this._reloadViewer(this._getLoadOptionsForState(state));\n    }\n\n    /**\n     * Sets the zoom level.\n     *\n     * @public\n     * @returns {boolean} - True if the operation was successful.\n     **/\n    setZoomLevel (zoomLevel: number): boolean\n    {\n        if (this.settings.inGrid)\n        {\n            this._reloadViewer({\n                inGrid: false\n            });\n        }\n\n        return this.divaState.viewerCore.zoom(zoomLevel);\n    }\n\n    /**\n     * Show non-paged pages.\n     *\n     * @public\n     * @returns {boolean} - True if the operation was successful.\n     **/\n    showNonPagedPages (): boolean\n    {\n        return this._reloadViewer({ showNonPagedPages: true });\n    }\n\n    /**\n     * Toggle fullscreen mode.\n     *\n     * @public\n     * @returns {boolean} - True if the operation was successful.\n     **/\n    toggleFullscreenMode (): void\n    {\n        this._toggleFullscreen();\n    }\n\n    /**\n     * Show/Hide non-paged pages\n     *\n     * @public\n     * @returns {boolean} - True if the operation was successful.\n     **/\n    toggleNonPagedPagesVisibility (): boolean\n    {\n        return this._reloadViewer({\n            showNonPagedPages: !this.settings.showNonPagedPages\n        });\n    }\n\n    //Changes between horizontal layout and vertical layout. Returns true if document is now vertically oriented, false otherwise.\n    toggleOrientation (): boolean\n    {\n        return this._togglePageLayoutOrientation();\n    }\n\n    /**\n     * Translates a measurement from the zoom level on the largest size\n     * to one on the current zoom level.\n     *\n     * For example, a point 1000 on an image that is on zoom level 2 of 5\n     * translates to a position of 111.111... (1000 / (5 - 2)^2).\n     *\n     * Works for a single pixel co-ordinate or a dimension (e.g., translates a box\n     * that is 1000 pixels wide on the original to one that is 111.111 pixels wide\n     * on the current zoom level).\n     *\n     * @public\n     * @params {number} position - A point on the max zoom level\n     * @returns {number} - The same point on the current zoom level.\n    */\n    translateFromMaxZoomLevel (position: number): number\n    {\n        const zoomDifference = this.settings.maxZoomLevel - this.settings.zoomLevel;\n        return position / Math.pow(2, zoomDifference);\n    }\n\n    /**\n     * Translates a measurement from the current zoom level to the position on the\n     * largest zoom level.\n     *\n     * Works for a single pixel co-ordinate or a dimension (e.g., translates a box\n     * that is 111.111 pixels wide on the current image to one that is 1000 pixels wide\n     * on the current zoom level).\n     *\n     * @public\n     * @params {number} position - A point on the current zoom level\n     * @returns {number} - The same point on the max zoom level.\n    */\n    translateToMaxZoomLevel (position: number): number\n    {\n        const zoomDifference: number = this.settings.maxZoomLevel - this.settings.zoomLevel;\n\n        // if there is no difference, it's a box on the max zoom level and\n        // we can just return the position.\n        if (zoomDifference === 0)\n        {\n            return position;\n        }\n\n        return position * Math.pow(2, zoomDifference);\n    }\n\n    /**\n     * Zoom in.\n     *\n     * @public\n     * @returns {boolean} - false if it's at the maximum zoom\n     **/\n    zoomIn (): boolean\n    {\n        return this.setZoomLevel(this.settings.zoomLevel + 1);\n    }\n\n    /**\n     * Zoom out.\n     * @returns {boolean} - false if it's at the minimum zoom\n     **/\n    zoomOut (): boolean\n    {\n        return this.setZoomLevel(this.settings.zoomLevel - 1);\n    }\n}\n\nDiva.Events = globalDiva.Events;\n\nexport default Diva;\n\n/**\n * Make `Diva` available in the global context.\n * */\nif (typeof window !== 'undefined') {\n    (function (global)\n    {\n        global.Diva = global.Diva || Diva;\n    })(window);\n}\n","import { maxBy } from './utils/maxby';\nimport PageToolsOverlay from './page-tools-overlay';\nimport ViewerCore from \"./viewer-core\";\nimport {ViewerSettings} from \"./options-settings\";\nimport {Offset} from \"./viewer-type-definitions\";\nimport type Viewport from \"./viewport\";\nimport DocumentLayout from './document-layout';\n\n\nexport default class DocumentHandler\n{\n    _viewerCore: ViewerCore\n    _viewerState: ViewerSettings;\n    _overlays: PageToolsOverlay[]\n\n    constructor(viewerCore: ViewerCore)\n    {\n        this._viewerCore = viewerCore;\n        this._viewerState = viewerCore.getInternalState();\n        this._overlays = [];\n\n        if (this._viewerCore.getPageTools().length)\n        {\n            const numPages = viewerCore.getSettings().numPages;\n\n            for (let i = 0; i < numPages; i++)\n            {\n                const overlay = new PageToolsOverlay(i, viewerCore);\n                this._overlays.push(overlay);\n                this._viewerCore.addPageOverlay(overlay);\n\n                // create dummy label for width calculation\n                // this is necessary because the _pageToolsElem is only created on mount\n                // so there's no other way to get its width before the pages are loaded\n                // (which we need to avoid their width temporarily being 0 while loading)\n                let dummyLabel = document.createElement('span');\n                dummyLabel.innerHTML = viewerCore.settings.manifest.pages[i].l;\n                dummyLabel.classList.add('diva-page-labels');\n                dummyLabel.setAttribute('style', 'display: inline-block;');\n                document.body.appendChild(dummyLabel);\n                let labelWidth = dummyLabel.clientWidth;\n                document.body.removeChild(dummyLabel);\n\n                overlay.labelWidth = labelWidth;\n            }\n        }\n    }\n\n    // USER EVENTS\n    onDoubleClick(event: KeyboardEvent, coords: Offset)\n    {\n        const settings = this._viewerCore.getSettings();\n        const newZoomLevel = event.ctrlKey ? settings.zoomLevel - 1 : settings.zoomLevel + 1;\n\n        const position = this._viewerCore.getPagePositionAtViewportOffset(coords);\n        this._viewerCore.zoom(newZoomLevel, position);\n    }\n\n    onPinch(_event: TouchEvent, coords: Offset, startDistance: number, endDistance: number)\n    {\n        // FIXME: Do this check in a way which is less spaghetti code-y\n        const viewerState = this._viewerCore.getInternalState();\n        const settings = this._viewerCore.getSettings();\n\n        let newZoomLevel = Math.log(Math.pow(2, settings.zoomLevel) * endDistance / (startDistance * Math.log(2))) / Math.log(2);\n        newZoomLevel = Math.max(settings.minZoomLevel, newZoomLevel);\n        newZoomLevel = Math.min(settings.maxZoomLevel, newZoomLevel);\n\n        if (newZoomLevel === settings.zoomLevel)\n        {\n            return;\n        }\n\n        const position = this._viewerCore.getPagePositionAtViewportOffset(coords);\n\n        const layout = this._viewerCore.getCurrentLayout();\n        const centerOffset = layout.getPageToViewportCenterOffset(position.anchorPage, viewerState.viewport);\n        const scaleRatio = 1 / Math.pow(2, settings.zoomLevel - newZoomLevel);\n\n        this._viewerCore.reload({\n            zoomLevel: newZoomLevel,\n            goDirectlyTo: position.anchorPage,\n            horizontalOffset: (centerOffset.x - position.offset.left) + position.offset.left * scaleRatio,\n            verticalOffset: (centerOffset.y - position.offset.top) + position.offset.top * scaleRatio\n        });\n    }\n\n    // VIEW EVENTS\n    onViewWillLoad()\n    {\n        this._viewerCore.publish('DocumentWillLoad', this._viewerCore.getSettings());\n    }\n\n    onViewDidLoad()\n    {\n        // TODO: Should only be necessary to handle changes on view update, not\n        // initial load\n        this._handleZoomLevelChange();\n\n        const currentPageIndex = this._viewerCore.getSettings().activePageIndex;\n        const fileName = this._viewerCore.getPageName(currentPageIndex);\n        this._viewerCore.publish(\"DocumentDidLoad\", currentPageIndex, fileName);\n    }\n\n    onViewDidUpdate(renderedPages: any, targetPage: any)\n    {\n        const currentPage = (targetPage !== null) ?\n            targetPage :\n            getCentermostPage(renderedPages, this._viewerCore.getCurrentLayout(), this._viewerCore.getViewport());\n\n        // calculate the visible pages from the rendered pages\n        let temp = this._viewerState.viewport.intersectionTolerance;\n        // without setting to 0, isPageVisible returns true for pages out of viewport by intersectionTolerance\n        this._viewerState.viewport.intersectionTolerance = 0;\n        let visiblePages = renderedPages.filter((index: number) => this._viewerState.renderer.isPageVisible(index));\n        // reset back to original value after getting true visible pages\n        this._viewerState.viewport.intersectionTolerance = temp;\n\n        // Don't change the current page if there is no page in the viewport\n        // FIXME: Would be better to fall back to the page closest to the viewport\n        if (currentPage !== null)\n        {\n            this._viewerCore.setCurrentPages(currentPage, visiblePages);\n        }\n\n        if (targetPage !== null)\n        {\n            this._viewerCore.publish(\"ViewerDidJump\", targetPage);\n        }\n\n        this._handleZoomLevelChange();\n    }\n\n    _handleZoomLevelChange()\n    {\n        const viewerState = this._viewerState;\n        const zoomLevel = viewerState.options.zoomLevel;\n\n        // If this is not the initial load, trigger the zoom events\n        if (viewerState.oldZoomLevel !== zoomLevel && viewerState.oldZoomLevel >= 0)\n        {\n            if (viewerState.oldZoomLevel < zoomLevel)\n            {\n                this._viewerCore.publish(\"ViewerDidZoomIn\", zoomLevel);\n            }\n            else\n            {\n                this._viewerCore.publish(\"ViewerDidZoomOut\", zoomLevel);\n            }\n\n            this._viewerCore.publish(\"ViewerDidZoom\", zoomLevel);\n        }\n\n        viewerState.oldZoomLevel = zoomLevel;\n    }\n\n    destroy()\n    {\n        this._overlays.forEach((overlay) =>\n        {\n            this._viewerCore.removePageOverlay(overlay);\n        }, this);\n    }\n}\n\nfunction getCentermostPage(renderedPages: number[], layout: DocumentLayout, viewport: Viewport)\n{\n    const centerY = viewport.top + (viewport.height / 2);\n    const centerX = viewport.left + (viewport.width / 2);\n\n    // Find the minimum distance from the viewport center to a page.\n    // Compute minus the squared distance from viewport center to the page's border.\n    // http://gamedev.stackexchange.com/questions/44483/how-do-i-calculate-distance-between-a-point-and-an-axis-aligned-rectangle\n    const centerPage = maxBy(renderedPages, pageIndex =>\n    {\n        const dims = layout.getPageDimensions(pageIndex)!;\n        const imageOffset = layout.getPageOffset(pageIndex, {includePadding: true})!;\n\n        const midX = imageOffset.left + (dims.width / 2);\n        const midY = imageOffset.top + (dims.height / 2);\n\n        const dx = Math.max(Math.abs(centerX - midX) - (dims.width / 2), 0);\n        const dy = Math.max(Math.abs(centerY - midY) - (dims.height / 2), 0);\n\n        return -(dx * dx + dy * dy);\n    });\n\n    return centerPage != null ? centerPage : null;\n}\n","/**\n * Translate page layouts, as generated by page-layouts, into an\n * object which computes layout information for the document as\n * a whole.\n */\nimport {\n    Dimension,\n    PageInfo,\n    Region,\n    XYPos,\n    Offset,\n    PageInfoCollection,\n    PageGroup,\n    LayoutGroupPages\n} from \"./viewer-type-definitions\";\nimport {PageRegionOptions, RendererLoadConfig} from \"./options-settings\";\n\n\n\nexport default class DocumentLayout\n{\n    dimensions: Dimension;\n    pageGroups: PageGroup[];\n    _pageLookup: PageInfoCollection;\n\n    constructor (config: RendererLoadConfig, zoomLevel: number)\n    {\n        const computedLayout = getComputedLayout(config, zoomLevel);\n\n        this.dimensions = computedLayout.dimensions;\n        this.pageGroups = computedLayout.pageGroups;\n        this._pageLookup = getPageLookup(computedLayout.pageGroups);\n    }\n\n    /**\n     * @param pageIndex\n     * @returns {PageInfo|null}\n     */\n    getPageInfo (pageIndex: number): PageInfo | null\n    {\n        return this._pageLookup[pageIndex] || null;\n    }\n\n    /**\n     * Gets the page index of the first page so that we don't accidentally assume a first page index.\n     * This is particularly useful when non-paged pages are skipped but we assume the default of 0\n     * as the first page.\n     * @returns {string}\n     */\n    getIndexOfFirstPage()\n    {\n        return Object.keys(this._pageLookup)[0];\n    }\n\n    /**\n     * Get the dimensions of a page\n     *\n     * @param pageIndex\n     * @returns {{height: number, width: number}}\n     */\n    getPageDimensions (pageIndex: number): Dimension | null\n    {\n        if (!this._pageLookup || !this._pageLookup[pageIndex])\n        {\n            return null;\n        }\n\n        const region = getPageRegionFromPageInfo(this._pageLookup[pageIndex]);\n\n        return {\n            height: region.bottom - region.top,\n            width: region.right - region.left\n        };\n    }\n\n    // TODO(wabain): Get rid of this; it's a subset of the page region, so\n    // give that instead\n    /**\n     * Get the top-left coordinates of a page, including*** padding\n     *\n     * @param pageIndex\n     * @param options\n     * @returns {{top: number, left: number} | null}\n     */\n    getPageOffset (pageIndex: number, options?: PageRegionOptions): Offset | null\n    {\n        const region = this.getPageRegion(pageIndex, options);\n\n        if (!region)\n        {\n            return null;\n        }\n\n        return {\n            top: region.top,\n            left: region.left\n        };\n    }\n\n    getPageRegion (pageIndex: number, options?: PageRegionOptions): Region | null\n    {\n        const pageInfo: PageInfo | null = this._pageLookup[pageIndex] || null;\n\n        if (!pageInfo)\n        {\n            return null;\n        }\n\n        const region = getPageRegionFromPageInfo(pageInfo);\n        const padding = pageInfo.group.padding;\n\n        if (options && options.includePadding)\n        {\n            return {\n                top: region.top + padding.top,\n                left: region.left + padding.left,\n                bottom: region.bottom,\n                right: region.right\n            };\n        }\n\n        return {\n            top: region.top,\n            left: region.left,\n            // need to account for plugin icons below the page, see \n            // https://github.com/DDMAL/diva.js/issues/436\n            bottom: region.bottom + padding.top, \n            right: region.right\n        };\n    }\n\n    /**\n     * Get the distance from the top-right of the page to the center of the\n     * specified viewport region\n     *\n     * @param pageIndex\n     * @param viewport {{top: number, left: number, bottom: number, right: number}}\n     * @returns {{x: number, y: number}}\n     */\n    getPageToViewportCenterOffset (pageIndex: number, viewport: Region): XYPos | null\n    {\n        const scrollLeft = viewport.left;\n        const elementWidth = viewport.right - viewport.left;\n\n        const offset: Offset | null = this.getPageOffset(pageIndex);\n        if (!offset)\n        {\n            return null;\n        }\n\n        const x = scrollLeft - offset.left + Math.floor(elementWidth / 2);\n\n        const scrollTop = viewport.top;\n        const elementHeight = viewport.bottom - viewport.top;\n\n        const y = scrollTop - offset.top + Math.floor(elementHeight / 2);\n\n        return {\n            x: x,\n            y: y\n        };\n    }\n}\n\nfunction getPageRegionFromPageInfo (page: PageInfo): Region\n{\n    const top    = page.groupOffset.top  + page.group.region.top;\n    const bottom = top + page.dimensions.height;\n    const left   = page.groupOffset.left + page.group.region.left;\n    const right  = left + page.dimensions.width;\n\n    return {\n        top: top,\n        bottom: bottom,\n        left: left,\n        right: right\n    };\n}\n\nfunction getPageLookup (pageGroups: PageGroup[]): PageInfoCollection\n{\n    const pageLookup: PageInfoCollection = {};\n\n    pageGroups.forEach((group: PageGroup) => {\n        group.pages.forEach(page => {\n            pageLookup[page.index] = {\n                index: page.index,\n                group: group,\n                dimensions: page.dimensions,\n                groupOffset: page.groupOffset\n            };\n        });\n    });\n\n    return pageLookup;\n}\n\nfunction getComputedLayout (config: RendererLoadConfig, zoomLevel: number): { dimensions: Dimension, pageGroups: PageGroup[] }\n{\n    const scaledLayouts: LayoutGroupPages[] = zoomLevel === null ? config.pageLayouts : getScaledPageLayouts(config, zoomLevel);\n\n    const documentSecondaryExtent = getExtentAlongSecondaryAxis(config, scaledLayouts);\n\n    // The current position in the document along the primary axis\n    let primaryDocPosition = config.verticallyOriented ?\n        config.padding.document.top :\n        config.padding.document.left;\n\n    const pageGroups: PageGroup[] = [];\n\n    // TODO: Use bottom, right as well\n    const pagePadding = {\n        top: config.padding.page.top,\n        left: config.padding.page.left\n    };\n\n    scaledLayouts.forEach((layout: LayoutGroupPages, index: number) => {\n        let top, left;\n\n        if (config.verticallyOriented)\n        {\n            top = primaryDocPosition;\n            left = (documentSecondaryExtent - layout.dimensions.width) / 2;\n        }\n        else\n        {\n            top = (documentSecondaryExtent - layout.dimensions.height) / 2;\n            left = primaryDocPosition;\n        }\n\n        const region: Region = {\n            top: top,\n            bottom: top + pagePadding.top + layout.dimensions.height,\n            left: left,\n            right: left + pagePadding.left + layout.dimensions.width\n        };\n\n        pageGroups.push({\n            index: index,\n            dimensions: layout.dimensions,\n            pages: layout.pages,\n            region: region,\n            padding: pagePadding\n        });\n\n        primaryDocPosition = config.verticallyOriented ? region.bottom : region.right;\n    });\n\n    let height, width;\n\n    if (config.verticallyOriented)\n    {\n        height = primaryDocPosition + pagePadding.top;\n        width = documentSecondaryExtent;\n    }\n    else\n    {\n        height = documentSecondaryExtent;\n        width = primaryDocPosition + pagePadding.left;\n    }\n\n    return {\n        dimensions: {\n            height: height,\n            width: width\n        },\n        pageGroups: pageGroups\n    };\n}\n\nfunction getScaledPageLayouts (config: RendererLoadConfig, zoomLevel: number): LayoutGroupPages[]\n{\n    const scaleRatio: number = Math.pow(2, zoomLevel - config.maxZoomLevel!);\n\n    return config.pageLayouts.map(group => ({\n        dimensions: scaleDimensions(group.dimensions, scaleRatio),\n\n        pages: group.pages.map(page => ({\n            index: page.index,\n\n            groupOffset: {\n                top: Math.floor(page.groupOffset.top * scaleRatio),\n                left: Math.floor(page.groupOffset.left * scaleRatio)\n            },\n\n            dimensions: scaleDimensions(page.dimensions, scaleRatio)\n        }))\n    }));\n}\n\nfunction scaleDimensions (dimensions: Dimension, scaleRatio: number): Dimension\n{\n    return {\n        height: Math.floor(dimensions.height * scaleRatio),\n        width: Math.floor(dimensions.width * scaleRatio)\n    };\n}\n\nfunction getExtentAlongSecondaryAxis (config: RendererLoadConfig, scaledLayouts: LayoutGroupPages[]): number\n{\n    // Get the extent of the document along the secondary axis\n    let secondaryDim, secondaryPadding;\n    const docPadding = config.padding.document;\n\n    if (config.verticallyOriented)\n    {\n        secondaryDim = 'width';\n        secondaryPadding = docPadding.left + docPadding.right;\n    }\n    else\n    {\n        secondaryDim = 'height';\n        secondaryPadding = docPadding.top + docPadding.bottom;\n    }\n\n    return secondaryPadding + scaledLayouts.reduce((maxDim: number, layout: any): number => Math.max(layout.dimensions[secondaryDim], maxDim), 0);\n}\n","export function DivaParentElementNotFoundException (message: string)\n{\n    this.name = \"DivaParentElementNotFoundException\";\n    this.message = message;\n    this.stack = (new Error()).stack;\n}\n\nDivaParentElementNotFoundException.prototype = new Error();\n\nexport function NotAnIIIFManifestException (message: string)\n{\n    this.name = \"NotAnIIIFManifestException\";\n    this.message = message;\n    this.stack = (new Error()).stack;\n}\n\nNotAnIIIFManifestException.prototype = new Error();\n\nexport function ObjectDataNotSuppliedException (message: string)\n{\n    this.name = \"ObjectDataNotSuppliedException\";\n    this.message = message;\n    this.stack = (new Error()).stack;\n}\n\nObjectDataNotSuppliedException.prototype = new Error();\n","import {Offset, PageXYPos} from \"./viewer-type-definitions\";\n\nexport default {\n    onDoubleClick,\n    onPinch,\n    onDoubleTap\n};\n\nconst DOUBLE_CLICK_TIMEOUT = 500;\nconst DOUBLE_TAP_DISTANCE_THRESHOLD = 50;\nconst DOUBLE_TAP_TIMEOUT = 250;\n\nfunction onDoubleClick(elem: HTMLElement, callback)\n{\n    elem.addEventListener('dblclick', function (event)\n    {\n        if (!event.ctrlKey)\n        {\n            callback(event, getRelativeOffset(event.currentTarget as HTMLElement, event));\n        }\n    });\n\n    // Handle the control key for macs (in conjunction with double-clicking)\n    // FIXME: Does a click get handled with ctrl pressed on non-Macs?\n    const tracker = createDoubleEventTracker(DOUBLE_CLICK_TIMEOUT);\n\n    elem.addEventListener('contextmenu', function (event)\n    {\n        event.preventDefault();\n\n        if (event.ctrlKey)\n        {\n            if (tracker.isTriggered())\n            {\n                tracker.reset();\n                callback(event, getRelativeOffset(event.currentTarget as HTMLElement, event));\n            }\n            else\n            {\n                tracker.trigger();\n            }\n        }\n    });\n}\n\nfunction onPinch(elem: HTMLElement, callback)\n{\n    let startDistance = 0;\n\n    elem.addEventListener('touchstart', function (event: TouchEvent)\n    {\n        // Prevent mouse event from firing\n        event.preventDefault();\n\n        if (event.touches.length === 2)\n        {\n            startDistance = distance(\n                event.touches[0].clientX,\n                event.touches[0].clientY,\n                event.touches[1].clientX,\n                event.touches[1].clientY\n            );\n        }\n    });\n\n    elem.addEventListener('touchmove', function(event: TouchEvent)\n    {\n        // Prevent mouse event from firing\n        event.preventDefault();\n\n        if (event.touches.length === 2)\n        {\n            const touches = event.touches;\n\n            const moveDistance = distance(\n                touches[0].clientX,\n                touches[0].clientY,\n                touches[1].clientX,\n                touches[1].clientY\n            );\n\n            const zoomDelta = moveDistance - startDistance;\n\n            if (Math.abs(zoomDelta) > 0)\n            {\n                const touchCenter = {\n                    pageX: (touches[0].clientX + touches[1].clientX) / 2,\n                    pageY: (touches[0].clientY + touches[1].clientY) / 2\n                };\n\n                callback(event, getRelativeOffset(event.currentTarget as HTMLElement, touchCenter), startDistance, moveDistance);\n            }\n        }\n    });\n}\n\nfunction onDoubleTap(elem: HTMLElement, callback)\n{\n    const tracker = createDoubleEventTracker(DOUBLE_TAP_TIMEOUT);\n    let firstTap: PageXYPos | null = null;\n\n    elem.addEventListener('touchend', (event) =>\n    {\n        // Prevent mouse event from firing\n        event.preventDefault();\n\n        if (tracker.isTriggered())\n        {\n            tracker.reset();\n\n            // Doubletap has occurred\n            const secondTap = {\n                pageX: event.changedTouches[0].clientX,\n                pageY: event.changedTouches[0].clientY\n            };\n\n            // If first tap is close to second tap (prevents interference with scale event)\n            const tapDistance = distance(firstTap.pageX, firstTap.pageY, secondTap.pageX, secondTap.pageY);\n\n            // TODO: Could give something higher-level than secondTap to callback\n            if (tapDistance < DOUBLE_TAP_DISTANCE_THRESHOLD)\n            {\n                callback(event, getRelativeOffset(event.currentTarget as HTMLElement, secondTap));\n            }\n\n            firstTap = null;\n        }\n        else\n        {\n            firstTap = {\n                pageX: event.changedTouches[0].clientX,\n                pageY: event.changedTouches[0].clientY\n            };\n\n            tracker.trigger();\n        }\n    });\n}\n\n// Pythagorean theorem to get the distance between two points (used for\n// calculating finger distance for double-tap and pinch-zoom)\nfunction distance(x1: number, y1: number, x2: number, y2: number): number\n{\n    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\n\n// Utility to keep track of whether an event has been triggered twice\n// during a a given duration\nfunction createDoubleEventTracker(timeoutDuration: number)\n{\n    let triggered = false;\n    let timeoutId: number | null = null;\n\n    return {\n        trigger()\n        {\n            triggered = true;\n            resetTimeout();\n            timeoutId = setTimeout(function ()\n            {\n                triggered = false;\n                timeoutId = null;\n            }, timeoutDuration);\n        },\n        isTriggered()\n        {\n            return triggered;\n        },\n        reset()\n        {\n            triggered = false;\n            resetTimeout();\n        }\n    };\n\n    function resetTimeout()\n    {\n        if (timeoutId !== null)\n        {\n            clearTimeout(timeoutId);\n            timeoutId = null;\n        }\n    }\n}\n\nfunction getRelativeOffset(elem: HTMLElement, pageCoords: MouseEvent): Offset\n{\n    const bounds = elem.getBoundingClientRect();\n\n    return {\n        left: pageCoords.pageX - bounds.left,\n        top: pageCoords.pageY - bounds.top\n    };\n}\n","import { maxBy } from './utils/maxby';\nimport ViewerCore from './viewer-core';\nimport {\n    Dimension,\n    LayoutGroupPage,\n    Offset,\n    PageGroup,\n    Region,\n    ViewportSize\n} from \"./viewer-type-definitions\";\nimport DocumentLayout from \"./document-layout\";\n\nexport default class GridHandler\n{\n    _viewerCore: ViewerCore;\n\n    constructor (viewerCore: ViewerCore)\n    {\n        this._viewerCore = viewerCore;\n    }\n\n    // USER EVENTS\n    onDoubleClick (_event: MouseEvent, coords: Offset)\n    {\n        const position = this._viewerCore.getPagePositionAtViewportOffset(coords);\n\n        const layout = this._viewerCore.getCurrentLayout()!;\n        const viewport: ViewportSize = this._viewerCore.getViewport();\n        const pageToViewportCenterOffset = layout.getPageToViewportCenterOffset(position.anchorPage, viewport)!;\n\n        this._viewerCore.reload({\n            inGrid: false,\n            goDirectlyTo: position.anchorPage,\n            horizontalOffset: pageToViewportCenterOffset.x + position.offset.left,\n            verticalOffset: pageToViewportCenterOffset.y + position.offset.top\n        });\n    }\n\n    onPinch ()\n    {\n        this._viewerCore.reload({inGrid: false});\n    }\n\n    // VIEW EVENTS\n    onViewWillLoad ()\n    {\n        // FIXME(wabain): Should something happen here?\n        /* No-op */\n    }\n\n    onViewDidLoad ()\n    {\n        // FIXME(wabain): Should something happen here?\n        /* No-op */\n    }\n\n    onViewDidUpdate (renderedPages: number[], targetPage: number | null)\n    {\n        // return early if there are no rendered pages in view.\n        if (renderedPages.length === 0)\n        {\n            return;\n        }\n\n        // calculate the visible pages from the rendered pages\n        let temp = this._viewerCore.viewerState.viewport.intersectionTolerance;\n        // without setting to 0, isPageVisible returns true for pages out of viewport by intersectionTolerance\n        this._viewerCore.viewerState.viewport.intersectionTolerance = 0;\n        let visiblePages = renderedPages.filter((index: number) => this._viewerCore.viewerState.renderer!.isPageVisible(index));\n        // reset back to original value after getting true visible pages\n        this._viewerCore.viewerState.viewport.intersectionTolerance = temp;\n\n        if (targetPage !== null)\n        {\n            this._viewerCore.setCurrentPages(targetPage, visiblePages);\n            return;\n        }\n\n        // Select the current page from the first row if it is fully visible, or from\n        // the second row if it is fully visible, or from the centermost row otherwise.\n        // If the current page is in that group then don't change it. Otherwise, set\n        // the current page to the group's first page.\n\n        const layout: DocumentLayout = this._viewerCore.getCurrentLayout()!;\n        const groups: PageGroup[] = [];\n\n        renderedPages.forEach((pageIndex: number) =>\n        {\n            const group: PageGroup = layout.getPageInfo(pageIndex)!.group;\n            if (groups.length === 0 || group !== groups[groups.length - 1])\n            {\n                groups.push(group);\n            }\n        });\n\n        const viewport = this._viewerCore.getViewport();\n        let chosenGroup;\n\n        if (groups.length === 1 || groups[0].region.top >= viewport.top)\n        {\n            chosenGroup = groups[0];\n        }\n        else if (groups[1].region.bottom <= viewport.bottom)\n        {\n            chosenGroup = groups[1];\n        }\n        else\n        {\n            chosenGroup = getCentermostGroup(groups, viewport);\n        }\n\n        const currentPage = this._viewerCore.getSettings().activePageIndex;\n\n        const hasCurrentPage = chosenGroup.pages.some((page: LayoutGroupPage) => page.index === currentPage);\n\n        if (!hasCurrentPage)\n        {\n            this._viewerCore.setCurrentPages(chosenGroup.pages[0].index, visiblePages);\n        }\n    }\n\n    destroy ()\n    {\n        // No-op\n    }\n}\n\nfunction getCentermostGroup (groups: any[] | null, viewport: Region & Dimension)\n{\n    const viewportMiddle = viewport.top + viewport.height / 2;\n\n    return maxBy(groups, group =>\n    {\n        const groupMiddle = group.region.top + group.dimensions.height / 2;\n        return -Math.abs(viewportMiddle - groupMiddle);\n    });\n}\n","import {DivaTiledRequestParams, OptionalDimension} from \"./viewer-type-definitions\";\nimport ImageManifest from \"./image-manifest\";\n\nexport default class IIIFSourceAdapter\n{\n    getPageImageURL (manifest: ImageManifest, pageIndex: number, size?: OptionalDimension): string\n    {\n        let dimens;\n\n        if (!size || (size.width == null && size.height == null))\n        {\n            dimens = 'full';\n        }\n        else\n        {\n            dimens = (size.width == null ? '' : size.width) + ',' + (size.height == null ? '' : size.height);\n        }\n\n        const page = manifest.pages[pageIndex];\n        const quality = (page.api > 1.1) ? 'default' : 'native';\n\n        return encodeURI(page.url + 'full/' + dimens + '/0/' + quality + '.jpg');\n    }\n\n    getTileImageURL (manifest: any, pageIndex: number, params: DivaTiledRequestParams): string\n    {\n        const page = manifest.pages[pageIndex];\n\n        let height: number, width: number;\n\n        if (params.row === params.rowCount - 1)\n        {\n            height = page.d[params.zoomLevel].h - (params.rowCount - 1) * params.tileDimensions.height;\n        }\n        else\n        {\n            height = params.tileDimensions.height;\n        }\n\n        if (params.col === params.colCount - 1)\n        {\n            width = page.d[params.zoomLevel].w - (params.colCount - 1) * params.tileDimensions.width;\n        }\n        else\n        {\n            width = params.tileDimensions.width;\n        }\n\n        const zoomDifference: number = Math.pow(2, manifest.maxZoom - params.zoomLevel);\n\n        let x = params.col * params.tileDimensions.width * zoomDifference;\n        let y = params.row * params.tileDimensions.height * zoomDifference;\n\n        if (page.hasOwnProperty('xoffset'))\n        {\n            x += page.xoffset;\n            y += page.yoffset;\n        }\n\n        const region = [x, y, width * zoomDifference, height * zoomDifference].join(',');\n\n        const quality = (page.api > 1.1) ? 'default' : 'native';\n\n        return encodeURI(page.url + region + '/' + width + ',' + height + '/0/' + quality + '.jpg');\n    }\n}\n","const debug = require('debug')('diva:ImageCache');\n\n/* FIXME(wabain): The caching strategy here is completely\n * arbitrary and the implementation isn't especially efficient.\n */\nconst DEFAULT_MAX_KEYS = 100;\n\nexport default class ImageCache\n{\n    maxKeys: number;\n    _held: Record<string, any>;\n    _urls: Record<string, any>;\n    _lru: any[];\n\n    constructor (options?: any)\n    {\n        options = options || { maxKeys: DEFAULT_MAX_KEYS };\n        this.maxKeys = options.maxKeys || DEFAULT_MAX_KEYS;\n\n        this._held = {};\n        this._urls = {};\n        this._lru = [];\n    }\n\n    get (url: string)\n    {\n        const record = this._urls[url];\n        return record ? record.img : null;\n    }\n\n    has (url: string)\n    {\n        return !!this._urls[url];\n    }\n\n    put (url: string, img: any)\n    {\n        let record = this._urls[url];\n        if (record)\n        {\n            // FIXME: Does this make sense for this use case?\n            record.img = img;\n            this._promote(record);\n        }\n        else\n        {\n            record = {\n                img: img,\n                url: url\n            };\n\n            this._urls[url] = record;\n            this._tryEvict(1);\n            this._lru.unshift(record);\n        }\n    }\n\n    _promote (record: any)\n    {\n        const index = this._lru.indexOf(record);\n        this._lru.splice(index, 1);\n        this._lru.unshift(record);\n    }\n\n    _tryEvict (extraCapacity: number)\n    {\n        const allowedEntryCount = this.maxKeys - extraCapacity;\n\n        if (this._lru.length <= allowedEntryCount)\n        {\n            return;\n        }\n\n        let evictionIndex = this._lru.length - 1;\n\n        for (;;)\n        {\n            const target = this._lru[evictionIndex];\n\n            if (!this._held[target.url])\n            {\n                debug('Evicting image %s', target.url);\n                this._lru.splice(evictionIndex, 1);\n                delete this._urls[target.url];\n\n                if (this._lru.length <= allowedEntryCount)\n                    break;\n            }\n\n            if (evictionIndex === 0)\n            {\n                /* istanbul ignore next */\n                debug.enabled && debug('Cache overfull by %s (all entries are being held)',\n                    this._lru.length - allowedEntryCount);\n\n                break;\n            }\n\n            evictionIndex--;\n        }\n    }\n\n    acquire (url: string)\n    {\n        this._held[url] = (this._held[url] || 0) + 1;\n        this._promote(this._urls[url]);\n    }\n\n    release (url: string)\n    {\n        const count = this._held[url];\n\n        if (count > 1)\n        {\n            this._held[url]--;\n        }\n        else\n        {\n            delete this._held[url];\n        }\n\n        this._tryEvict(0);\n    }\n}\n","import parseIIIFManifest from './parse-iiif-manifest';\nimport IIIFSourceAdapter from \"./iiif-source-adapter\";\nimport {\n    Dimension,\n    DivaServiceBlock,\n    DivaTiledPage,\n    DivaTileSource,\n    HWDimension,\n    OptionalDimension\n} from \"./viewer-type-definitions\";\n\n\nexport default class ImageManifest\n{\n    pages: any[];\n    maxZoom: number;\n    maxRatio: number;\n    minRatio: number;\n    itemTitle: string;\n    metadata: object;\n    paged: boolean;\n    _maxWidths: number[];\n    _maxHeights: number[];\n    _averageWidths: number[];\n    _averageHeights: number[];\n    _totalHeights: number[];\n    _totalWidths: number[];\n    _urlAdapter: IIIFSourceAdapter;\n\n    constructor (data: DivaServiceBlock, urlAdapter: IIIFSourceAdapter)\n    {\n        // Save all the data we need\n        this.pages = data.pgs;\n        this.maxZoom = data.max_zoom;\n        this.maxRatio = data.dims.max_ratio;\n        this.minRatio = data.dims.min_ratio;\n        this.itemTitle = data.item_title;\n        this.metadata = data.metadata;\n\n        // Only given for IIIF manifests\n        this.paged = data.paged;\n\n        // These are arrays, the index corresponding to the zoom level\n        this._maxWidths = data.dims.max_w;\n        this._maxHeights = data.dims.max_h;\n        this._averageWidths = data.dims.a_wid;\n        this._averageHeights = data.dims.a_hei;\n        this._totalHeights = data.dims.t_hei;\n        this._totalWidths = data.dims.t_wid;\n\n        this._urlAdapter = urlAdapter;\n    }\n\n    static fromIIIF (iiifManifest: object): ImageManifest\n    {\n        const data: DivaServiceBlock = parseIIIFManifest(iiifManifest)!;\n        return new ImageManifest(data, new IIIFSourceAdapter());\n    }\n\n    isPageValid (pageIndex: number, showNonPagedPages: boolean): boolean\n    {\n        if (!showNonPagedPages && this.paged && !this.pages[pageIndex].paged)\n        {\n            return false;\n        }\n\n        return pageIndex >= 0 && pageIndex < this.pages.length;\n    }\n\n    getMaxPageDimensions (pageIndex: number): Dimension\n    {\n        const maxDims: HWDimension = this.pages[pageIndex].d[this.maxZoom];\n\n        return {\n            height: maxDims.h,\n            width: maxDims.w\n        };\n    }\n\n    getPageDimensionsAtZoomLevel (pageIndex: number, zoomLevel: number): Dimension\n    {\n        const maxDims: HWDimension = this.pages[pageIndex].d[this.maxZoom];\n\n        const scaleRatio: number = getScaleRatio(this.maxZoom, zoomLevel);\n\n        return {\n            height: maxDims.h * scaleRatio,\n            width: maxDims.w * scaleRatio\n        };\n    }\n\n    /**\n     * Returns a URL for the image of the given page. The optional size\n     * parameter supports setting the image width or height (default is\n     * full-sized).\n     */\n    getPageImageURL (pageIndex: number, size: OptionalDimension): string\n    {\n        return this._urlAdapter.getPageImageURL(this, pageIndex, size);\n    }\n\n    /**\n     * Return an array of tile objects for the specified page and integer zoom level\n     */\n    getPageImageTiles (pageIndex: number, zoomLevel: number, tileDimensions: Dimension): DivaTiledPage\n    {\n        const page = this.pages[pageIndex];\n\n        if (!isFinite(zoomLevel) || zoomLevel % 1 !== 0)\n        {\n            throw new TypeError('Zoom level must be an integer: ' + zoomLevel);\n        }\n\n        const rows = Math.ceil(page.d[zoomLevel].h / tileDimensions.height);\n        const cols = Math.ceil(page.d[zoomLevel].w / tileDimensions.width);\n\n        const tiles: DivaTileSource[] = [];\n\n        let row, col, url;\n\n        for (row = 0; row < rows; row++)\n        {\n            for (col = 0; col < cols; col++)\n            {\n                url = this._urlAdapter.getTileImageURL(this, pageIndex, {\n                    row: row,\n                    col: col,\n                    rowCount: rows,\n                    colCount: cols,\n                    zoomLevel: zoomLevel,\n                    tileDimensions: tileDimensions\n                });\n\n                // FIXME: Dimensions should account for partial tiles (e.g. the\n                // last row and column in a tiled image)\n                tiles.push({\n                    row: row,\n                    col: col,\n                    zoomLevel: zoomLevel,\n                    dimensions: {\n                        height: tileDimensions.height,\n                        width: tileDimensions.width\n                    },\n                    offset: {\n                        top: row * tileDimensions.height,\n                        left: col * tileDimensions.width\n                    },\n                    url: url\n                });\n            }\n        }\n\n        return {\n            zoomLevel: zoomLevel,\n            rows: rows,\n            cols: cols,\n            tiles: tiles\n        };\n    }\n\n    getAverageWidth (zoomLevel: number): number\n    {\n        return this._averageWidths[zoomLevel]\n    }\n\n    getAverageHeight (zoomLevel: number): number\n    {\n        return this._averageHeights[zoomLevel]\n    }\n\n    getMaxWidth (zoomLevel: number): number\n    {\n        return this._maxWidths[zoomLevel]\n    }\n\n    getMaxHeight (zoomLevel: number): number\n    {\n        return this._maxHeights[zoomLevel]\n    }\n\n    getTotalWidth (zoomLevel: number): number\n    {\n        return this._totalWidths[zoomLevel]\n    }\n\n    getTotalHeight (zoomLevel: number): number\n    {\n        return this._totalHeights[zoomLevel]\n    }\n}\n\nfunction getScaleRatio (sourceZoomLevel: number, targetZoomLevel: number): number\n{\n    return 1 / Math.pow(2, sourceZoomLevel - targetZoomLevel);\n}\n","import {ImageRequestOptions} from \"./options-settings\";\n\n/**\n * Handler for the request for an image tile\n *\n * @param url\n * @param callback\n * @constructor\n */\nexport default class ImageRequestHandler\n{\n    _image: HTMLImageElement;\n    _callback: any;\n    _errorCallback: any;\n    timeout: any;\n    timeoutTime: any;\n    _aborted: any;\n    _crossOrigin: any;\n    _url: string;\n    _complete: any;\n\n    constructor (options: ImageRequestOptions)\n    {\n        this._url = options.url;\n        this._callback = options.load;\n        this._errorCallback = options.error;\n        this.timeoutTime = options.timeoutTime || 0;\n        this._aborted = this._complete = false;\n        this._crossOrigin = options.settings.imageCrossOrigin;\n\n        //Use a timeout to allow the requests to be debounced (as they are in renderer)\n        this.timeout = setTimeout(() => {\n            // Initiate the request\n            this._image = new Image();\n            this._image.crossOrigin = this._crossOrigin;\n            this._image.onload = this._handleLoad.bind(this);\n            this._image.onerror = this._handleError.bind(this);\n            this._image.src = options.url;\n\n        }, this.timeoutTime);\n    }\n\n    abort ()\n    {\n        clearTimeout(this.timeout);\n\n        // FIXME\n        // People on the Internet say that doing this {{should/should not}} abort the request. I believe\n        // it corresponds to what the WHATWG HTML spec says should happen when the UA\n        // updates the image data if selected source is null.\n        //\n        // Sources:\n        //\n        // https://html.spec.whatwg.org/multipage/embedded-content.html#the-img-element\n        // http://stackoverflow.com/questions/7390888/does-changing-the-src-attribute-of-an-image-stop-the-image-from-downloading\n        if (this._image)\n        {\n            this._image.onload = this._image.onerror = null;\n\n            this._image.src = '';\n        }\n\n        this._aborted = true;\n    }\n\n    _handleLoad ()\n    {\n        if (this._aborted)\n        {\n            console.error('ImageRequestHandler invoked on cancelled request for ' + this._url);\n            return;\n        }\n\n        if (this._complete)\n        {\n            console.error('ImageRequestHandler invoked on completed request for ' + this._url);\n            return;\n        }\n\n        this._complete = true;\n        this._callback(this._image);\n    }\n\n    _handleError ()\n    {\n        this._errorCallback(this._image);\n    }\n}\n","// TODO: requestAnimationFrame fallback\n\nexport default {\n    animate,\n    easing: {\n        linear: linearEasing,\n        cubic: inOutCubicEasing\n    }\n};\n\nlet now: (() => number) = (): number => { return performance.now(); };\n\n\nfunction animate (options)\n{\n    const durationMs = options.duration;\n    const parameters = options.parameters;\n    const onUpdate = options.onUpdate;\n    const onEnd = options.onEnd;\n\n    // Setup\n    // Times are in milliseconds from a basically arbitrary start\n    const start = now();\n    const end = start + durationMs;\n\n    const tweenFns = {};\n    const values = {};\n    const paramKeys = Object.keys(parameters);\n\n    paramKeys.forEach(key => {\n        const config = parameters[key];\n        tweenFns[key] = interpolate(config.from, config.to, config.easing || inOutCubicEasing);\n    });\n\n    // Run it!\n    let requestId = requestAnimationFrame(update);\n\n    return {\n        cancel()\n        {\n            if (requestId !== null)\n            {\n                cancelAnimationFrame(requestId);\n                handleAnimationCompletion({\n                    interrupted: true\n                });\n            }\n        }\n    };\n\n    function update()\n    {\n        const current = now();\n        const elapsed = Math.min((current - start) / durationMs, 1);\n\n        updateValues(elapsed);\n        onUpdate(values);\n\n        if (current < end)\n        {\n            requestId = requestAnimationFrame(update);\n        }\n        else\n        {\n            handleAnimationCompletion({\n                interrupted: false\n            });\n        }\n    }\n\n    function updateValues(elapsed)\n    {\n        paramKeys.forEach(key => {\n            values[key] = tweenFns[key](elapsed);\n        });\n    }\n\n    function handleAnimationCompletion(info)\n    {\n        requestId = null;\n\n        if (onEnd)\n        {\n            onEnd(info);\n        }\n    }\n}\n\nfunction interpolate(start, end, easing)\n{\n    return (elapsed) => { return start + (end - start) * easing(elapsed); };\n}\n\n/**\n * Easing functions. inOutCubicEasing is the default, but\n * others are given for convenience.\n *\n **/\nfunction linearEasing(e)\n{\n    return e;\n}\n\n/* jshint ignore:start */\nfunction inOutQuadEasing (e)\n{\n    return e < .5 ? 2 * e * e : -1+(4-2 * e) * e\n}\n/* jshint ignore:end */\n\n\nfunction inOutCubicEasing (t)\n{\n    return t < 0.5 ? 4 * t * t * t : ( t - 1 ) * ( 2 * t - 2 ) * ( 2 * t - 2 ) + 1;\n}\n","import getPageDimensions from './page-dimensions';\nimport {LayoutGroupSettings} from \"../options-settings\";\nimport {BookLayoutPage, DivaPage, LayoutGroupPages} from \"../viewer-type-definitions\";\n\nexport default function getBookLayoutGroups (viewerConfig: LayoutGroupSettings): LayoutGroupPages[]\n{\n    const groupings = getGroupings(viewerConfig);\n\n    return groupings.map(grouping => getGroupLayoutsFromPageGrouping(viewerConfig, grouping));\n}\n\nfunction getGroupings(viewerConfig: LayoutGroupSettings)\n{\n    const manifest = viewerConfig.manifest;\n\n    const pagesByGroup: any[] = [];\n    let leftPage: BookLayoutPage | null = null;\n    let nonPagedPages: BookLayoutPage[] = []; // Pages to display below the current group\n\n    const _addNonPagedPages = () =>\n    {\n        for (let i = 0, nlen = nonPagedPages.length; i < nlen; i++)\n        {\n            pagesByGroup.push([ nonPagedPages[i] ]);\n        }\n        nonPagedPages = [];\n    };\n\n    manifest.pages.forEach( (page: DivaPage, index: number) =>\n    {\n        const pageRecord: BookLayoutPage = {\n            index: index,\n            dimensions: getPageDimensions(index, manifest),\n            paged: (!manifest.paged || page.paged)\n        };\n\n        // Only display non-paged pages if specified in the settings\n        if (!viewerConfig.showNonPagedPages && !pageRecord.paged)\n        {\n            return;\n        }\n\n        if (!pageRecord.paged)\n        {\n            nonPagedPages.push(pageRecord);\n        }\n        else if (index === 0 || page.facingPages)\n        {\n            // The first page is placed on its own\n            pagesByGroup.push([pageRecord]);\n            _addNonPagedPages();\n        }\n        else if (leftPage === null)\n        {\n            leftPage = pageRecord;\n        }\n        else\n        {\n            pagesByGroup.push([leftPage, pageRecord]);\n            leftPage = null;\n            _addNonPagedPages();\n        }\n    });\n\n    // Flush a final left page\n    if (leftPage !== null)\n    {\n        pagesByGroup.push([leftPage]);\n        _addNonPagedPages();\n    }\n\n    return pagesByGroup;\n}\n\nfunction getGroupLayoutsFromPageGrouping(viewerConfig: LayoutGroupSettings, grouping: string | any[]): LayoutGroupPages\n{\n    const verticallyOriented = viewerConfig.verticallyOriented;\n\n    if (grouping.length === 2)\n    {\n        return getFacingPageGroup(grouping[0], grouping[1], verticallyOriented);\n    }\n\n    const page = grouping[0];\n    const pageDims = page.dimensions;\n\n    // The first page is placed on its own to the right in vertical orientation.\n    // NB that this needs to be the page with index 0; if the first page is excluded\n    // from the layout then this special case shouldn't apply.\n    // If the page is tagged as 'non-paged', center it horizontally\n    let leftOffset;\n    if (page.paged)\n    {\n        leftOffset = (page.index === 0 && verticallyOriented) ? pageDims.width : 0;\n    }\n    else\n    {\n        leftOffset = (verticallyOriented) ? pageDims.width / 2 : 0;\n    }\n\n    const shouldBeHorizontallyAdjusted =\n        verticallyOriented && !viewerConfig.manifest.pages[page.index].facingPages;\n\n    // We need to left-align the page in vertical orientation, so we double\n    // the group width\n    return {\n        dimensions: {\n            height: pageDims.height,\n            width: shouldBeHorizontallyAdjusted ? pageDims.width * 2 : pageDims.width\n        },\n        pages: [{\n            index: page.index,\n            groupOffset: {\n                top: 0,\n                left: leftOffset\n            },\n            dimensions: pageDims\n        }]\n    };\n}\n\nfunction getFacingPageGroup(leftPage: { dimensions: any; index: any; }, rightPage: {\n    dimensions: any;\n    index: any;\n}, verticallyOriented: any): LayoutGroupPages\n{\n    const leftDims = leftPage.dimensions;\n    const rightDims = rightPage.dimensions;\n\n    const height = Math.max(leftDims.height, rightDims.height);\n\n    let width, firstLeftOffset, secondLeftOffset;\n\n    if (verticallyOriented)\n    {\n        const midWidth = Math.max(leftDims.width, rightDims.width);\n\n        width = midWidth * 2;\n\n        firstLeftOffset = midWidth - leftDims.width;\n        secondLeftOffset = midWidth;\n    }\n    else\n    {\n        width = leftDims.width + rightDims.width;\n        firstLeftOffset = 0;\n        secondLeftOffset = leftDims.width;\n    }\n\n    return {\n        dimensions: {\n            height: height,\n            width: width\n        },\n        pages: [\n            {\n                index: leftPage.index,\n                dimensions: leftDims,\n                groupOffset: {\n                    top: 0,\n                    left: firstLeftOffset\n                }\n            },\n            {\n                index: rightPage.index,\n                dimensions: rightDims,\n                groupOffset: {\n                    top: 0,\n                    left: secondLeftOffset\n                }\n            }\n        ]\n    };\n}\n","import {LayoutGroupSettings} from \"../options-settings\";\nimport {Dimension, DivaPage, LayoutGroupPage, LayoutGroupPages} from \"../viewer-type-definitions\";\n\nexport default function getGridLayoutGroups (viewerConfig: LayoutGroupSettings): LayoutGroupPages[]\n{\n    const viewportWidth = viewerConfig.viewport.width;\n    const manifest = viewerConfig.manifest;\n    const pagesPerRow = viewerConfig.pagesPerRow!;\n    const fixedHeightGrid = viewerConfig.fixedHeightGrid;\n    const fixedPadding = viewerConfig.fixedPadding!;\n    const showNonPagedPages = viewerConfig.showNonPagedPages;\n\n    const horizontalPadding = fixedPadding * (pagesPerRow + 1);\n    const pageWidth = (viewportWidth - horizontalPadding) / pagesPerRow;\n    const gridPageWidth = pageWidth;\n\n    // Calculate the row height depending on whether we want to fix the width or the height\n    const rowHeight = (fixedHeightGrid) ? fixedPadding + manifest.minRatio * pageWidth : fixedPadding + manifest.maxRatio * pageWidth;\n\n    const groups = [];\n    let currentPages: LayoutGroupPage[] = [];\n\n    const getGridPageDimensions: ((pageData: DivaPage) => Dimension) = (pageData: DivaPage): Dimension =>\n    {\n        // Calculate the width, height and horizontal placement of this page\n        // Get dimensions at max zoom level, although any level should be fine\n        const pageDimenData = pageData.d[pageData.d.length - 1]!;\n        const heightToWidthRatio = pageDimenData.h / pageDimenData.w;\n\n        let pageWidth, pageHeight;\n\n        if (fixedHeightGrid)\n        {\n            pageWidth = (rowHeight - fixedPadding) / heightToWidthRatio;\n            pageHeight = rowHeight - fixedPadding;\n        }\n        else\n        {\n            pageWidth = gridPageWidth;\n            pageHeight = pageWidth * heightToWidthRatio;\n        }\n\n        return {\n            width: Math.round(pageWidth),\n            height: Math.round(pageHeight)\n        };\n    };\n\n    const rowDimensions = {\n        height: rowHeight,\n        width: viewportWidth\n    };\n\n    manifest.pages.forEach( (page: DivaPage, pageIndex: number) =>\n    {\n        if (!showNonPagedPages && manifest.paged && !page.paged)\n        {\n            return;\n        }\n\n        // Calculate the width, height and horizontal placement of this page\n        const pageDimens = getGridPageDimensions(page);\n        let leftOffset = Math.floor(currentPages.length * (fixedPadding + gridPageWidth) + fixedPadding);\n\n        // Center the page if the height is fixed (otherwise, there is no horizontal padding)\n        if (fixedHeightGrid)\n        {\n            leftOffset += (gridPageWidth - pageDimens.width) / 2;\n        }\n\n        // TODO: Precompute page dimensions everywhere\n        currentPages.push({\n            index: pageIndex,\n            dimensions: pageDimens,\n            groupOffset: {\n                top: 0,\n                left: leftOffset\n            }\n        });\n\n        if (currentPages.length === pagesPerRow)\n        {\n            groups.push({\n                dimensions: rowDimensions,\n                pages: currentPages\n            });\n\n            currentPages = [];\n        }\n    });\n\n    if (currentPages.length > 0)\n    {\n        groups.push({\n            dimensions: rowDimensions,\n            pages: currentPages\n        });\n    }\n\n    return groups;\n}\n","import getBookLayoutGroups from './book-layout';\nimport getSinglesLayoutGroups from './singles-layout';\nimport getGridLayoutGroups from './grid-layout';\nimport {LayoutGroupSettings, MergedConfiguration} from \"../options-settings\";\nimport {LayoutGroupPages} from \"../viewer-type-definitions\";\n\n/** Get the relative positioning of pages for the current view */\nexport default function getPageLayouts (settings: MergedConfiguration): LayoutGroupPages[]\n{\n    if (settings.inGrid)\n    {\n        return getGridLayoutGroups(pluck(settings, [\n            'manifest',\n            'viewport',\n            'pagesPerRow',\n            'fixedHeightGrid',\n            'fixedPadding',\n            'showNonPagedPages'\n        ]));\n    }\n    else\n    {\n        const config: LayoutGroupSettings = pluck(settings, ['manifest', 'verticallyOriented', 'showNonPagedPages']);\n\n        if (settings.inBookLayout)\n        {\n            return getBookLayoutGroups(config);\n        }\n        else\n        {\n            return getSinglesLayoutGroups(config);\n        }\n    }\n}\n\nfunction pluck (obj: MergedConfiguration, keys: string[]): LayoutGroupSettings\n{\n    const out: LayoutGroupSettings = {};\n    keys.forEach(function (key)\n    {\n        out[key] = obj[key];\n    });\n    return out;\n}\n","import {Dimension} from \"../viewer-type-definitions\";\nimport ImageManifest from \"../image-manifest\";\n\nexport default function getPageDimensions (pageIndex: number, manifest: ImageManifest): Dimension\n{\n    const dims = manifest.getMaxPageDimensions(pageIndex);\n\n    return {\n        width: Math.floor(dims.width),\n        height: Math.floor(dims.height)\n    };\n}\n","import getPageDimensions from './page-dimensions';\nimport {LayoutGroupSettings} from \"../options-settings\";\nimport {Dimension, DivaPage, LayoutGroupPages} from \"../viewer-type-definitions\";\n\nexport default function getSinglesLayoutGroups (viewerConfig: LayoutGroupSettings): LayoutGroupPages[]\n{\n    const manifest = viewerConfig.manifest;\n\n    // Render each page alone in a group\n    const pages: LayoutGroupPages[] = [];\n    manifest.pages.forEach( (page: DivaPage, index: number) =>\n    {\n        if (!viewerConfig.showNonPagedPages && manifest.paged && !page.paged)\n        {\n            return;\n        }\n\n        const pageDims: Dimension = getPageDimensions(index, manifest);\n\n        pages.push({\n            dimensions: pageDims,\n            pages: [{\n                index: index,\n                groupOffset: { top: 0, left: 0 },\n                dimensions: pageDims\n            }]\n        });\n    });\n\n    return pages;\n}\n","/**\n * Manages a collection of page overlays, which implement a low-level\n * API for synchronizing HTML pages to the canvas. Each overlay needs\n * to implement the following protocol:\n *\n *   mount(): Called when a page is first rendered\n *   refresh(): Called when a page is moved\n *   unmount(): Called when a previously rendered page has stopped being rendered\n *\n * @class\n */\nimport PageToolsOverlay from \"./page-tools-overlay\";\n\nexport default class PageOverlayManager\n{\n    _pages: Record<number, any[]>;\n    _renderedPages: any[];\n    _renderedPageMap: Record<number, any>;\n\n    constructor ()\n    {\n        this._pages = {};\n        this._renderedPages = [];\n        this._renderedPageMap = {};\n    }\n\n    addOverlay (overlay: PageToolsOverlay)\n    {\n        const overlaysByPage = this._pages[overlay.page] || (this._pages[overlay.page] = []);\n\n        overlaysByPage.push(overlay);\n\n        if (this._renderedPageMap[overlay.page])\n        {\n            overlay.mount();\n        }\n    }\n\n    removeOverlay (overlay: PageToolsOverlay)\n    {\n        const page = overlay.page;\n        const overlaysByPage = this._pages[page];\n\n        if (!overlaysByPage)\n        {\n            return;\n        }\n\n        const overlayIndex = overlaysByPage.indexOf(overlay);\n\n        if (overlayIndex === -1)\n        {\n            return;\n        }\n\n        if (this._renderedPageMap[page])\n        {\n            overlaysByPage[overlayIndex].unmount();\n        }\n\n        overlaysByPage.splice(overlayIndex, 1);\n\n        if (overlaysByPage.length === 0)\n        {\n            delete this._pages[page];\n        }\n    }\n\n    updateOverlays (renderedPages: number[])\n    {\n        const previouslyRendered = this._renderedPages;\n        const newRenderedMap: Record<number, boolean> = {};\n\n        renderedPages.map( (pageIndex: number) =>\n        {\n            newRenderedMap[pageIndex] = true;\n\n            if (!this._renderedPageMap[pageIndex])\n            {\n                this._renderedPageMap[pageIndex] = true;\n\n                this._invokeOnOverlays(pageIndex, (overlay: PageToolsOverlay) =>\n                {\n                    overlay.mount();\n                });\n            }\n        });\n\n        previouslyRendered.map( (pageIndex) =>\n        {\n            if (newRenderedMap[pageIndex])\n            {\n                this._invokeOnOverlays(pageIndex, (overlay: PageToolsOverlay) =>\n                {\n                    overlay.refresh();\n                });\n            }\n            else\n            {\n                delete this._renderedPageMap[pageIndex];\n                this._invokeOnOverlays(pageIndex, (overlay: PageToolsOverlay) =>\n                {\n                    overlay.unmount();\n                });\n            }\n        });\n\n        this._renderedPages = renderedPages;\n    }\n\n    _invokeOnOverlays (pageIndex: number, func)\n    {\n        const overlays = this._pages[pageIndex];\n        if (overlays)\n        {\n            overlays.map((o) => func(o));\n        }\n    }\n}\n","import { elt } from './utils/elt';\nimport ViewerCore from \"./viewer-core\";\nimport {Region} from \"./viewer-type-definitions\";\n/**\n*\n*\n**/\nexport default class PageToolsOverlay\n{\n    page: number;\n    _viewerCore: ViewerCore;\n    _innerElement: HTMLElement | null;\n    _pageToolsElem: HTMLElement | null;\n    _pageLabelsElem: HTMLElement;\n    labelWidth: number;\n    _buttons: HTMLElement[];\n\n    constructor (pageIndex: number, viewerCore: ViewerCore)\n    {\n        this.page = pageIndex;\n\n        this._viewerCore = viewerCore;\n\n        this._innerElement = this._viewerCore.getSettings().innerElement;\n        this._pageToolsElem = null;\n        this.labelWidth = 0;\n    }\n\n    mount ()\n    {\n        if (this._pageToolsElem === null)\n        {\n            this._buttons = this._initializePageToolButtons();\n\n            this._pageToolsElem = elt('div', { class: 'diva-page-tools-wrapper' },\n                elt('div', { class: 'diva-page-tools' }, this._buttons)\n            );\n\n            this._pageLabelsElem = elt('div', { class: 'diva-page-labels-wrapper'},\n                elt('div', { class: 'diva-page-labels' }, this._viewerCore.settings.manifest!.pages[this.page].l)\n            );\n        }\n\n        this.refresh();\n        this._innerElement!.appendChild(this._pageToolsElem);\n        this._innerElement!.appendChild(this._pageLabelsElem);\n    }\n\n    _initializePageToolButtons (): HTMLElement[]\n    {\n        // Callback parameters\n        const settings = this._viewerCore.getSettings();\n        const publicInstance = this._viewerCore.getPublicInstance();\n        const pageIndex = this.page;\n\n        return this._viewerCore.getPageTools().map( (plugin) =>\n        {\n            // !!! The node needs to be cloned otherwise it is detached from\n            //  one and reattached to the other.\n            const button = plugin.pageToolsIcon.cloneNode(true);\n\n            // ensure the plugin instance is handed as the first argument to call;\n            // this will set the context (i.e., `this`) of the handleClick call to the plugin instance\n            // itself.\n            button.addEventListener('click', (event: MouseEvent) =>\n            {\n                plugin.handleClick.call(plugin, event, settings, publicInstance, pageIndex);\n            }, false);\n\n            button.addEventListener('touchend', (event: TouchEvent) =>\n            {\n                // Prevent firing of emulated mouse events\n                event.preventDefault();\n\n                plugin.handleClick.call(plugin, event, settings, publicInstance, pageIndex);\n            }, false);\n\n            return button;\n\n        });\n    }\n\n    unmount ()\n    {\n        this._innerElement!.removeChild(this._pageToolsElem!);\n        this._innerElement!.removeChild(this._pageLabelsElem);\n    }\n\n    refresh ()\n    {\n        const pos: Region | null = this._viewerCore.getPageRegion(this.page, {\n            includePadding: true,\n            incorporateViewport: true\n        });\n\n        // if window is resized larger, a margin is created - need to subtract this from offsets\n        let marginLeft = window.getComputedStyle(this._innerElement!, null).getPropertyValue('margin-left');\n\n        this._pageToolsElem!.style.top = `${pos!.top}px`;\n        this._pageToolsElem!.style.left = `${pos!.left - parseInt(marginLeft)}px`;\n\n        this._pageLabelsElem.style.top = `${pos!.top}px`;\n        this._pageLabelsElem.style.left = `${pos!.right - parseInt(marginLeft) - this.labelWidth - 5}px`;\n    }\n}\n","import parseLabelValue from './utils/parse-label-value';\nimport {\n    DivaDimensionMeasurements,\n    DivaImageInfo,\n    DivaPage, DivaSecondaryPage,\n    DivaServiceBlock, HWDimension\n} from \"./viewer-type-definitions\";\n\nconst getMaxZoomLevel: (width: number, height: number) => number = (width: number, height: number): number =>\n{\n    const largestDimension: number = Math.max(width, height);\n    if (largestDimension < 128)\n    {\n        return 0;\n    }\n    return Math.ceil(Math.log((largestDimension + 1) / (256 + 1)) / Math.log(2));\n};\n\nconst incorporateZoom: (imageDimension: number, zoomDifference: number) => number = (imageDimension: number, zoomDifference: number) => imageDimension / (Math.pow(2, zoomDifference));\n\nconst getOtherImageData: (otherImages: any[], lowestMaxZoom: number) => {\n    f: string;\n    url: string;\n    il: string;\n    d: HWDimension[]\n}[] = (otherImages: any[], lowestMaxZoom: number): DivaSecondaryPage[] =>\n{\n    return otherImages.map( (itm) =>\n    {\n        const w: number = itm.width;\n        const h: number = itm.height;\n        const info: DivaImageInfo = parseImageInfo(itm);\n        const url: string = info.url.slice(-1) !== '/' ? info.url + '/' : info.url;  // append trailing slash to url if it's not there.\n\n        const dims: HWDimension[] = new Array(lowestMaxZoom + 1);\n        for (let j = 0; j < lowestMaxZoom + 1; j++)\n        {\n            dims[j] = {\n                h: Math.floor(incorporateZoom(h, lowestMaxZoom - j)),\n                w: Math.floor(incorporateZoom(w, lowestMaxZoom - j))\n            };\n        }\n\n        return {\n            f: info.url,\n            url: url,\n            il: itm.label || \"\",\n            d: dims\n        };\n    });\n};\n\nconst getIIIFPresentationVersion = (context: string | string[]): 2 | 3 =>\n{\n    if (context === \"http://iiif.io/api/presentation/2/context.json\")\n    {\n        return 2;\n    }\n    else if (Array.isArray(context) && context.includes(\"http://iiif.io/api/presentation/2/context.json\"))\n    {\n        return 2;\n    }\n    else if (Array.isArray(context) && context.includes(\"http://iiif.io/api/presentation/3/context.json\"))\n    {\n        return 3;\n    }\n    else\n    {\n        return 2; // Assume a v2 manifest.\n    }\n};\n\n/**\n * Parses an IIIF Presentation API Manifest and converts it into a Diva.js-format object\n * (See https://github.com/DDMAL/diva.js/wiki/Development-notes#data-received-through-ajax-request)\n *\n * @param {Object} manifest - an object that represents a valid IIIF manifest\n * @returns {Object} divaServiceBlock - the data needed by Diva to show a view of a single document\n */\nexport default function parseIIIFManifest (manifest: Record<string, any>): DivaServiceBlock | null\n{\n    let ctx = manifest[\"@context\"] || null;\n\n    if (!ctx)\n    {\n        console.error(\"Invalid IIIF Manifest; No @context found.\");\n        return null;\n    }\n\n    const version = getIIIFPresentationVersion(ctx);\n    const sequence = manifest.sequences ? manifest.sequences[0] : null;\n    const canvases = sequence ? sequence.canvases : manifest.items;\n    const numCanvases = canvases.length;\n\n    const pages: DivaPage[] = new Array(canvases.length);\n\n    let thisCanvas,\n        thisResource, \n        thisImage,\n        secondaryImages,\n        otherImages: DivaSecondaryPage[] = [],\n        context, \n        url, \n        info, \n        imageAPIVersion, \n        width, \n        height, \n        maxZoom, \n        canvas, \n        label, \n        imageLabel, \n        zoomDimensions, \n        widthAtCurrentZoomLevel, \n        heightAtCurrentZoomLevel;\n\n    let lowestMaxZoom: number = 100;\n    let maxRatio: number = 0;\n    let minRatio: number = 100;\n\n    // quickly determine the lowest possible max zoom level (i.e., the upper bound for images) across all canvases.\n    // while we're here, compute the global ratios as well.\n    for (let z: number = 0; z < numCanvases; z++)\n    {\n        const c: any = canvases[z];              // canvas\n        const w: number = c.width;                  // canvas width\n        const h: number = c.height;                 // canvas height\n        const mz: number = getMaxZoomLevel(w, h);  // max zoom level\n        const ratio: number = h / w;\n        maxRatio = Math.max(ratio, maxRatio);\n        minRatio = Math.min(ratio, minRatio);\n        lowestMaxZoom = Math.min(lowestMaxZoom, mz);\n    }\n\n    /*\n        These arrays need to be pre-initialized since we will do arithmetic and value checking on them\n    */\n    const totalWidths: number[] = new Array(lowestMaxZoom + 1).fill(0);\n    const totalHeights: number[] = new Array(lowestMaxZoom + 1).fill(0);\n    const maxWidths: number[] = new Array(lowestMaxZoom + 1).fill(0);\n    const maxHeights: number[] = new Array(lowestMaxZoom + 1).fill(0);\n\n    for (let i: number = 0; i < numCanvases; i++)\n    {\n        thisCanvas = canvases[i];\n        canvas = thisCanvas['@id'] || thisCanvas.id;\n        label = thisCanvas.label;\n        thisResource = thisCanvas.images ? thisCanvas.images[0].resource : thisCanvas.items[0].items[0].body;\n\n        /*\n         * If a canvas has multiple images it will be encoded\n         * with a resource type of \"oa:Choice\" (v2) or \"Choice\" (v3).\n         **/\n        otherImages = []; // reset array\n        if (thisResource['@type'] === \"oa:Choice\" || thisResource.type === \"Choice\")\n        {\n            thisImage = thisResource.default || thisResource.items[0];\n            secondaryImages = thisResource.item || thisResource.items.slice(1);\n            otherImages = getOtherImageData(secondaryImages, lowestMaxZoom);\n        }\n        else\n        {\n            thisImage = thisResource;\n        }\n\n        // Prioritize the canvas height / width first, since images may not have h/w\n        width = thisCanvas.width || thisImage.width;\n        height = thisCanvas.height || thisImage.height;\n\n        if (width <= 0 || height <= 0)\n        {\n            console.warn('Invalid width or height for canvas ' + label + '. Skipping');\n            continue;\n        }\n\n        maxZoom = getMaxZoomLevel(width, height);\n\n        imageLabel = thisImage.label || null;\n\n        info = parseImageInfo(thisImage);\n        url = info.url.slice(-1) !== '/' ? info.url + '/' : info.url;  // append trailing slash to url if it's not there.\n\n        context = thisImage.service['@context'] || thisImage.service.type;\n\n        if (context === 'http://iiif.io/api/image/2/context.json' || context === \"ImageService2\")\n        {\n            imageAPIVersion = 2;\n        }\n        else if (context === 'http://library.stanford.edu/iiif/image-api/1.1/context.json')\n        {\n            imageAPIVersion = 1.1;\n        }\n        else\n        {\n            imageAPIVersion = 1.0;\n        }\n\n        zoomDimensions = new Array(lowestMaxZoom + 1);\n\n        for (let k: number = 0; k < lowestMaxZoom + 1; k++)\n        {\n            widthAtCurrentZoomLevel = Math.floor(incorporateZoom(width, lowestMaxZoom - k));\n            heightAtCurrentZoomLevel = Math.floor(incorporateZoom(height, lowestMaxZoom - k));\n            zoomDimensions[k] = {\n                h: heightAtCurrentZoomLevel,\n                w: widthAtCurrentZoomLevel\n            };\n\n            totalWidths[k]! += widthAtCurrentZoomLevel;\n            totalHeights[k]! += heightAtCurrentZoomLevel;\n            maxWidths[k] = Math.max(widthAtCurrentZoomLevel, maxWidths[k]!);\n            maxHeights[k] = Math.max(heightAtCurrentZoomLevel, maxHeights[k]!);\n        }\n\n        let isPaged = thisCanvas.viewingHint !== 'non-paged' || (thisCanvas.behavior ? thisCanvas.behavior[0] !== 'non-paged' : false);\n        let isFacing = thisCanvas.viewingHint === 'facing-pages' || (thisCanvas.behavior ? thisCanvas.behavior[0] === 'facing-pages' : false);\n\n        pages[i] = {\n            d: zoomDimensions,\n            m: maxZoom,\n            l: label,         // canvas label ('page 1, page 2', etc.)\n            il: imageLabel,   // default image label ('primary image', 'UV light', etc.)\n            f: info.url,\n            url: url,\n            api: imageAPIVersion,\n            paged: isPaged,\n            facingPages: isFacing,\n            canvas: canvas,\n            otherImages: otherImages,\n            xoffset: info.x || null,\n            yoffset: info.y || null\n        };\n    }\n\n    const averageWidths: number[] = new Array(lowestMaxZoom + 1).fill(0);\n    const averageHeights: number[] = new Array(lowestMaxZoom + 1).fill(0);\n\n    for (let a = 0; a < lowestMaxZoom + 1; a++)\n    {\n        averageWidths[a] = totalWidths[a]! / numCanvases;\n        averageHeights[a] = totalHeights[a]! / numCanvases;\n    }\n\n    const dims: DivaDimensionMeasurements = {\n        a_wid: averageWidths,\n        a_hei: averageHeights,\n        max_w: maxWidths,\n        max_h: maxHeights,\n        max_ratio: maxRatio,\n        min_ratio: minRatio,\n        t_hei: totalHeights,\n        t_wid: totalWidths\n    };\n\n    // assumes paged is false for non-paged values\n    return {\n        version: version,\n        item_title: parseLabelValue(manifest).label,\n        metadata: manifest.metadata || null,\n        dims: dims,\n        max_zoom: lowestMaxZoom,\n        pgs: pages,\n        paged: manifest.viewingHint === 'paged' || (manifest.behaviour ? manifest.behaviour[0] === 'paged' : false) || (sequence ? sequence.viewingHint === 'paged' : false)\n    };\n}\n\n/**\n * Takes in a resource block from a canvas and outputs the following information associated with that resource:\n * - Image URL\n * - Image region to be displayed\n *\n * @param {Object} resource - an object representing the resource block of a canvas section in a IIIF manifest\n * @returns {Object} imageInfo - an object containing image URL and region\n */\nfunction parseImageInfo (resource: Record<string, any>): DivaImageInfo\n{\n    let url = resource['@id'] || resource.id;\n    const fragmentRegex = /#xywh=([0-9]+,[0-9]+,[0-9]+,[0-9]+)/;\n    let xywh = '';\n    let stripURL = true;\n\n    if (/\\/([0-9]+,[0-9]+,[0-9]+,[0-9]+)\\//.test(url))\n    {\n        // if resource in image API format, extract region x,y,w,h from URL (after 4th slash from last)\n        // matches coordinates in URLs of the form http://www.example.org/iiif/book1-page1/40,50,1200,1800/full/0/default.jpg\n        const urlArray = url.split('/');\n        xywh = urlArray[urlArray.length - 4];\n    }\n    else if (fragmentRegex.test(url))\n    {\n        // matches coordinates of the style http://www.example.org/iiif/book1/canvas/p1#xywh=50,50,320,240\n        const result:  RegExpExecArray | null = fragmentRegex.exec(url)!;\n        xywh = result[1];\n    }\n    else if (resource.service && (resource.service['@id'] || resource.service.id))\n    {\n        // this URL excludes region parameters so we don't need to remove them\n        url = resource.service['@id'] || resource.service.id;\n        stripURL = false;\n    }\n\n    if (stripURL)\n    {\n        // extract URL up to identifier (we eliminate the last 5 parameters: /region/size/rotation/quality.format)\n        url = url.split('/').slice(0, -4).join('/');\n    }\n\n    const imageInfo: DivaImageInfo = {\n        url: url\n    };\n\n    if (xywh.length)\n    {\n        // parse into separate components\n        const dimensions = xywh.split(',');\n        imageInfo.x = parseInt(dimensions[0], 10);\n        imageInfo.y = parseInt(dimensions[1], 10);\n        imageInfo.w = parseInt(dimensions[2], 10);\n        imageInfo.h = parseInt(dimensions[3], 10);\n    }\n\n    return imageInfo;\n}\n","import { elt, setAttributes } from './utils/elt';\nimport CompositeImage from './composite-image';\nimport DocumentLayout from './document-layout';\nimport ImageCache from './image-cache';\nimport ImageRequestHandler from './image-request-handler';\nimport InterpolateAnimation from './interpolate-animation';\nimport {\n    MergedConfiguration,\n    RendererHooks,\n    RendererLoadConfig,\n    RendererSettings,\n    RendererViewportPosition\n} from \"./options-settings\";\nimport {\n    DivaTileSource,\n    LayoutGroupPage,\n    Offset,\n    PageGroup,\n    PageInfo,\n    ScaledDivaTileSource,\n    SourceProvider\n} from \"./viewer-type-definitions\";\n\nconst REQUEST_DEBOUNCE_INTERVAL = 250;\n\nexport default class Renderer\n{\n    _viewport: any;\n    _outerElement: HTMLElement | null;\n    _documentElement: HTMLElement | null;\n    _settings: MergedConfiguration;\n    _hooks: RendererHooks;\n    _canvas: HTMLCanvasElement;\n    _ctx: CanvasRenderingContext2D | null;\n    _sourceResolver: SourceProvider | null;\n    _renderedPages: LayoutGroupPage[] | null;\n    _config: RendererLoadConfig | null;\n    _zoomLevel: number | null;\n    _compositeImages: object | null;\n    _renderedTiles: any[];\n    _animation: any;\n    _cache: ImageCache;\n    _pendingRequests: Record<string, any>;\n    layout: DocumentLayout | null;\n\n\n    constructor(options: RendererSettings, hooks: RendererHooks)\n    {\n        this._viewport = options.viewport;\n        this._outerElement = options.outerElement;\n        this._documentElement = options.innerElement;\n        this._settings = options.settings;\n\n        this._hooks = hooks || {};\n\n        this._canvas = <HTMLCanvasElement>elt('canvas', {class: 'diva-viewer-canvas'});\n        this._ctx = this._canvas.getContext('2d');\n        // @ts-ignore\n        this._ctx.imageSmoothingEnabled = true;\n\n        this.layout = null;\n\n        this._sourceResolver = null;\n        this._renderedPages = null;\n        this._config = null;\n        this._zoomLevel = null;\n        this._compositeImages = null;\n        this._renderedTiles = null;\n        this._animation = null;\n\n        // FIXME(wabain): What level should this be maintained at?\n        // Diva global?\n        this._cache = new ImageCache();\n        this._pendingRequests = {};\n    }\n\n    static getCompatibilityErrors()\n    {\n        if (typeof HTMLCanvasElement !== 'undefined')\n        {\n            return null;\n        }\n\n        return [\n            'Your browser lacks support for the canvas element. Please upgrade your browser.'\n        ];\n    }\n\n    load(config: RendererLoadConfig, viewportPosition: RendererViewportPosition, sourceResolver: SourceProvider)\n    {\n        this._clearAnimation();\n\n        if (this._hooks.onViewWillLoad)\n        {\n            this._hooks.onViewWillLoad();\n        }\n\n        this._sourceResolver = sourceResolver;\n        this._config = config;\n        this._compositeImages = {};\n        this._setLayoutToZoomLevel(viewportPosition.zoomLevel);\n\n        // FIXME(wabain): Remove this when there's more confidence the check shouldn't be needed\n        if (this.layout && !this.layout.getPageInfo(viewportPosition.anchorPage))\n        {\n            //throw new Error('invalid page: ' + viewportPosition.anchorPage);\n            viewportPosition.anchorPage = parseInt(this.layout.getIndexOfFirstPage(), 10);\n        }\n\n        if (this._canvas.width !== this._viewport.width || this._canvas.height !== this._viewport.height)\n        {\n            this._canvas.width = this._viewport.width;\n            this._canvas.height = this._viewport.height;\n        }\n\n        // FIXME: What hooks should be called here?\n        this.goto(viewportPosition.anchorPage, viewportPosition.verticalOffset, viewportPosition.horizontalOffset);\n\n        if (this._canvas.parentNode !== this._outerElement)\n        {\n            this._outerElement!.insertBefore(this._canvas, this._outerElement!.firstChild);\n        }\n\n        if (this._hooks.onViewDidLoad)\n        {\n            this._hooks.onViewDidLoad();\n        }\n    }\n\n    _setViewportPosition(viewportPosition: RendererViewportPosition)\n    {\n        if (viewportPosition.zoomLevel !== this._zoomLevel)\n        {\n            if (this._zoomLevel === null)\n            {\n                throw new TypeError('The current view is not zoomable');\n            }\n            else if (viewportPosition.zoomLevel === null)\n            {\n                throw new TypeError('The current view requires a zoom level');\n            }\n\n            this._setLayoutToZoomLevel(viewportPosition.zoomLevel);\n        }\n\n        this._goto(viewportPosition.anchorPage, viewportPosition.verticalOffset, viewportPosition.horizontalOffset);\n    }\n\n    _setLayoutToZoomLevel(zoomLevel: number)\n    {\n        this.layout = new DocumentLayout(this._config!, zoomLevel);\n        this._zoomLevel = zoomLevel;\n\n        setAttributes(this._documentElement, {\n            style: {\n                height: this.layout.dimensions.height + 'px',\n                width: this.layout.dimensions.width + 'px'\n            }\n        });\n\n        this._viewport.setInnerDimensions(this.layout.dimensions);\n    }\n\n    adjust()\n    {\n        this._clearAnimation();\n\n        this._render();\n\n        if (this._hooks.onViewDidUpdate)\n        {\n            this._hooks.onViewDidUpdate(this._renderedPages.slice(), null);\n        }\n    }\n\n    _render()\n    {\n        const newRenderedPages: LayoutGroupPage[] = [];\n        this.layout.pageGroups.forEach((group: PageGroup) =>\n        {\n            if (!this._viewport.intersectsRegion(group.region))\n            {\n                return;\n            }\n\n            const visiblePages = group.pages\n                .filter((page) =>\n                {\n                    return this.isPageVisible(page.index);\n                })\n                .map(page => page.index);\n\n            newRenderedPages.push.apply(newRenderedPages, visiblePages);\n        }, this);\n\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n        this._paintOutline(newRenderedPages);\n\n        newRenderedPages.forEach((pageIndex: number) =>\n        {\n            if (!this._compositeImages[pageIndex])\n            {\n                const page = this.layout.getPageInfo(pageIndex);\n                const zoomLevels = this._sourceResolver.getAllZoomLevelsForPage(page);\n                const composite = new CompositeImage(zoomLevels);\n                composite.updateFromCache(this._cache);\n                this._compositeImages[pageIndex] = composite;\n            }\n        });\n\n        this._initiateTileRequests(newRenderedPages);\n\n        const changes = findChanges(this._renderedPages || [], newRenderedPages);\n\n        changes.removed.forEach((pageIndex) =>\n        {\n            delete this._compositeImages[pageIndex];\n        });\n\n        this._renderedPages = newRenderedPages;\n        this._paint();\n\n        if (this._hooks.onPageWillLoad)\n        {\n            changes.added.forEach((pageIndex) =>\n            {\n                this._hooks.onPageWillLoad(pageIndex);\n            }, this);\n        }\n    }\n\n    _paint()\n    {\n        const renderedTiles = [];\n\n        this._renderedPages.forEach((pageIndex: number) =>\n        {\n            this._compositeImages[pageIndex].getTiles(this._zoomLevel).forEach((source) =>\n            {\n                const scaled = getScaledTileRecord(source, this._zoomLevel);\n\n                if (this._isTileVisible(pageIndex, scaled))\n                {\n                    renderedTiles.push(source.url);\n                    this._drawTile(pageIndex, scaled, this._cache.get(source.url));\n                }\n            });\n        });\n\n        const cache = this._cache;\n\n        const changes = findChanges(this._renderedTiles || [], renderedTiles);\n\n        changes.added.forEach((url: string) =>\n        {\n            cache.acquire(url);\n        });\n\n        changes.removed.forEach((url: string) =>\n        {\n            cache.release(url);\n        });\n\n        if (changes.removed)\n        {\n            // FIXME: Should only need to update the composite images\n            // for which tiles were removed\n            this._renderedPages.forEach((pageIndex: number) =>\n            {\n                this._compositeImages[pageIndex].updateFromCache(this._cache);\n            }, this);\n        }\n\n        this._renderedTiles = renderedTiles;\n    }\n\n    // Paint a page outline while the tiles are loading.\n    _paintOutline(pages)\n    {\n        pages.forEach((pageIndex) =>\n        {\n            let pageInfo = this.layout.getPageInfo(pageIndex);\n            let pageOffset = this._getImageOffset(pageIndex);\n\n            // Ensure the document is drawn to the center of the viewport\n            let viewportPaddingX = Math.max(0, (this._viewport.width - this.layout.dimensions.width) / 2);\n            let viewportPaddingY = Math.max(0, (this._viewport.height - this.layout.dimensions.height) / 2);\n\n            let viewportOffsetX = pageOffset.left - this._viewport.left + viewportPaddingX;\n            let viewportOffsetY = pageOffset.top - this._viewport.top + viewportPaddingY;\n\n            let destXOffset = viewportOffsetX < 0 ? -viewportOffsetX : 0;\n            let destYOffset = viewportOffsetY < 0 ? -viewportOffsetY : 0;\n\n            let canvasX = Math.max(0, viewportOffsetX);\n            let canvasY = Math.max(0, viewportOffsetY);\n\n            let destWidth = pageInfo.dimensions.width - destXOffset;\n            let destHeight = pageInfo.dimensions.height - destYOffset;\n\n            this._ctx.strokeStyle = '#AAA';\n            // In order to get a 1px wide line using strokes, we need to start at a 'half pixel'\n            this._ctx.strokeRect(canvasX + 0.5, canvasY + 0.5, destWidth, destHeight);\n        });\n    }\n\n    // This method should be sent all visible pages at once because it will initiate\n    // all image requests and cancel any remaining image requests. In the case that\n    // a request is ongoing and the tile is still visible in the viewport, the old request\n    // is kept active instead of restarting it. The image requests are given a timeout\n    // before loading in order to debounce them and have a small reaction time\n    // to cancel them and avoid useless requests.\n    _initiateTileRequests(pages)\n    {\n        // Only requests in this object are kept alive, since all others are not visible in the viewport\n        const newPendingRequests: Record<string, any> = {};\n\n        // Used later as a closure to initiate the image requests with the right source and pageIndex\n        const initiateRequest = (source, pageIndex) =>\n        {\n            const composite = this._compositeImages[pageIndex];\n\n            newPendingRequests[source.url] = new ImageRequestHandler({\n                url: source.url,\n                timeoutTime: REQUEST_DEBOUNCE_INTERVAL,\n                settings: this._settings,\n                load: (img: HTMLImageElement) =>\n                {\n                    delete this._pendingRequests[source.url];\n                    this._cache.put(source.url, img);\n\n                    // Awkward way to check for updates\n                    if (composite === this._compositeImages[pageIndex])\n                    {\n                        composite.updateWithLoadedUrls([source.url]);\n\n                        if (this._isTileForSourceVisible(pageIndex, source))\n                        {\n                            this._paint();\n                        }\n                    }\n                    else\n                    {\n                        if (this._isTileForSourceVisible(pageIndex, source))\n                        {\n                            this._paint();\n                        }\n                    }\n                },\n                error: () =>\n                {\n                    // TODO: Could make a limited number of retries, etc.\n                    delete this._pendingRequests[source.url];\n                }\n            });\n        };\n\n        for (let i = 0; i < pages.length; i++)\n        {\n            const pageIndex = pages[i];\n            const tiles = this._sourceResolver.getBestZoomLevelForPage(this.layout.getPageInfo(pageIndex)).tiles;\n\n            for (let j = 0; j < tiles.length; j++)\n            {\n                const source = tiles[j];\n                if (this._cache.has(source.url) || !this._isTileForSourceVisible(pageIndex, source))\n                {\n                    continue;\n                }\n\n                // Don't create a new request if the tile is already being loaded\n                if (this._pendingRequests[source.url])\n                {\n                    newPendingRequests[source.url] = this._pendingRequests[source.url];\n                    delete this._pendingRequests[source.url];\n                    continue;\n                }\n\n                // Use a closure since the load and error methods are going to be called later and\n                // we need to keep the right reference to the source and the page index\n                initiateRequest(source, pageIndex);\n            }\n        }\n\n        for (const url in this._pendingRequests)\n        {\n            this._pendingRequests[url].abort();\n        }\n        this._pendingRequests = newPendingRequests;\n    }\n\n    _drawTile(pageIndex: number, scaledTile: ScaledDivaTileSource, img: CanvasImageSource)\n    {\n        let tileOffset = this._getTileToDocumentOffset(pageIndex, scaledTile);\n\n        // Ensure the document is drawn to the center of the viewport\n        let viewportPaddingX = Math.max(0, (this._viewport.width - this.layout.dimensions.width) / 2);\n        let viewportPaddingY = Math.max(0, (this._viewport.height - this.layout.dimensions.height) / 2);\n\n        let viewportOffsetX = tileOffset.left - this._viewport.left + viewportPaddingX;\n        let viewportOffsetY = tileOffset.top - this._viewport.top + viewportPaddingY;\n\n        let destXOffset = viewportOffsetX < 0 ? -viewportOffsetX : 0;\n        let destYOffset = viewportOffsetY < 0 ? -viewportOffsetY : 0;\n\n        let canvasX = Math.max(0, viewportOffsetX);\n        let canvasY = Math.max(0, viewportOffsetY);\n\n        let sourceXOffset = destXOffset / scaledTile.scaleRatio;\n        let sourceYOffset = destYOffset / scaledTile.scaleRatio;\n\n        // Ensure that the specified dimensions are no greater than the actual\n        // size of the image. Safari won't display the tile if they are.\n        let destImgWidth = Math.min(scaledTile.dimensions.width, img.width * scaledTile.scaleRatio) - destXOffset;\n        let destImgHeight = Math.min(scaledTile.dimensions.height, img.height * scaledTile.scaleRatio) - destYOffset;\n\n        let destWidth = Math.max(1, Math.round(destImgWidth));\n        let destHeight = Math.max(1, Math.round(destImgHeight));\n\n        let sourceWidth = destWidth / scaledTile.scaleRatio;\n        let sourceHeight = destHeight / scaledTile.scaleRatio;\n\n        this._ctx.drawImage(\n            img,\n            sourceXOffset, sourceYOffset,\n            sourceWidth, sourceHeight,\n            canvasX, canvasY,\n            destWidth, destHeight);\n    }\n\n    _isTileForSourceVisible (pageIndex, tileSource)\n    {\n        return this._isTileVisible(pageIndex, getScaledTileRecord(tileSource, this._zoomLevel));\n    }\n\n    _isTileVisible (pageIndex, scaledTile)\n    {\n        const tileOffset = this._getTileToDocumentOffset(pageIndex, scaledTile);\n\n        // FIXME(wabain): This check is insufficient during a zoom transition\n        return this._viewport.intersectsRegion({\n            top: tileOffset.top,\n            bottom: tileOffset.top + scaledTile.dimensions.height,\n            left: tileOffset.left,\n            right: tileOffset.left + scaledTile.dimensions.width\n        });\n    }\n\n    _getTileToDocumentOffset (pageIndex, scaledTile)\n    {\n        const imageOffset = this._getImageOffset(pageIndex);\n\n        return {\n            top: imageOffset.top + scaledTile.offset.top,\n            left: imageOffset.left + scaledTile.offset.left\n        };\n    }\n\n    _getImageOffset (pageIndex)\n    {\n        return this.layout.getPageOffset(pageIndex, {includePadding: true});\n    }\n\n    // TODO: Update signature\n    goto (pageIndex, verticalOffset, horizontalOffset)\n    {\n        this._clearAnimation();\n        this._goto(pageIndex, verticalOffset, horizontalOffset);\n\n        if (this._hooks.onViewDidUpdate)\n        {\n            this._hooks.onViewDidUpdate(this._renderedPages.slice(), pageIndex);\n        }\n    }\n\n    _goto (pageIndex, verticalOffset, horizontalOffset)\n    {\n        // FIXME(wabain): Move this logic to the viewer\n        const pageOffset = this.layout.getPageOffset(pageIndex);\n\n        const desiredVerticalCenter = pageOffset.top + verticalOffset;\n        const top = desiredVerticalCenter - Math.round(this._viewport.height / 2);\n\n        const desiredHorizontalCenter = pageOffset.left + horizontalOffset;\n        const left = desiredHorizontalCenter - Math.round(this._viewport.width / 2);\n\n        this._viewport.top = top;\n        this._viewport.left = left;\n\n        this._render();\n    }\n\n    transitionViewportPosition (options)\n    {\n        this._clearAnimation();\n\n        const getPosition = options.getPosition;\n        const onViewDidTransition = this._hooks.onViewDidTransition;\n\n        this._animation = InterpolateAnimation.animate({\n            duration: options.duration,\n            parameters: options.parameters,\n            onUpdate: (values) =>\n            {\n                this._setViewportPosition(getPosition(values));\n                this._hooks.onZoomLevelWillChange(values.zoomLevel);\n\n                if (onViewDidTransition)\n                {\n                    onViewDidTransition();\n                }\n            },\n            onEnd: (info) =>\n            {\n                if (options.onEnd)\n                {\n                    options.onEnd(info);\n                }\n\n                if (this._hooks.onViewDidUpdate && !info.interrupted)\n                {\n                    this._hooks.onViewDidUpdate(this._renderedPages.slice(), null);\n                }\n            }\n        });\n    }\n\n    _clearAnimation ()\n    {\n        if (this._animation)\n        {\n            this._animation.cancel();\n            this._animation = null;\n        }\n    }\n\n    isPageVisible (pageIndex: number)\n    {\n        if (!this.layout)\n        {\n            return false;\n        }\n\n        const page: PageInfo | null = this.layout.getPageInfo(pageIndex);\n\n        if (!page)\n        {\n            return false;\n        }\n\n        return this._viewport.intersectsRegion(this.layout.getPageRegion(pageIndex));\n    }\n\n    getRenderedPages (): number[]\n    {\n        return this._renderedPages!.slice();\n    }\n\n    destroy ()\n    {\n        this._clearAnimation();\n\n        // FIXME(wabain): I don't know if we should actually do this\n        Object.keys(this._pendingRequests).forEach((req) =>\n        {\n            const handler = this._pendingRequests[req];\n            delete this._pendingRequests[req];\n\n            handler.abort();\n        }, this);\n\n        this._canvas.parentNode.removeChild(this._canvas);\n    }\n}\n\nfunction getScaledTileRecord (source: DivaTileSource, scaleFactor: number | null): ScaledDivaTileSource\n{\n    let scaleRatio: number;\n\n    if (scaleFactor === null)\n    {\n        scaleRatio = 1;\n    }\n    else\n    {\n        scaleRatio = Math.pow(2, scaleFactor - source.zoomLevel);\n    }\n\n    return {\n        sourceZoomLevel: source.zoomLevel,\n        scaleRatio: scaleRatio,\n        row: source.row,\n        col: source.col,\n        dimensions: {\n            width: source.dimensions.width * scaleRatio,\n            height: source.dimensions.height * scaleRatio\n        },\n        offset: {\n            left: source.offset.left * scaleRatio,\n            top: source.offset.top * scaleRatio\n        },\n        url: source.url\n    };\n}\n\nfunction findChanges (oldArray: any[], newArray: any[]): { added: any[], removed: any[] }\n{\n    if (oldArray === newArray)\n    {\n        return {\n            added: [],\n            removed: []\n        };\n    }\n\n    const removed = oldArray.filter(oldEntry => newArray.indexOf(oldEntry) === -1);\n\n    const added = newArray.filter(newEntry => oldArray.indexOf(newEntry) === -1);\n\n    return {\n        added: added,\n        removed: removed\n    };\n}\n","export default class TileCoverageMap\n{\n    _rows: number;\n    _cols: number;\n    _map: boolean[][];\n\n    constructor (rows: number, cols: number)\n    {\n        this._rows = rows;\n        this._cols = cols;\n        this._map = new Array(rows).fill(null).map(() => new Array(cols).fill(false));\n    }\n\n    isLoaded (row: number, col: number): boolean\n    {\n        // Return true for out of bounds tiles because they\n        // don't need to load. (Unfortunately this will also\n        // mask logical errors.)\n        if (row >= this._rows || col >= this._cols)\n        {\n            return true;\n        }\n\n        return this._map[row][col];\n    }\n\n    set(row: number, col: number, value: boolean)\n    {\n        this._map[row][col] = value;\n    }\n}\n","import globalDiva from './diva-global';\nimport { elt } from './utils/elt';\n\nexport default class Toolbar\n{\n    settings: any;\n    viewer: any;\n\n    constructor (viewer: any)\n    {\n        this.viewer = viewer;\n        this.settings = viewer.settings;\n    }\n\n    _elemAttrs (ident: string, base?: any)\n    {\n        const attrs = {\n            id: this.settings.ID + ident,\n            class: 'diva-' + ident\n        };\n\n        if (base)\n        {\n            return Object.assign(attrs, base);\n        }\n        else\n        {\n            return attrs;\n        }\n    }\n\n\n    /** Convenience function to subscribe to a Diva event */\n    _subscribe (event: string, callback: any)\n    {\n        globalDiva.Events.subscribe(event, callback, this.settings.ID);\n    }\n\n\n    createButton (name: string, label: string, callback: any, icon?: SVGSVGElement): HTMLElement\n    {\n        const button = elt('button', {\n            type: 'button',\n            id: this.settings.ID + name,\n            class: 'diva-' + name + ' diva-button',\n            title: label,\n            'aria-label': label\n        });\n\n        if (icon)\n        {\n            button.appendChild(icon);\n        }\n\n        if (callback)\n        {\n            button.addEventListener('click', callback);\n        }\n\n        return button;\n    }\n\n    createLabel (name: string, id: string, label: string, innerName: string, innerValue: any)\n    {\n        return elt('div', { id: this.settings.ID + id, class: name + ' diva-label'},\n                    [ label, elt('span', { id: this.settings.ID + innerName }, innerValue)\n                    ]);\n    }\n\n    createZoomButtons ()\n    {\n        let zoomOutIcon = this._createZoomOutIcon();\n        let zoomInIcon = this._createZoomInIcon();\n\n        let zoomButtons = [\n            this.createButton('zoom-out-button', 'Zoom Out', () => {\n                this.viewer.setZoomLevel(this.settings.zoomLevel - 1);\n            }, zoomOutIcon),\n            this.createButton('zoom-in-button', 'Zoom In', () => {\n                this.viewer.setZoomLevel(this.settings.zoomLevel + 1);\n            }, zoomInIcon),\n            this.createLabel('diva-zoom-label', 'zoom-label', 'Zoom level: ', 'zoom-level', this.settings.zoomLevel + 1)\n        ];\n\n        let zoomHandler = () =>\n        {\n            let labelEl: HTMLElement | null = document.getElementById(this.settings.ID + 'zoom-level')!;\n            labelEl.textContent = this.settings.zoomLevel + 1;\n        };\n\n        this._subscribe('ZoomLevelDidChange', zoomHandler);\n        this._subscribe('ViewerDidLoad', zoomHandler);\n\n        return elt('div', { id: this.settings.ID + \"zoom-controls\", style: \"display: none\"}, zoomButtons);\n    }\n\n    createGridControls ()\n    {\n        let gridMoreIcon = this._createGridMoreIcon();\n        let gridFewerIcon = this._createGridFewerIcon();\n\n        let gridButtons = [\n            this.createButton('grid-out-button', 'Fewer', () =>\n            {\n                this.viewer.setGridPagesPerRow(this.settings.pagesPerRow - 1);\n            }, gridFewerIcon),\n            this.createButton('grid-in-button', 'More', () =>\n            {\n                this.viewer.setGridPagesPerRow(this.settings.pagesPerRow + 1);\n            }, gridMoreIcon),\n            this.createLabel('diva-grid-label', 'grid-label', 'Pages per row: ', 'pages-per-row', this.settings.pagesPerRow)\n        ];\n\n        let gridChangeHandler = () =>\n        {\n            let labelEl: HTMLElement | null = document.getElementById(this.settings.ID + 'pages-per-row')!;\n            labelEl.textContent = this.settings.pagesPerRow;\n        };\n\n        this._subscribe('GridRowNumberDidChange', gridChangeHandler);\n\n        return elt('div', {id: this.settings.ID + \"grid-controls\", style: \"display:none\" }, gridButtons);\n    }\n\n    createPageLabel ()\n    {\n        // Current page\n        const currentPage = elt('span', {\n            id: this.settings.ID + 'current-page'\n        });\n\n        const updateCurrentPage = () =>\n        {\n            // get labels for index range\n            let indices = this.viewer.getCurrentPageIndices();\n            let startIndex = indices[0];\n            let endIndex = indices[indices.length - 1];\n            let startLabel = this.settings.manifest.pages[startIndex].l;\n            let endLabel = this.settings.manifest.pages[endIndex].l;\n\n            if (startIndex !== endIndex)\n            {\n                if (this.settings.enableIndexAsLabel)\n                {\n                    currentPage.textContent = startIndex + \" - \" + endIndex;\n                }\n                else\n                {\n                    currentPage.textContent = startLabel + \" - \" + endLabel;\n                }\n            }\n            else\n            {\n                if (this.settings.enableIndexAsLabel)\n                {\n                    currentPage.textContent = startIndex;\n                }\n                else\n                {\n                    currentPage.textContent = startLabel;\n                }\n            }\n        };\n\n        this._subscribe('VisiblePageDidChange', updateCurrentPage);\n        this._subscribe('ViewerDidLoad', updateCurrentPage);\n        this._subscribe('ViewDidSwitch', updateCurrentPage);\n\n        return elt('span', {\n                class: 'diva-page-label diva-label'\n            },\n            currentPage\n        );\n    }\n\n    createGotoPageForm ()\n    {\n        const gotoPageInput: HTMLInputElement = elt('input', {\n            id: this.settings.ID + 'goto-page-input',\n            class: 'diva-input diva-goto-page-input',\n            autocomplete: 'off',\n            type: 'text',\n            'aria-label': 'Page Input'\n        }) as HTMLInputElement;\n\n        const gotoPageSubmit = elt('input', {\n            id: this.settings.ID + 'goto-page-submit',\n            class: 'diva-button diva-button-text',\n            type: 'submit',\n            value: 'Go'\n        });\n\n        const inputSuggestions = elt('div', {\n                id: this.settings.ID + 'input-suggestions',\n                class: 'diva-input-suggestions'\n            }\n        );\n\n        const gotoForm = elt('form', {\n                id: this.settings.ID + 'goto-page',\n                class: 'diva-goto-form'\n            },\n            gotoPageInput,\n            gotoPageSubmit,\n            inputSuggestions\n        );\n\n        gotoForm.addEventListener('submit', (e) =>\n        {\n            e.preventDefault();\n\n            const desiredPageLabel = gotoPageInput.value;\n\n            if (this.settings.onGotoSubmit && typeof this.settings.onGotoSubmit === \"function\")\n            {\n                const pageIndex = this.settings.onGotoSubmit(desiredPageLabel);\n                if (!this.viewer.gotoPageByIndex(pageIndex))\n                    window.alert(\"No page could be found with that label or page number\");\n\n            }\n            else // Default if no function is specified in the settings\n            {\n                if (!this.viewer.gotoPageByLabel(desiredPageLabel))\n                    window.alert(\"No page could be found with that label or page number\");\n            }\n\n            // Hide the suggestions\n            inputSuggestions.style.display = 'none';\n\n            // Prevent the default action of reloading the page\n            return false;\n        });\n\n        ['input', 'focus'].forEach(event =>\n        {\n            gotoPageInput.addEventListener(event, () => {\n                inputSuggestions.innerHTML = ''; // Remove all previous suggestions\n\n                const value = gotoPageInput.value;\n                let numSuggestions = 0;\n                if (this.settings.enableGotoSuggestions && value)\n                {\n                    const pages = this.settings.manifest.pages;\n                    for (let i = 0, len = pages.length; i < len && numSuggestions < 10; i++)\n                    {\n                        if (pages[i].l.toLowerCase().indexOf(value.toLowerCase()) > -1)\n                        {\n                            const newInputSuggestion = elt('div', {\n                                    class: 'diva-input-suggestion'\n                                },\n                                pages[i].l\n                            );\n\n                            inputSuggestions.appendChild(newInputSuggestion);\n\n                            numSuggestions++;\n                        }\n                    }\n\n                    // Show label suggestions\n                    if (numSuggestions > 0)\n                        inputSuggestions.style.display = 'block';\n                }\n                else\n                    inputSuggestions.style.display = 'none';\n            });\n        });\n\n        gotoPageInput.addEventListener('keydown', e => {\n            let el;\n            if (e.code === 'Enter') // 'Enter' key\n            {\n                const active: HTMLElement = document.getElementsByClassName('active')[0] as HTMLElement;\n                if (typeof active !== 'undefined')\n                {\n                    gotoPageInput.value = active.innerText;\n                }\n            }\n            if (e.code === 'ArrowUp') // Up arrow key\n            {\n                el = document.getElementsByClassName('active')[0];\n                const prevEl: HTMLElement | undefined = el ? el.previousSibling as HTMLElement : undefined;\n                if (typeof prevEl !== 'undefined')\n                {\n                    el.classList.remove('active');\n                    if (prevEl !== null)\n                    {\n                        prevEl.classList.add('active');\n                    }\n                }\n                else\n                {\n                    let last = document.getElementsByClassName('diva-input-suggestion').length - 1;\n                    document.getElementsByClassName('diva-input-suggestion')[last].classList.add('active');\n                }\n            }\n            else if (e.code === 'ArrowDown') // Down arrow key\n            {\n                el = document.getElementsByClassName('active')[0] as HTMLElement;\n                const nextEl: HTMLElement | undefined = el ? el.nextSibling as HTMLElement : undefined;\n                if (typeof nextEl !== 'undefined')\n                {\n                    el.classList.remove('active');\n                    if (nextEl !== null)\n                    {\n                        nextEl.classList.add('active');\n                    }\n                }\n                else\n                {\n                    document.getElementsByClassName('diva-input-suggestion')[0].classList.add('active');\n                }\n            }\n        });\n\n        onEvent(inputSuggestions, 'mousedown', '.diva-input-suggestion',  () =>\n        {\n            gotoPageInput.value = this.textContent;\n            inputSuggestions.style.display = 'none';\n            let submitEvent = new Event('submit', {\n                cancelable: true\n            });\n            gotoForm.dispatchEvent(submitEvent);\n        });\n\n        // javascript equivalent to jquery .on(event, selector, function)\n        function onEvent (elem: HTMLElement, evt: string, sel: string, handler: { (): void; call?: any; })\n        {\n            elem.addEventListener(evt,  (event) =>\n            {\n                let t = event.target;\n                while (t && t !== this)\n                {\n                    if (t.matches(sel))\n                    {\n                        handler.call(t, event);\n                    }\n                    t = t.parentNode;\n                }\n            });\n        }\n\n        gotoPageInput.addEventListener('blur', () => {\n            // Hide label suggestions\n            inputSuggestions.style.display = 'none';\n        });\n\n        return gotoForm;\n    }\n\n    createViewMenu ()\n    {\n        const viewOptionsList = elt('div', this._elemAttrs('view-options')) as HTMLElement;\n        const gridViewIcon = this._createGridViewIcon();\n        const bookViewIcon = this._createBookViewIcon();\n        const pageViewIcon = this._createPageViewIcon();\n\n        const viewOptionsToggle = () =>\n        {\n            viewOptionsList.style.display = viewOptionsList.style.display === \"none\" ? \"block\" : \"none\";\n        };\n\n        const changeViewButton = this.createButton('view-icon', 'Change view', viewOptionsToggle);\n\n        const selectView = (view: string) =>\n        {\n            this.viewer.changeView(view);\n\n            //hide view menu\n            viewOptionsList.style.display = \"none\";\n        };\n\n        const updateViewMenu = () =>\n        {\n            const viewIconClasses = ' diva-view-icon diva-button';\n\n\n            // display the icon of the mode we're currently in (?)\n            if (this.settings.inGrid)\n            {\n                changeViewButton.appendChild(gridViewIcon);\n                changeViewButton.className = 'diva-grid-icon' + viewIconClasses;\n            }\n            else if (this.settings.inBookLayout)\n            {\n                changeViewButton.appendChild(bookViewIcon);\n                changeViewButton.className = 'diva-book-icon' + viewIconClasses;\n            }\n            else\n            {\n                changeViewButton.appendChild(pageViewIcon);\n                changeViewButton.className = 'diva-document-icon' + viewIconClasses;\n            }\n\n            const viewOptions = document.createDocumentFragment();\n\n            // then display document, book, and grid buttons in that order, excluding the current view\n            if (this.settings.inGrid || this.settings.inBookLayout)\n            {\n                viewOptions.appendChild(this.createButton('document-icon', 'Document View', selectView.bind(null, 'document'), pageViewIcon));\n            }\n\n            if (this.settings.inGrid || !this.settings.inBookLayout)\n            {\n                viewOptions.appendChild(this.createButton('book-icon', 'Book View', selectView.bind(null, 'book'), bookViewIcon));\n            }\n\n            if (!this.settings.inGrid)\n            {\n                viewOptions.appendChild(this.createButton('grid-icon', 'Grid View', selectView.bind(null, 'grid'), gridViewIcon));\n            }\n\n            // remove old menu\n            while (viewOptionsList.firstChild)\n            {\n                viewOptionsList.removeChild(viewOptionsList.firstChild);\n            }\n\n            // insert new menu\n            viewOptionsList.appendChild(viewOptions);\n        };\n\n        document.addEventListener('mouseup', event =>\n        {\n            if (viewOptionsList !== event.target)\n            {\n                viewOptionsList.style.display = 'none';\n            }\n        });\n\n        this._subscribe('ViewDidSwitch', updateViewMenu);\n        this._subscribe('ObjectDidLoad', updateViewMenu);\n\n        return elt('div', this._elemAttrs('view-menu'),\n            changeViewButton,\n            viewOptionsList\n        );\n    }\n\n    createFullscreenButton ()\n    {\n        let fullscreenIcon = this._createFullscreenIcon();\n\n        return this.createButton('fullscreen-icon', 'Toggle fullscreen mode', () => {\n            this.viewer.toggleFullscreenMode();\n        }, fullscreenIcon);\n    }\n\n    toggleZoomGridControls ()\n    {\n        if (!this.settings.inGrid)\n        {\n            document.getElementById(this.settings.ID + \"zoom-controls\")!.style.display = \"block\";\n            document.getElementById(this.settings.ID + \"grid-controls\")!.style.display = \"none\";\n        }\n        else\n        {\n            document.getElementById(this.settings.ID + \"zoom-controls\")!.style.display = \"none\";\n            document.getElementById(this.settings.ID + \"grid-controls\")!.style.display = \"block\";\n        }\n\n    }\n\n    render ()\n    {\n        this._subscribe(\"ViewDidSwitch\", this.toggleZoomGridControls);\n        this._subscribe(\"ObjectDidLoad\", this.toggleZoomGridControls);\n\n        let leftTools = [\n            this.createZoomButtons(),\n            this.createGridControls()\n        ];\n        let rightTools = [\n            this.createPageLabel(),\n            this.createViewMenu()\n        ];\n        if (this.settings.enableFullscreen)\n        {\n            rightTools.push(this.createFullscreenButton());\n        }\n        if (this.settings.enableGotoPage)\n        {\n            rightTools.splice(1, 0, this.createGotoPageForm());\n        }\n\n        // assign toolbar plugins to proper side\n        let plugins = this.viewer.viewerState.pluginInstances;\n        for (let i = 0, len = plugins.length; i < len; i++)\n        {\n            let plugin = plugins[i];\n\n            if (!plugin.toolbarSide) // not a toolbar tool\n            {\n                continue;\n            }\n\n            plugin.toolbarIcon = plugin.createIcon();\n            if (!plugin.toolbarIcon) // icon couldn't be created\n            {\n                continue;\n            }\n\n            // add plugin tools after the go-to-page and page-label tools\n            if (plugin.toolbarSide === 'right')\n            {\n                rightTools.splice(2, 0, plugin.toolbarIcon);\n            }\n            else if (plugin.toolbarSide === 'left')\n            {\n                leftTools.splice(2, 0, plugin.toolbarIcon);\n            }\n\n            plugin.toolbarIcon.addEventListener('click', handlePluginClick.bind(this, plugin));\n        }\n\n        function handlePluginClick (plugin: { handleClick: (arg0: any) => void; })\n        {\n            plugin.handleClick(this.viewer);\n        }\n\n        const tools = elt('div', this._elemAttrs('tools'),\n                    elt('div', this._elemAttrs('tools-left'), leftTools),\n                    elt('div', this._elemAttrs('tools-right'), rightTools)\n                );\n\n        this.settings.toolbarParentObject.insertBefore(\n            tools,\n            this.settings.toolbarParentObject.firstChild\n        );\n    }\n\n    _createToolbarIcon (paths: any[])\n    {\n        let icon = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n        icon.setAttributeNS(null, 'viewBox', \"0 0 25 25\");\n        icon.setAttributeNS(null, 'x', '0px');\n        icon.setAttributeNS(null, 'y', '0px');\n        icon.setAttributeNS(null, 'style', \"enable-background:new 0 0 48 48;\");\n\n        let glyph = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n        glyph.setAttributeNS(null, \"transform\", \"matrix(1, 0, 0, 1, -12, -12)\");\n\n        paths.forEach( (path) =>\n        {\n            let pEl = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n            pEl.setAttributeNS(null, \"d\", path);\n            glyph.appendChild(pEl);\n        });\n\n        icon.appendChild(glyph);\n        return icon;\n    }\n\n    _createZoomOutIcon ()\n    {\n        let paths = [\n            \"M19.5,23c-0.275,0-0.5-0.225-0.5-0.5v-1c0-0.275,0.225-0.5,0.5-0.5h7c0.275,0,0.5,0.225,0.5,0.5v1c0,0.275-0.225,0.5-0.5,0.5H19.5z\",\n            \"M37.219,34.257l-2.213,2.212c-0.202,0.202-0.534,0.202-0.736,0l-6.098-6.099c-1.537,0.993-3.362,1.577-5.323,1.577c-5.431,0-9.849-4.418-9.849-9.849c0-5.431,4.418-9.849,9.849-9.849c5.431,0,9.849,4.418,9.849,9.849c0,1.961-0.584,3.786-1.576,5.323l6.098,6.098C37.422,33.722,37.422,34.054,37.219,34.257z M29.568,22.099c0-3.706-3.014-6.72-6.72-6.72c-3.706,0-6.72,3.014-6.72,6.72c0,3.706,3.014,6.72,6.72,6.72C26.555,28.818,29.568,25.805,29.568,22.099z\"\n        ];\n\n        return this._createToolbarIcon(paths);\n    }\n\n    _createZoomInIcon ()\n    {\n        let paths = [\n            \"M37.469,34.257l-2.213,2.212c-0.202,0.202-0.534,0.202-0.736,0l-6.098-6.099c-1.537,0.993-3.362,1.577-5.323,1.577c-5.431,0-9.849-4.418-9.849-9.849c0-5.431,4.418-9.849,9.849-9.849c5.431,0,9.849,4.418,9.849,9.849c0,1.961-0.584,3.786-1.576,5.323l6.098,6.098C37.672,33.722,37.672,34.054,37.469,34.257z M29.818,22.099c0-3.706-3.014-6.72-6.72-6.72c-3.706,0-6.72,3.014-6.72,6.72c0,3.706,3.014,6.72,6.72,6.72C26.805,28.818,29.818,25.805,29.818,22.099z M26.5,21H24v-2.5c0-0.275-0.225-0.5-0.5-0.5h-1c-0.275,0-0.5,0.225-0.5,0.5V21h-2.5c-0.275,0-0.5,0.225-0.5,0.5v1c0,0.275,0.225,0.5,0.5,0.5H22v2.5c0,0.275,0.225,0.5,0.5,0.5h1c0.275,0,0.5-0.225,0.5-0.5V23h2.5c0.275,0,0.5-0.225,0.5-0.5v-1C27,21.225,26.775,21,26.5,21z\"\n        ];\n        return this._createToolbarIcon(paths);\n    }\n\n    _createGridMoreIcon ()\n    {\n        let paths = [\n            \"M29.5,35c-0.275,0-0.5-0.225-0.5-0.5v-5c0-0.275,0.225-0.5,0.5-0.5h5c0.275,0,0.5,0.225,0.5,0.5v5c0,0.275-0.225,0.5-0.5,0.5H29.5z M21.5,35c-0.275,0-0.5-0.225-0.5-0.5v-5c0-0.275,0.225-0.5,0.5-0.5h5c0.275,0,0.5,0.225,0.5,0.5v5c0,0.275-0.225,0.5-0.5,0.5H21.5z M13.5,35c-0.275,0-0.5-0.225-0.5-0.5v-5c0-0.275,0.225-0.5,0.5-0.5h5c0.275,0,0.5,0.225,0.5,0.5v5c0,0.275-0.225,0.5-0.5,0.5H13.5z M29.5,27c-0.275,0-0.5-0.225-0.5-0.5v-5c0-0.275,0.225-0.5,0.5-0.5h5c0.275,0,0.5,0.225,0.5,0.5v5c0,0.275-0.225,0.5-0.5,0.5H29.5z M21.5,27c-0.275,0-0.5-0.225-0.5-0.5v-5c0-0.275,0.225-0.5,0.5-0.5h5c0.275,0,0.5,0.225,0.5,0.5v5c0,0.275-0.225,0.5-0.5,0.5H21.5z M13.5,27c-0.275,0-0.5-0.225-0.5-0.5v-5c0-0.275,0.225-0.5,0.5-0.5h5c0.275,0,0.5,0.225,0.5,0.5v5c0,0.275-0.225,0.5-0.5,0.5H13.5z M29.5,19c-0.275,0-0.5-0.225-0.5-0.5v-5c0-0.275,0.225-0.5,0.5-0.5h5c0.275,0,0.5,0.225,0.5,0.5v5c0,0.275-0.225,0.5-0.5,0.5H29.5z M21.5,19c-0.275,0-0.5-0.225-0.5-0.5v-5c0-0.275,0.225-0.5,0.5-0.5h5c0.275,0,0.5,0.225,0.5,0.5v5c0,0.275-0.225,0.5-0.5,0.5H21.5z M13.5,19c-0.275,0-0.5-0.225-0.5-0.5v-5c0-0.275,0.225-0.5,0.5-0.5h5c0.275,0,0.5,0.225,0.5,0.5v5c0,0.275-0.225,0.5-0.5,0.5H13.5z\"\n        ];\n        return this._createToolbarIcon(paths);\n    }\n\n    _createGridFewerIcon ()\n    {\n        let paths = [\n            \"M25.5,35c-0.275,0-0.5-0.225-0.5-0.5v-9c0-0.275,0.225-0.5,0.5-0.5h9c0.275,0,0.5,0.225,0.5,0.5v9c0,0.275-0.225,0.5-0.5,0.5H25.5z M22.5,35c0.275,0,0.5-0.225,0.5-0.5v-9c0-0.275-0.225-0.5-0.5-0.5h-9c-0.275,0-0.5,0.225-0.5,0.5v9c0,0.275,0.225,0.5,0.5,0.5H22.5z M34.5,23c0.275,0,0.5-0.225,0.5-0.5v-9c0-0.275-0.225-0.5-0.5-0.5h-9c-0.275,0-0.5,0.225-0.5,0.5v9c0,0.275,0.225,0.5,0.5,0.5H34.5z M22.5,23c0.275,0,0.5-0.225,0.5-0.5v-9c0-0.275-0.225-0.5-0.5-0.5h-9c-0.275,0-0.5,0.225-0.5,0.5v9c0,0.275,0.225,0.5,0.5,0.5H22.5z\"\n        ];\n        return this._createToolbarIcon(paths);\n    }\n\n    _createGridViewIcon ()\n    {\n        let paths = [\n            \"M29.5,35c-0.275,0-0.5-0.225-0.5-0.5v-5c0-0.275,0.225-0.5,0.5-0.5h5c0.275,0,0.5,0.225,0.5,0.5v5c0,0.275-0.225,0.5-0.5,0.5H29.5z M21.5,35c-0.275,0-0.5-0.225-0.5-0.5v-5c0-0.275,0.225-0.5,0.5-0.5h5c0.275,0,0.5,0.225,0.5,0.5v5c0,0.275-0.225,0.5-0.5,0.5H21.5z M13.5,35c-0.275,0-0.5-0.225-0.5-0.5v-5c0-0.275,0.225-0.5,0.5-0.5h5c0.275,0,0.5,0.225,0.5,0.5v5c0,0.275-0.225,0.5-0.5,0.5H13.5z M29.5,27c-0.275,0-0.5-0.225-0.5-0.5v-5c0-0.275,0.225-0.5,0.5-0.5h5c0.275,0,0.5,0.225,0.5,0.5v5c0,0.275-0.225,0.5-0.5,0.5H29.5z M21.5,27c-0.275,0-0.5-0.225-0.5-0.5v-5c0-0.275,0.225-0.5,0.5-0.5h5c0.275,0,0.5,0.225,0.5,0.5v5c0,0.275-0.225,0.5-0.5,0.5H21.5z M13.5,27c-0.275,0-0.5-0.225-0.5-0.5v-5c0-0.275,0.225-0.5,0.5-0.5h5c0.275,0,0.5,0.225,0.5,0.5v5c0,0.275-0.225,0.5-0.5,0.5H13.5z M29.5,19c-0.275,0-0.5-0.225-0.5-0.5v-5c0-0.275,0.225-0.5,0.5-0.5h5c0.275,0,0.5,0.225,0.5,0.5v5c0,0.275-0.225,0.5-0.5,0.5H29.5z M21.5,19c-0.275,0-0.5-0.225-0.5-0.5v-5c0-0.275,0.225-0.5,0.5-0.5h5c0.275,0,0.5,0.225,0.5,0.5v5c0,0.275-0.225,0.5-0.5,0.5H21.5z M13.5,19c-0.275,0-0.5-0.225-0.5-0.5v-5c0-0.275,0.225-0.5,0.5-0.5h5c0.275,0,0.5,0.225,0.5,0.5v5c0,0.275-0.225,0.5-0.5,0.5H13.5z\"\n        ];\n        return this._createToolbarIcon(paths);\n    }\n\n    _createBookViewIcon ()\n    {\n        let paths = [\n            \"M35,16.8v-1.323c0,0-2.292-1.328-5.74-1.328c-3.448,0-5.26,1.25-5.26,1.25s-1.813-1.25-5.26-1.25c-3.448,0-5.74,1.328-5.74,1.328V16.8l-1,0.531v0.021v15.687c0,0,4.531-1.578,6.999-1.578c2.468,0,5.001,0.885,5.001,0.885s2.532-0.885,5-0.885c0.306,0,0.643,0.024,1,0.066v4.325l1.531-2.016L33,35.852v-3.72c2,0.43,3,0.906,3,0.906V17.352v-0.021L35,16.8z M23,29.03c-1-0.292-2.584-0.679-3.981-0.679c-2.246,0-3.019,0.404-4.019,0.699V16.634c0,0,1.125-0.699,4.019-0.699c1.694,0,2.981,0.417,3.981,1.126V29.03z M33,29.051c-1-0.295-1.773-0.699-4.02-0.699c-1.396,0-2.981,0.387-3.98,0.679V17.06c1-0.709,2.286-1.126,3.98-1.126c2.895,0,4.02,0.699,4.02,0.699V29.051z\"\n        ];\n        return this._createToolbarIcon(paths);\n    }\n\n    _createPageViewIcon ()\n    {\n        let paths = [\n            \"M29.425,29h4.47L29,33.934v-4.47C29,29.19,29.151,29,29.425,29z M34,14.563V28h-5.569C28.157,28,28,28.196,28,28.47V34H14.497C14.223,34,14,33.71,14,33.437V14.563C14,14.29,14.223,14,14.497,14h18.9C33.672,14,34,14.29,34,14.563z M25.497,26.497C25.497,26.223,25.275,26,25,26h-7c-0.275,0-0.497,0.223-0.497,0.497v1.006C17.503,27.777,17.725,28,18,28h7c0.275,0,0.497-0.223,0.497-0.497V26.497z M30.497,22.497C30.497,22.223,30.275,22,30,22H18c-0.275,0-0.497,0.223-0.497,0.497v1.006C17.503,23.777,17.725,24,18,24h12c0.275,0,0.497-0.223,0.497-0.497V22.497z M30.497,18.497C30.497,18.223,30.275,18,30,18H18c-0.275,0-0.497,0.223-0.497,0.497v1.006C17.503,19.777,17.725,20,18,20h12c0.275,0,0.497-0.223,0.497-0.497V18.497z\"\n        ];\n\n        return this._createToolbarIcon(paths);\n    }\n\n    _createFullscreenIcon ()\n    {\n        let paths = [\n            \"M35,12H13c-0.55,0-1,0.45-1,1v22c0,0.55,0.45,1,1,1h22c0.55,0,1-0.45,1-1V13C36,12.45,35.55,12,35,12z M34,34H14V14h20V34z\",\n            \"M17,21.75v-4.5c0-0.138,0.112-0.25,0.25-0.25h4.5c0.138,0,0.17,0.08,0.073,0.177l-1.616,1.616l1.823,1.823c0.097,0.097,0.097,0.256,0,0.354l-1.061,1.06c-0.097,0.097-0.256,0.097-0.354,0l-1.823-1.823l-1.616,1.616C17.08,21.92,17,21.888,17,21.75z M20.97,25.97c-0.097-0.097-0.256-0.097-0.354,0l-1.823,1.823l-1.616-1.616C17.08,26.08,17,26.112,17,26.25v4.5c0,0.138,0.112,0.25,0.25,0.25h4.5c0.138,0,0.17-0.08,0.073-0.177l-1.616-1.616l1.823-1.823c0.097-0.097,0.097-0.256,0-0.354L20.97,25.97z M30.75,17h-4.5c-0.138,0-0.17,0.08-0.073,0.177l1.616,1.616l-1.823,1.823c-0.097,0.097-0.097,0.256,0,0.354l1.061,1.06c0.097,0.097,0.256,0.097,0.354,0l1.823-1.823l1.616,1.616C30.92,21.92,31,21.888,31,21.75v-4.5C31,17.112,30.888,17,30.75,17z M30.823,26.177l-1.616,1.616l-1.823-1.823c-0.097-0.097-0.256-0.097-0.354,0l-1.061,1.06c-0.097,0.097-0.097,0.256,0,0.354l1.823,1.823l-1.616,1.616C26.08,30.92,26.112,31,26.25,31h4.5c0.138,0,0.25-0.112,0.25-0.25v-4.5C31,26.112,30.92,26.08,30.823,26.177z M26,22.5c0-0.275-0.225-0.5-0.5-0.5h-3c-0.275,0-0.5,0.225-0.5,0.5v3c0,0.275,0.225,0.5,0.5,0.5h3c0.275,0,0.5-0.225,0.5-0.5V22.5z\"\n        ];\n\n        return this._createToolbarIcon(paths);\n    }\n}\n","/**\n * @fileoverview dragscroll - scroll area by dragging\n * @version 0.0.8\n *\n * @license MIT, see http://github.com/asvd/dragscroll\n * @copyright 2015 asvd <heliosframework@gmail.com>\n */\n(function (root, factory)\n{\n    if (typeof define === 'function' && define.amd)\n    {\n        define(['exports'], factory);\n    }\n    else if (typeof exports !== 'undefined')\n    {\n        factory(exports);\n    }\n    else\n    {\n        factory((root.dragscroll = {}));\n    }\n}(this, function (exports)\n{\n    var _window = window;\n    var _document = document;\n    var mousemove = 'mousemove';\n    var mouseup = 'mouseup';\n    var mousedown = 'mousedown';\n    var EventListener = 'EventListener';\n    var addEventListener = 'add' + EventListener;\n    var removeEventListener = 'remove' + EventListener;\n    var newScrollX, newScrollY; // jshint ignore:line\n\n    var dragged = [];\n\n    var reset = function (i, el)\n    {\n        for (i = 0; i < dragged.length;)\n        {\n            el = dragged[i++];\n            el = el.container || el;\n            el[removeEventListener](mousedown, el.md, 0);\n            _window[removeEventListener](mouseup, el.mu, 0);\n            _window[removeEventListener](mousemove, el.mm, 0);\n        }\n\n        // suppress warning about functions in loops.\n        /* jshint ignore:start */\n        // cloning into array since HTMLCollection is updated dynamically\n        dragged = [].slice.call(_document.getElementsByClassName('dragscroll'));\n        for (i = 0; i < dragged.length;)\n        {\n            (function (el, lastClientX, lastClientY, pushed, scroller, cont)\n            {\n                (cont = el.container || el)[addEventListener](\n                    mousedown,\n                    cont.md = function (e)\n                    {\n                        if (!el.hasAttribute('nochilddrag') || _document.elementFromPoint(e.pageX, e.pageY) === cont)\n                        {\n                            pushed = 1;\n                            lastClientX = e.clientX;\n                            lastClientY = e.clientY;\n\n                            e.preventDefault();\n                        }\n                    }, 0\n                );\n\n                _window[addEventListener](mouseup, cont.mu = function ()\n                    {\n                        pushed = 0;\n                    }, 0);\n\n                _window[addEventListener](mousemove, cont.mm = function (e)\n                    {\n                        if (pushed)\n                        {\n                            (scroller = el.scroller || el).scrollLeft -=\n                                newScrollX = (-lastClientX + (lastClientX = e.clientX));\n                            scroller.scrollTop -=\n                                newScrollY = (-lastClientY + (lastClientY = e.clientY));\n                            if (el === _document.body)\n                            {\n                                (scroller = _document.documentElement).scrollLeft -= newScrollX;\n                                scroller.scrollTop -= newScrollY;\n                            }\n                        }\n                    }, 0);\n            })(dragged[i++]);\n        }\n        /* jshint ignore:end */\n    };\n\n    if (_document.readyState === 'complete')\n    {\n        reset();\n    }\n    else\n    {\n        _window[addEventListener]('load', reset, 0);\n    }\n\n    exports.reset = reset;\n    window.resetDragscroll = reset;\n}));\n","export { setDOMAttributes as setAttributes };\n\n/**\n * Convenience function to create a DOM element, set attributes on it, and\n * append children. All arguments which are not of primitive type, are not\n * arrays, and are not DOM nodes are treated as attribute hashes and are\n * handled as described for setDOMAttributes. Children can either be a DOM\n * node or a primitive value, which is converted to a text node. Arrays are\n * handled recursively. Null and undefined values are ignored.\n *\n * Inspired by the ProseMirror helper of the same name.\n */\nexport function elt (tag: string, ...args: any[])\n{\n    const el: HTMLElement = document.createElement(tag);\n\n    while (args.length)\n    {\n        const arg = args.shift();\n        handleEltConstructorArg(el, arg);\n    }\n\n    return el;\n}\n\nfunction handleEltConstructorArg (el: HTMLElement, arg)\n{\n    if (arg == null) // NB: == is correct;\n    {\n        return;\n    }\n\n    if (typeof arg !== 'object' && typeof arg !== 'function')\n    {\n        // Coerce to string\n        el.appendChild(document.createTextNode(arg));\n    }\n    else if (arg instanceof window.Node)\n    {\n        el.appendChild(arg);\n    }\n    else if (arg instanceof Array)\n    {\n        const childCount = arg.length;\n        for (let i = 0; i < childCount; i++)\n        {\n            handleEltConstructorArg(el, arg[i]);\n        }\n    }\n    else\n    {\n        setDOMAttributes(el, arg);\n    }\n}\n\n/**\n * Set attributes of a DOM element. The `style` property is special-cased to\n * accept either a string or an object whose own attributes are assigned to\n * el.style.\n */\nfunction setDOMAttributes (el, attributes)\n{\n    for (const prop in attributes)\n    {\n        if (!attributes.hasOwnProperty(prop))\n        {\n            continue;\n        }\n\n        if (prop === 'style')\n        {\n            setStyle(el, attributes.style);\n        }\n        else\n        {\n            el.setAttribute(prop, attributes[prop]);\n        }\n    }\n}\n\nfunction setStyle (el, style)\n{\n    if (!style)\n    {\n        return;\n    }\n\n    if (typeof style !== 'object')\n    {\n        el.style.cssText = style;\n        return;\n    }\n\n    for (const cssProp in style)\n    {\n        if (!style.hasOwnProperty(cssProp))\n        {\n            continue;\n        }\n\n        el.style[cssProp] = style[cssProp];\n    }\n}\n","/**\n * Events. Pub/Sub system for Loosely Coupled logic.\n * Based on Peter Higgins' port from Dojo to jQuery\n * https://github.com/phiggins42/bloody-jquery-plugins/blob/master/pubsub.js\n *\n * Re-adapted to vanilla Javascript\n *\n * @class Events\n */\n\nclass DivaEvents\n{\n    _cache: Record<string, any>;\n\n    constructor()\n    {\n        this._cache = {};\n    }\n\n    /**\n     * diva.Events.publish\n     * e.g.: diva.Events.publish(\"PageDidLoad\", [pageIndex, filename, pageSelector], this);\n     *\n     * @class Events\n     * @method publish\n     * @param topic {String}\n     * @param args  {Array}\n     * @param scope {Object=} Optional - Subscribed functions will be executed with the supplied object as `this`.\n     *     It is necessary to supply this argument with the self variable when within a Diva instance.\n     *     The scope argument is matched with the instance ID of subscribers to determine whether they\n     *         should be executed. (See instanceID argument of subscribe.)\n     */\n    publish(topic: string, args: any[], scope: any)\n    {\n        if (this._cache[topic])\n        {\n            const thisTopic = this._cache[topic];\n\n            if (typeof thisTopic.global !== 'undefined')\n            {\n                const thisTopicGlobal = thisTopic.global;\n                const globalCount = thisTopicGlobal.length;\n\n                for (let i=0; i < globalCount; i++)\n                {\n                    thisTopicGlobal[i].apply(scope || null, args || []);\n                }\n            }\n\n            if (scope && typeof scope.getInstanceId !== 'undefined')\n            {\n                // get publisher instance ID from scope arg, compare, and execute if match\n                const instanceID = scope.getInstanceId();\n\n                if (this._cache[topic][instanceID])\n                {\n                    const thisTopicInstance = this._cache[topic][instanceID];\n                    const scopedCount = thisTopicInstance.length;\n\n                    for (let j=0; j < scopedCount; j++)\n                    {\n                        thisTopicInstance[j].apply(scope, args || []);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * diva.Events.subscribe\n     * e.g.: diva.Events.subscribe(\"PageDidLoad\", highlight, settings.ID)\n     *\n     * @class Events\n     * @method subscribe\n     * @param {string} topic\n     * @param {function} callback\n     * @param {string=} instanceID  Optional - String representing the ID of a Diva instance; if provided,\n     *                                       callback only fires for events published from that instance.\n     * @return Event handler {Array}\n     */\n    subscribe(topic: string, callback: any, instanceID?: string | null): [string, any, string?]\n    {\n        if (!this._cache[topic])\n        {\n            this._cache[topic] = {};\n        }\n\n        if (typeof instanceID === 'string')\n        {\n            if (!this._cache[topic][instanceID])\n            {\n                this._cache[topic][instanceID] = [];\n            }\n\n            this._cache[topic][instanceID].push(callback);\n        }\n        else\n        {\n            if (!this._cache[topic].global)\n            {\n                this._cache[topic].global = [];\n            }\n\n            this._cache[topic].global.push(callback);\n        }\n\n        return instanceID ? [topic, callback, instanceID] : [topic, callback];\n    }\n\n    /**\n     * diva.Events.unsubscribe\n     * e.g.: var handle = Events.subscribe(\"PageDidLoad\", highlight);\n     *         Events.unsubscribe(handle);\n     *\n     * @class Events\n     * @method unsubscribe\n     * @param {array} handle\n     * @param {boolean=} completely - Unsubscribe all events for a given topic.\n     * @return {boolean} success\n     */\n    unsubscribe(handle: Array<any>, completely?: boolean): boolean\n    {\n        const t = handle[0];\n\n        if (this._cache[t])\n        {\n            let topicArray;\n            const instanceID = handle.length === 3 ? handle[2] : 'global';\n\n            topicArray = this._cache[t][instanceID];\n\n            if (!topicArray)\n            {\n                return false;\n            }\n\n            if (completely)\n            {\n                delete this._cache[t][instanceID];\n                return topicArray.length > 0;\n            }\n\n            let i = topicArray.length;\n\n            while (i--)\n            {\n                if (topicArray[i] === handle[1])\n                {\n                    this._cache[t][instanceID].splice(i, 1);\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * diva.Events.unsubscribeAll\n     * e.g.: diva.Events.unsubscribeAll('global');\n     *\n     * @class Events\n     * @param {string=} instanceID Optional - instance ID to remove subscribers from or 'global' (if omitted,\n     *                              subscribers in all scopes removed)\n     * @method unsubscribeAll\n     */\n    unsubscribeAll(instanceID: string): void\n    {\n        if (instanceID)\n        {\n            const topics = Object.keys(this._cache);\n            let i = topics.length;\n            let topic;\n\n            while (i--)\n            {\n                topic = topics[i]!;\n\n                if (typeof this._cache[topic][instanceID] !== 'undefined')\n                {\n                    delete this._cache[topic][instanceID];\n                }\n            }\n        }\n        else\n        {\n            this._cache = {};\n        }\n    }\n}\n\nexport let Events = new DivaEvents();\n","// From http://www.alexandre-gomes.com/?p=115, modified slightly\nexport default function getScrollbarWidth()\n{\n    let inner: HTMLParagraphElement = document.createElement('p');\n    inner.style.width = '100%';\n    inner.style.height = '200px';\n\n    let outer: HTMLDivElement = document.createElement('div');\n    outer.style.position = 'absolute';\n    outer.style.top = '0px';\n    outer.style.left = '0px';\n    outer.style.visibility = 'hidden';\n    outer.style.width = '200px';\n    outer.style.height = '150px';\n    outer.style.overflow = 'hidden';\n    outer.appendChild(inner);\n\n    document.body.appendChild(outer);\n\n    let w1 = inner.offsetWidth;\n    outer.style.overflow = 'scroll';\n    let w2 = inner.offsetWidth;\n    if (w1 === w2)\n    {\n        w2 = outer.clientWidth; // for IE i think\n    }\n\n    document.body.removeChild(outer);\n    return w1 - w2;\n}\n","let HashParams = {\n    get: getHashParam,\n    update: updateHashParam\n};\n\nexport default HashParams;\n\n\n// For getting the #key values from the URL. For specifying a page and zoom level\n// Look into caching, because we only need to get this during the initial load\n// Although for the tests I guess we would need to override caching somehow\nfunction getHashParam (key: string): string | false\n{\n    const hash = window.location.hash;\n\n    if (hash !== '')\n    {\n        // Check if there is something that looks like either &key= or #key=\n        let startIndex = (hash.indexOf('&' + key + '=') > 0) ? hash.indexOf('&' + key + '=') : hash.indexOf('#' + key + '=');\n\n        // If startIndex is still -1, it means it can't find either\n        if (startIndex >= 0)\n        {\n            // Add the length of the key plus the & and =\n            startIndex += key.length + 2;\n\n            // Either to the next ampersand or to the end of the string\n            const endIndex = hash.indexOf('&', startIndex);\n            if (endIndex > startIndex)\n            {\n                return decodeURIComponent(hash.substring(startIndex, endIndex));\n            }\n            else if (endIndex < 0)\n            {\n                // This means this hash param is the last one\n                return decodeURIComponent(hash.substring(startIndex));\n            }\n            // If the key doesn't have a value I think\n            return '';\n        }\n        else\n        {\n            // If it can't find the key\n            return false;\n        }\n    }\n    else\n    {\n        // If there are no hash params just return false\n        return false;\n    }\n}\n\nfunction updateHashParam (key: string, value: string)\n{\n    // First make sure that we have to do any work at all\n    const originalValue = getHashParam(key);\n    const hash = window.location.hash;\n\n    if (originalValue !== value)\n    {\n        // Is the key already in the URL?\n        if (typeof originalValue === 'string')\n        {\n            // Already in the URL. Just get rid of the original value\n            const startIndex = (hash.indexOf('&' + key + '=') > 0) ? hash.indexOf('&' + key + '=') : hash.indexOf('#' + key + '=');\n            const endIndex = startIndex + key.length + 2 + originalValue.length;\n            // # if it's the first, & otherwise\n            const startThing = (startIndex === 0) ? '#' : '&';\n            window.location.replace(hash.substring(0, startIndex) + startThing + key + '=' + value + hash.substring(endIndex));\n        }\n        else\n        {\n            // It's not present - add it\n            if (hash.length === 0)\n            {\n                window.location.replace('#' + key + '=' + value);\n            }\n            else\n            {\n                // Append it\n                window.location.replace(hash + '&' + key + '=' + value);\n            }\n        }\n    }\n}\n","function getTag(value: null | any): string\n{\n    if (value == null)\n    {\n        return value === undefined ? '[object Undefined]' : '[object Null]'\n    }\n    return toString.call(value)\n}\n\nfunction isSymbol(value: null | any): boolean\n{\n    const type = typeof value;\n    return (\n        type === 'symbol' ||\n        (type === 'object' && value != null && getTag(value) === '[object Symbol]')\n    );\n}\n\nexport function maxBy(array: null | Array<any>, iteratee: (arg0: any) => any)\n{\n    let result;\n    if (array == null)\n    {\n        return result;\n    }\n    let computed;\n    for (const value of array)\n    {\n        const current = iteratee(value);\n\n        if (\n            current != null &&\n            (computed === undefined\n                ? current === current && !isSymbol(current)\n                : current > computed)\n        )\n        {\n            computed = current;\n            result = value;\n        }\n    }\n    return result;\n}\n","/**\n * Parses a v3 manifest's label/value pair from an object & array to a string\n *\n * @public\n * @params {string} key - The key from which a label/value pair should be extracted.\n * @returns {object} - The label/value pair as strings.\n * */\n\nexport default function parseLabelValue (key: {label: string, value: any}): object\n{\n    let l = key.label; \n    let label = (typeof l === 'object') ? l[Object.keys(l)[0]][0] : l;\n\n    let v = key.value;\n    let value;\n    if (Array.isArray(v))\n    { // is array of objects\n        value = v.map(e => e[Object.keys(e)[0]]);\n    }\n    else\n    { // is object where value is possibly an array\n        value = (typeof v === 'object') ? v[Object.keys(v)[0]] : v;\n    }\n\n    if (Array.isArray(value))\n    {\n        value = value.join(', ');\n    }\n\n    return {\n        label: label,\n        value: value\n    };\n}\n","/*\n The MIT License (MIT)\n Copyright (c) <2011> <Dave Taylor http://the-taylors.org>\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is furnished\n to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n Port to vanilla Javascript by Jacek Nowacki http://jacek-nowacki.net/\n**/\n\n(function() {\n    var _raf = window.requestAnimationFrame;\n\n    var _isTouch = 'ontouchend' in document;\n\n    // this is simple, no \"deep\" support\n    var _extend = function() {\n        for (var i=1; i<arguments.length; i++) {\n            for (var key in arguments[i]) {\n                if (arguments[i].hasOwnProperty(key)) {\n                    arguments[0][key] = arguments[i][key];\n                }\n            }\n        }\n        return arguments[0];\n    };\n\n    var VanillaKinetic = function(element, settings) {\n        this.settings = _extend({}, VanillaKinetic.DEFAULTS, settings);\n        this.el       = element;\n        this.ACTIVE_CLASS = \"kinetic-active\";\n\n        this._initElements();\n\n        this.el._VanillaKinetic = this;\n        return this;\n    };\n\n    VanillaKinetic.DEFAULTS = {\n        cursor: 'move',\n        decelerate: true,\n        triggerHardware: false,\n        threshold: 0,\n        y: true,\n        x: true,\n        slowdown: 0.9,\n        maxvelocity: 40,\n        throttleFPS: 60,\n        invert: false,\n        movingClass: {\n            up: 'kinetic-moving-up',\n            down: 'kinetic-moving-down',\n            left: 'kinetic-moving-left',\n            right: 'kinetic-moving-right'\n        },\n        deceleratingClass: {\n            up: 'kinetic-decelerating-up',\n            down: 'kinetic-decelerating-down',\n            left: 'kinetic-decelerating-left',\n            right: 'kinetic-decelerating-right'\n        }\n    };\n\n    // Public functions\n    VanillaKinetic.prototype.start = function(options) {\n        this.settings = _extend(this.settings, options);\n        this.velocity = options.velocity || this.velocity;\n        this.velocityY = options.velocityY || this.velocityY;\n        this.settings.decelerate = false;\n        this._move();\n    };\n\n    VanillaKinetic.prototype.end = function() {\n        this.settings.decelerate = true;\n    };\n\n    VanillaKinetic.prototype.stop = function() {\n        this.velocity = 0;\n        this.velocityY = 0;\n        this.settings.decelerate = true;\n        if (typeof this.settings.stopped === 'function') {\n            this.settings.stopped.call(this);\n        }\n    };\n\n    VanillaKinetic.prototype.detach = function() {\n        this._detachListeners();\n        this.el.classList.remove(this.ACTIVE_CLASS);\n        this.el.style.cursor = '';\n    };\n\n    VanillaKinetic.prototype.attach = function() {\n        if (this.el.classList.contains(this.ACTIVE_CLASS)) {\n            return;\n        }\n        this._attachListeners();\n        this.el.classList.add(this.ACTIVE_CLASS);\n        this.el.style.cursor = this.settings.cursor;\n    };\n\n    // Internal functions\n\n    VanillaKinetic.prototype._initElements = function() {\n        this.el.classList.add(this.ACTIVE_CLASS);\n\n        _extend(this, {\n            xpos: null,\n            prevXPos: false,\n            ypos: null,\n            prevYPos: false,\n            mouseDown: false,\n            throttleTimeout: 1000 / this.settings.throttleFPS,\n            lastMove: null,\n            elementFocused: null\n        });\n\n        this.velocity = 0;\n        this.velocityY = 0;\n\n        var that = this;\n        this.documentResetHandler = function() {\n            that._resetMouse.apply(that);\n        };\n\n        // FIXME make sure to remove this\n        var html = document.documentElement;\n        html.addEventListener(\"mouseup\", this.documentResetHandler, false);\n        html.addEventListener(\"click\", this.documentResetHandler, false);\n\n        this._initEvents();\n\n        this.el.style.cursor = this.settings.cursor;\n\n        if (this.settings.triggerHardware) {\n            var prefixes = ['', '-ms-', '-webkit-', '-moz-'];\n            var styles = {\n                'transform': 'translate3d(0,0,0)',\n                'perspective': '1000', // TODO is this even valid? is this even needed?\n                'backface-visibility': 'hidden'\n            };\n            for (var i=0; i<prefixes.length; i++) {\n                var prefix = prefixes[i];\n                for (var key in styles) {\n                    if (styles.hasOwnProperty(key)){\n                        this.el.style[prefix+key] = styles[key];\n                    }\n                }\n            }\n        }\n    };\n\n    VanillaKinetic.prototype._initEvents = function() {\n        var self = this;\n        this.settings.events = {\n            touchStart: function(e) {\n                var touch;\n                if (self._useTarget(e.target, e)) {\n                    touch = e.originalEvent.touches[0];\n                    self.threshold = self._threshold(e.target, e);\n                    self._start(touch.clientX, touch.clientY);\n                    e.stopPropagation();\n                }\n            },\n            touchMove: function(e) {\n                var touch;\n                if (self.mouseDown) {\n                    touch = e.originalEvent.touches[0];\n                    self._inputmove(touch.clientX, touch.clientY);\n                    if (e.preventDefault) {\n                        e.preventDefault();\n                    }\n                }\n            },\n            inputDown: function(e) {\n                if (self._useTarget(e.target, e)) {\n                    self.threshold = self._threshold(e.target, e);\n                    self._start(e.clientX, e.clientY);\n                    self.elementFocused = e.target;\n                    if (e.target.nodeName === \"IMG\") {\n                        e.preventDefault();\n                    }\n                    e.stopPropagation();\n                }\n            },\n            inputEnd: function(e) {\n                if (self._useTarget(e.target, e)) {\n                    self._end();\n                    self.elementFocused = null;\n                    if (e.preventDefault) {\n                        e.preventDefault();\n                    }\n                }\n            },\n            inputMove: function(e) {\n                if (self.mouseDown) {\n                    self._inputmove(e.clientX, e.clientY);\n                    if (e.preventDefault) {\n                        e.preventDefault();\n                    }\n                }\n            },\n            scroll: function(e) {\n                if (typeof self.settings.moved === 'function') {\n                    self.settings.moved.call(self, self.settings);\n                }\n                if (e.preventDefault) {\n                    e.preventDefault();\n                }\n            },\n            inputClick: function(e) {\n                if (Math.abs(self.velocity) > 0 || Math.abs(self.velocityY) > 0) {\n                    e.preventDefault();\n                    if (e.stopPropagation) {\n                        e.stopPropagation();\n                    }\n                    return false;\n                }\n            },\n            dragStart: function(e) {\n                if (self._useTarget(e.target, e) && self.elementFocused) {\n                    if (e.preventDefault) {\n                        e.preventDefault();\n                    }\n                    if (e.stopPropagation) {\n                        e.stopPropagation();\n                    }\n                    return false;\n                }\n            },\n            selectStart: function(e) {\n                if (typeof self.settings.selectStart === 'function') {\n                    return self.settings.selectStart.apply(self, arguments);\n                }\n                else if (self._useTarget(e.target, e)) {\n                    if (e.preventDefault) {\n                        e.preventDefault();\n                    }\n                    if (e.stopPropagation) {\n                        e.stopPropagation();\n                    }\n                    return false;\n                }\n            }\n        };\n\n        this._attachListeners();\n    };\n\n    VanillaKinetic.prototype._inputmove = function(clientX, clientY) {\n        if (!this.lastMove || new Date() > new Date(this.lastMove.getTime() + this.throttleTimeout)) {\n            this.lastMove = new Date();\n\n            if (this.mouseDown && (this.xpos || this.ypos)) {\n                var movedX = (clientX - this.xpos);\n                var movedY = (clientY - this.ypos);\n                if (this.settings.invert) {\n                    movedX *= -1;\n                    movedY *= -1;\n                }\n                if (this.threshold>0) {\n                    var moved = Math.sqrt(movedX*movedX + movedY*movedY);\n                    if (this.threshold>moved) {\n                        return;\n                    }\n                    else {\n                        this.threshold = 0;\n                    }\n                }\n                if (this.elementFocused) {\n                    this.elementFocused.blur();\n                    this.elementFocused = null;\n                    this.el.focus();\n                }\n\n                this.settings.decelerate = false;\n                this.velocity = this.velocityY = 0;\n\n                var scrollLeft = this.scrollLeft();\n                var scrollTop = this.scrollTop();\n\n                this.scrollLeft(this.settings.x ? scrollLeft - movedX : scrollLeft);\n                this.scrollTop(this.settings.y ? scrollTop - movedY : scrollTop);\n\n                this.prevXPos = this.xpos;\n                this.prevYPos = this.ypos;\n                this.xpos = clientX;\n                this.ypos = clientY;\n\n                this._calculateVelocities();\n                this._setMoveClasses(this.settings.movingClass);\n\n                if (typeof this.settings.moved === 'function') {\n                    this.settings.moved.call(this, this.settings);\n                }\n            }\n        }\n    };\n\n    VanillaKinetic.prototype._calculateVelocities = function() {\n        this.velocity = this._capVelocity(this.prevXPos - this.xpos, this.settings.maxvelocity);\n        this.velocityY = this._capVelocity(this.prevYPos - this.ypos, this.settings.maxvelocity);\n        if (this.settings.invert) {\n            this.velocity *= -1;\n            this.velocityY *= -1;\n        }\n    };\n\n    VanillaKinetic.prototype._end = function() {\n        if (this.xpos && this.prevXPos && this.settings.decelerate === false) {\n            this.settings.decelerate = true;\n            this._calculateVelocities();\n            this.xpos = this.prevXPos = this.mouseDown = false;\n            this._move();\n        }\n    };\n\n    VanillaKinetic.prototype._useTarget = function(target, event) {\n        if (typeof this.settings.filterTarget === 'function') {\n            return this.settings.filterTarget.call(this, target, event) !== false;\n        }\n        return true;\n\n    };\n\n    VanillaKinetic.prototype._threshold = function(target, event) {\n        if (typeof this.settings.threshold === 'function') {\n            return this.settings.threshold.call(this, target, event);\n        }\n        return this.settings.threshold;\n    };\n\n    VanillaKinetic.prototype._start = function(clientX, clientY) {\n        this.mouseDown = true;\n        this.velocity = this.prevXPos = 0;\n        this.velocityY = this.prevYPos = 0;\n        this.xpos = clientX;\n        this.ypos = clientY;\n    };\n\n    VanillaKinetic.prototype._resetMouse = function() {\n        this.xpos = false;\n        this.ypos = false;\n        this.mouseDown = false;\n    };\n\n    VanillaKinetic.prototype._decelerateVelocity = function(velocity, slowdown) {\n        return Math.floor(Math.abs(velocity)) === 0 ? 0 // is velocity less than 1?\n            : velocity * slowdown; // reduce slowdown\n    };\n\n    VanillaKinetic.prototype._capVelocity = function(velocity, max) {\n        var newVelocity = velocity;\n        if (velocity > 0){\n            if (velocity > max){\n                newVelocity = max;\n            }\n        } else {\n            if (velocity < (0 - max)){\n                newVelocity = (0 - max);\n            }\n        }\n        return newVelocity;\n    };\n\n    VanillaKinetic.prototype._setMoveClasses = function(classes) {\n        // The fix-me comment below is from original jQuery.kinetic project\n        // FIXME: consider if we want to apply PL #44, this should not remove\n        // classes we have not defined on the element!\n        var settings = this.settings;\n        var el = this.el;\n\n        el.classList.remove(settings.movingClass.up);\n        el.classList.remove(settings.movingClass.down);\n        el.classList.remove(settings.movingClass.left);\n        el.classList.remove(settings.movingClass.right);\n        el.classList.remove(settings.deceleratingClass.up);\n        el.classList.remove(settings.deceleratingClass.down);\n        el.classList.remove(settings.deceleratingClass.left);\n        el.classList.remove(settings.deceleratingClass.right);\n\n        if (this.velocity > 0){\n            el.classList.add(classes.right);\n        }\n        if (this.velocity < 0){\n            el.classList.add(classes.left);\n        }\n        if (this.velocityY > 0){\n            el.classList.add(classes.down);\n        }\n        if (this.velocityY < 0){\n            el.classList.add(classes.up);\n        }\n    };\n\n    VanillaKinetic.prototype._move = function() {\n        var scroller = this._getScroller();\n        var self = this;\n        var settings = this.settings;\n\n        if (settings.x && scroller.scrollWidth > 0) {\n            this.scrollLeft(this.scrollLeft() + this.velocity);\n            if (Math.abs(this.velocity) > 0) {\n                this.velocity = settings.decelerate ?\n                    self._decelerateVelocity(this.velocity, settings.slowdown) : this.velocity;\n            }\n        }\n        else {\n            this.velocity = 0;\n        }\n\n        if (settings.y && scroller.scrollHeight > 0){\n            this.scrollTop(this.scrollTop() + this.velocityY);\n            if (Math.abs(this.velocityY) > 0){\n                this.velocityY = settings.decelerate ?\n                    self._decelerateVelocity(this.velocityY, settings.slowdown) : this.velocityY;\n            }\n        }\n        else {\n            this.velocityY = 0;\n        }\n\n        self._setMoveClasses(settings.deceleratingClass);\n\n        if (typeof settings.moved === 'function'){\n            settings.moved.call(this, settings);\n        }\n\n        if (Math.abs(this.velocity) > 0 || Math.abs(this.velocityY) > 0){\n            if (!this.moving) {\n                this.moving = true;\n                // tick for next movement\n                _raf(function() {\n                    self.moving = false;\n                    self._move();\n                });\n            }\n        }\n        else {\n            self.stop();\n        }\n    };\n\n    VanillaKinetic.prototype._getScroller = function() {\n        // FIXME we may want to normalize behaviour across browsers as in original jQuery.kinetic\n        // currently this won't work correctly on all brwosers when attached to html or body element\n        return this.el;\n    };\n\n    VanillaKinetic.prototype.scrollLeft = function(left) {\n        var scroller = this._getScroller();\n        if (typeof left === 'number') {\n            scroller.scrollLeft = left;\n            this.settings.scrollLeft = left;\n        }\n        else {\n            return scroller.scrollLeft;\n        }\n    };\n\n    VanillaKinetic.prototype.scrollTop = function(top) {\n        var scroller = this._getScroller();\n        if (typeof top === 'number') {\n            scroller.scrollTop = top;\n            this.settings.scrollTop = top;\n        }\n        else {\n            return scroller.scrollTop;\n        }\n    };\n\n    VanillaKinetic.prototype._attachListeners = function() {\n        var el = this.el;\n        var settings = this.settings;\n\n        if (_isTouch) {\n            el.addEventListener('touchstart', settings.events.touchStart, false);\n            el.addEventListener('touchend', settings.events.inputEnd, false);\n            el.addEventListener('touchmove', settings.events.touchMove, false);\n        }\n\n        el.addEventListener('mousedown', settings.events.inputDown, false);\n        el.addEventListener('mouseup', settings.events.inputEnd, false);\n        el.addEventListener('mousemove', settings.events.inputMove, false);\n\n        el.addEventListener('click', settings.events.inputClick, false);\n        el.addEventListener('scroll', settings.events.scroll, false);\n        el.addEventListener('selectstart', settings.events.selectStart, false);\n        el.addEventListener('dragstart', settings.events.dragStart, false);\n    };\n\n    VanillaKinetic.prototype._detachListeners = function() {\n        var el = this.el;\n        var settings = this.settings;\n\n        if (_isTouch) {\n            el.removeEventListener('touchstart', settings.events.touchStart, false);\n            el.removeEventListener('touchend', settings.events.inputEnd, false);\n            el.removeEventListener('touchmove', settings.events.touchMove, false);\n        }\n\n        el.removeEventListener('mousedown', settings.events.inputDown, false);\n        el.removeEventListener('mouseup', settings.events.inputEnd, false);\n        el.removeEventListener('mousemove', settings.events.inputMove, false);\n\n        el.removeEventListener('click', settings.events.inputClick, false);\n        el.removeEventListener('scroll', settings.events.scroll, false);\n        el.removeEventListener('selectstart', settings.events.selectStart, false);\n        el.removeEventListener('dragstart', settings.events.dragStart, false);\n    };\n\n\n    window.VanillaKinetic = VanillaKinetic;\n})();\n","import {ActiveViewOptions, MergedConfiguration, Options, OptionsValidator, ValidationOptions} from \"./options-settings\";\n\nexport default class ValidationRunner\n{\n    whitelistedKeys: Array<any>;\n    additionalProperties: Array<any>;\n    validations: OptionsValidator[];\n\n    constructor(options: ValidationOptions)\n    {\n        this.whitelistedKeys = options.whitelistedKeys || [];\n        this.additionalProperties = options.additionalProperties || [];\n        this.validations = options.validations;\n    }\n\n    isValid(key: string, value: any, settings: Options): boolean\n    {\n        // Get the validation index\n        let validationIndex = null;\n\n        this.validations.some((validation: { key: string; }, index: any): boolean =>\n        {\n            if (validation.key !== key)\n            {\n                return false;\n            }\n\n            validationIndex = index;\n            return true;\n        });\n\n        if (validationIndex === null)\n        {\n            return true;\n        }\n\n        // Run the validation\n        const dummyChanges: Record<string, any> = {};\n        dummyChanges[key] = value;\n        const proxier = createSettingsProxier(settings, dummyChanges, this);\n\n        return !this._runValidation(validationIndex, value, proxier);\n    }\n\n    validate(settings: Options)\n    {\n        this._validateOptions({}, settings);\n    }\n\n    getValidatedOptions(settings: MergedConfiguration, options: ActiveViewOptions): ActiveViewOptions\n    {\n        const cloned = Object.assign({}, options);\n        this._validateOptions(settings, cloned);\n        return cloned;\n    }\n\n    _validateOptions (settings: any, options: ActiveViewOptions)\n    {\n        const settingsProxier = createSettingsProxier(settings, options, this);\n        this._applyValidations(options, settingsProxier);\n    }\n\n    _applyValidations (options: ActiveViewOptions, proxier: { proxy: {}; index: null; })\n    {\n        this.validations.forEach((validation: { key: PropertyKey; }, index: any) =>\n        {\n            if (!options.hasOwnProperty(validation.key))\n            {\n                return;\n            }\n\n            const input = options[validation.key];\n            const corrected = this._runValidation(index, input, proxier);\n\n            if (corrected)\n            {\n                if (!corrected.warningSuppressed)\n                {\n                    emitWarning(validation.key, input, corrected.value);\n                }\n\n                options[validation.key] = corrected.value;\n            }\n        }, this);\n    }\n\n    _runValidation (index: string | number, input: any, proxier: { proxy: any; index: any; })\n    {\n        const validation = this.validations[index];\n\n        proxier.index = index;\n\n        let warningSuppressed = false;\n        const config = {\n            suppressWarning: () =>\n            {\n                warningSuppressed = true;\n            }\n        };\n\n        const outputValue = validation.validate(input, proxier.proxy, config);\n\n        if (outputValue === undefined || outputValue === input)\n        {\n            return null;\n        }\n\n        return {\n            value: outputValue,\n            warningSuppressed: warningSuppressed\n        };\n    }\n}\n\n// @ts-ignore\n// @ts-ignore\n/**\n * The settings proxy wraps the settings object and ensures that\n * only values which have previously been validated are accessed,\n * throwing a TypeError otherwise.\n *\n * FIXME(wabain): Is it worth keeping this? When I wrote it I had\n * multiple validation stages and it was a lot harder to keep track\n * of everything, so this was more valuable.\n */\nfunction createSettingsProxier (settings: any, options: ActiveViewOptions | Record<string, any>, runner: ValidationRunner)\n{\n    const proxier = {\n        proxy: {},\n        index: null\n    };\n\n    const lookup = lookupValue.bind(null, settings, options);\n\n    const properties = {};\n\n    runner.whitelistedKeys.forEach((whitelisted: string | number) =>\n    {\n        properties[whitelisted] = {\n            get: lookup.bind(null, whitelisted)\n        };\n    });\n\n    runner.additionalProperties.forEach((additional: { key: string | number; get: any; }) =>\n    {\n        properties[additional.key] = {\n            get: additional.get\n        };\n    });\n\n    runner.validations.forEach( (validation: { key: string; }, validationIndex: number) =>\n    {\n        properties[validation.key] = {\n            get: () =>\n            {\n                if (validationIndex < proxier.index)\n                {\n                    return lookup(validation.key);\n                }\n\n                const currentKey = runner.validations[proxier.index].key;\n                throw new TypeError('Cannot access setting ' + validation.key + ' while validating ' + currentKey);\n            }\n        };\n    });\n\n    Object.defineProperties(proxier.proxy, properties);\n\n    return proxier;\n}\n\nfunction emitWarning (key: PropertyKey, original: string, corrected: string)\n{\n    console.warn('Invalid value for ' + (key as string) + ': ' + original + '. Using ' + corrected + ' instead.');\n}\n\nfunction lookupValue (base: { [x: string]: any; }, extension: { [x: string]: any; }, key: string)\n{\n    if (key in extension)\n    {\n        return extension[key];\n    }\n\n    return base[key];\n}\n","import { elt } from './utils/elt';\nimport getScrollbarWidth from './utils/get-scrollbar-width';\nimport gestureEvents from './gesture-events';\nimport globalDiva from './diva-global';\nimport DocumentHandler from './document-handler';\nimport GridHandler from './grid-handler';\nimport PageOverlayManager from './page-overlay-manager';\nimport Renderer from './renderer';\nimport getPageLayouts from './page-layouts';\nimport ValidationRunner from './validation-runner';\nimport Viewport from './viewport';\nimport {\n    ViewerSettings,\n    Options,\n    MergedConfiguration,\n    RendererSettings,\n    RendererLoadConfig,\n    RendererViewportPosition, OptionsValidator, PageRegionOptions, ActiveViewOptions\n} from \"./options-settings\";\nimport {\n    Dimension,\n    DivaTiledPage,\n    Offset,\n    PaddingDefinitions,\n    PageInfo,\n    PagePosition, Region,\n    SourceProvider, ViewportSize\n} from \"./viewer-type-definitions\";\nimport PageToolsOverlay from \"./page-tools-overlay\";\nimport ImageManifest from \"./image-manifest\";\nimport divaGlobal from \"./diva-global\";\n\n\n\nconst debug = require('debug')('diva:ViewerCore');\n\nfunction generateId(): number {\n    return generateId.counter++;\n}\ngenerateId.counter = 1;\n\nfunction createSettingsView(sources: Array<object>): MergedConfiguration\n{\n    const obj = {};\n\n    sources.forEach( (source) =>\n    {\n        registerMixin(obj, source);\n    });\n\n    // @ts-ignore\n    return obj;\n}\n\nfunction registerMixin(obj: {}, mixin: Record<string, any>)\n{\n    Object.keys(mixin).forEach( (key: string) =>\n    {\n        Object.defineProperty(obj, key, {\n            get: () =>\n            {\n                return mixin[key];\n            },\n            set: () =>\n            {\n                // TODO: Make everything strict mode so this isn't needed\n                throw new TypeError('Cannot set settings.' + key);\n            }\n        });\n    });\n}\n\nfunction arraysEqual (a: Array<any>, b:Array<any>): boolean\n{\n    if (a.length !== b.length)\n    {\n        return false;\n    }\n\n    for (let i = 0, len = a.length; i < len; i++)\n    {\n        if (a[i] !== b[i])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Define validations\nconst optionsValidations: OptionsValidator[] = [\n    {\n        key: 'goDirectlyTo',\n        validate: (value: number, settings: MergedConfiguration) =>\n        {\n            if (value < 0 || value >= settings.manifest!.pages.length)\n            {\n                return 0;\n            }\n            return value;\n        }\n    },\n    {\n        key: 'minPagesPerRow',\n        validate: (value: number) =>\n        {\n            return Math.max(2, value);\n        }\n    },\n    {\n        key: 'maxPagesPerRow',\n        validate: (value: number, settings: MergedConfiguration) =>\n        {\n            return Math.max(value, settings.minPagesPerRow);\n        }\n    },\n    {\n        key: 'pagesPerRow',\n        validate: (value: number, settings: MergedConfiguration) =>\n        {\n            // Default to the maximum\n            if (value < settings.minPagesPerRow || value > settings.maxPagesPerRow)\n            {\n                return settings.maxPagesPerRow;\n            }\n            return value\n        }\n    },\n    {\n        key: 'maxZoomLevel',\n        validate: (value: number, settings: MergedConfiguration, config: any) =>\n        {\n            // Changing this value isn't really an error, it just depends on the\n            // source manifest\n            config.suppressWarning();\n\n            if (value < 0 || value > settings.manifest!.maxZoom)\n            {\n                return settings.manifest!.maxZoom;\n            }\n            return value;\n        }\n    },\n    {\n        key: 'minZoomLevel',\n        validate: (value: number, settings: MergedConfiguration, config: any) =>\n        {\n            // Changes based on the manifest value shouldn't trigger a\n            // warning\n            if (value > settings.manifest!.maxZoom)\n            {\n                config.suppressWarning();\n                return 0;\n            }\n\n            if (value < 0 || value > settings.maxZoomLevel)\n            {\n                return 0;\n            }\n            return value;\n        }\n    },\n    {\n        key: 'zoomLevel',\n        validate: (value: number, settings: MergedConfiguration, config: any) =>\n        {\n            if (value > settings.manifest!.maxZoom)\n            {\n                config.suppressWarning();\n                return 0;\n            }\n\n            if (value < settings.minZoomLevel || value > settings.maxZoomLevel)\n            {\n                return settings.minZoomLevel;\n            }\n            return value;\n        }\n    }\n];\n\nexport default class ViewerCore\n{\n    parentObject: HTMLElement;\n    publicInstance: any;\n    viewerState: ViewerSettings;\n    settings: MergedConfiguration;\n    optionsValidator: ValidationRunner;\n    boundScrollFunction: any;\n    boundEscapeListener: any;\n\n    constructor (element: HTMLElement, options: Options, publicInstance: any)\n    {\n        this.parentObject = element;\n        this.publicInstance = publicInstance;\n\n        // Things that cannot be changed because of the way they are used by the script\n        // Many of these are declared with arbitrary values that are changed later on\n        this.viewerState = {\n            currentPageIndices: [],    // The visible pages in the viewport\n            activePageIndex: 0,         // The current 'active' page in the viewport\n            horizontalOffset: 0,        // Distance from the center of the diva element to the top of the current page\n            horizontalPadding: 0,       // Either the fixed padding or adaptive padding\n            ID: null,                   // The prefix of the IDs of the elements (usually 1-diva-)\n            initialKeyScroll: false,    // Holds the initial state of enableKeyScroll\n            initialSpaceScroll: false,  // Holds the initial state of enableSpaceScroll\n            innerElement: null,         // The native .diva-outer DOM object\n            innerObject: null,            // document.getElementById(settings.ID + 'inner'), for selecting the .diva-inner element\n            isActiveDiva: true,         // In the case that multiple diva panes exist on the same page, this should have events funneled to it.\n            isScrollable: true,         // Used in enable/disableScrollable public methods\n            isZooming: false,           // Flag to keep track of whether zooming is still in progress, for handleZoom\n            loaded: false,              // A flag for when everything is loaded and ready to go.\n            manifest: null,\n            mobileWebkit: false,        // Checks if the user is on a touch device (iPad/iPod/iPhone/Android)\n            numPages: 0,                // Number of pages in the array\n            oldZoomLevel: -1,           // Holds the previous zoom level after zooming in or out\n            options: options,\n            outerElement: null,         // The native .diva-outer DOM object\n            outerObject: null,            // document.getElementById(settings.ID + 'outer'), for selecting the .diva-outer element\n            pageOverlays: new PageOverlayManager(),\n            pageTools: [],              // The plugins which are enabled as page tools\n            parentObject: this.parentObject, // JQuery object referencing the parent element\n            pendingManifestRequest: null, // Reference to the xhr request retrieving the manifest. Used to cancel the request on destroy()\n            pluginInstances: [],                // Filled with the enabled plugins from the registry\n            renderer: null,\n            resizeTimer: null,            // Holds the ID of the timeout used when resizing the window (for clearing)\n            scrollbarWidth: 0,          // Set to the actual scrollbar width in init()\n            selector: '',               // Uses the generated ID prefix to easily select elements\n            throbberTimeoutID: null,      // Holds the ID of the throbber loading timeout\n            toolbar: null,              // Holds an object with some toolbar-related functions\n            verticalOffset: 0,          // Distance from the center of the diva element to the left side of the current page\n            verticalPadding: 0,         // Either the fixed padding or adaptive padding\n            viewHandler: null,\n            viewport: null,             // Object caching the viewport dimensions\n            viewportElement: null,\n            viewportObject: null,\n            zoomDuration: 400\n        };\n\n        this.settings = createSettingsView([options, this.viewerState]);\n\n        // Generate an ID that can be used as a prefix for all the other IDs\n        const idNumber = generateId();\n        this.viewerState.ID = 'diva-' + idNumber + '-';\n        this.viewerState.selector = this.settings.ID;\n\n        // Aliases for compatibility\n        Object.defineProperties(this.settings, {\n            // Height of the document viewer pane\n            panelHeight: {\n                get: (): number =>\n                {\n                    return this.viewerState.viewport.height;\n                }\n            },\n            // Width of the document viewer pane\n            panelWidth: {\n                get: (): number =>\n                {\n                    return this.viewerState.viewport.width;\n                }\n            }\n        });\n\n        this.optionsValidator = new ValidationRunner({\n            additionalProperties: [\n                {\n                    key: 'manifest',\n                    get: () =>\n                    {\n                        return this.viewerState.manifest;\n                    }\n                }\n            ],\n\n            validations: optionsValidations\n        });\n\n        this.viewerState.scrollbarWidth = getScrollbarWidth();\n\n        // If window.orientation is defined, then it's probably mobileWebkit\n        this.viewerState.mobileWebkit = window.screen.orientation !== undefined;\n\n        if (options.hashParamSuffix === null)\n        {\n            // Omit the suffix from the first instance\n            if (idNumber === 1)\n            {\n                options.hashParamSuffix = '';\n            }\n            else\n            {\n                options.hashParamSuffix = idNumber + '';\n            }\n        }\n\n        // Create the inner and outer panels\n        const innerElem = elt('div', this.elemAttrs('inner', { class: 'diva-inner' }));\n        const viewportElem = elt('div', this.elemAttrs('viewport'), innerElem);\n        const outerElem = elt('div', this.elemAttrs('outer'),\n            viewportElem,\n            elt('div', this.elemAttrs('throbber'),\n                [\n                    elt('div', { class: 'cube cube1' }),\n                    elt('div', { class: 'cube cube2' }),\n                    elt('div', { class: 'cube cube3' }),\n                    elt('div', { class: 'cube cube4' }),\n                    elt('div', { class: 'cube cube5' }),\n                    elt('div', { class: 'cube cube6' }),\n                    elt('div', { class: 'cube cube7' }),\n                    elt('div', { class: 'cube cube8' }),\n                    elt('div', { class: 'cube cube9' }),\n                ]\n            ));\n\n        this.viewerState.innerElement = innerElem;\n        this.viewerState.viewportElement = viewportElem;\n        this.viewerState.outerElement = outerElem;\n\n        this.viewerState.innerObject = innerElem;\n        this.viewerState.viewportObject = viewportElem;\n        this.viewerState.outerObject = outerElem;\n\n        this.settings.parentObject.append(outerElem);\n\n        this.viewerState.viewport = new Viewport(this.viewerState.viewportElement, {\n            intersectionTolerance: this.settings.viewportMargin\n        });\n\n        this.boundScrollFunction = this.scrollFunction.bind(this);\n        this.boundEscapeListener = this.escapeListener.bind(this);\n\n        // Do all the plugin initialisation\n        this.initPlugins();\n        this.handleEvents();\n\n        // Show the throbber while waiting for the manifest to load\n        this.showThrobber();\n    }\n\n    isValidOption (key: string, value: number)\n    {\n        return this.optionsValidator.isValid(key, value, this.viewerState.options);\n    }\n\n    elemAttrs (ident: string, base?: any)\n    {\n        const attrs = {\n            id: this.settings.ID + ident,\n            class: 'diva-' + ident\n        };\n\n        if (base)\n        {\n            return Object.assign(attrs, base);\n        }\n        else\n        {\n            return attrs;\n        }\n    }\n\n    getPageData (pageIndex: number, attribute: string)\n    {\n        return this.settings.manifest!.pages[pageIndex].d[this.settings.zoomLevel][attribute];\n    }\n\n    // Reset some settings and empty the viewport\n    clearViewer ()\n    {\n        this.viewerState.viewport.top = 0;\n\n        // Clear all the timeouts to prevent undesired pages from loading\n        clearTimeout(this.viewerState.resizeTimer);\n    }\n\n    hasChangedOption (options: Record<string, any>, key: string): boolean\n    {\n        return key in options && options[key] !== this.settings[key];\n    }\n\n    //Shortcut for closing fullscreen with the escape key\n    escapeListener (e: KeyboardEvent)\n    {\n        if (e.code === 'Escape')\n        {\n            this.publicInstance.leaveFullscreenMode();\n        }\n    }\n\n    /**\n     * Update settings to match the specified options. Load the viewer,\n     * fire appropriate events for changed options.\n     */\n    reloadViewer (newOptions: ActiveViewOptions): boolean\n    {\n        const queuedEvents = [];\n\n        newOptions = this.optionsValidator.getValidatedOptions(this.settings, newOptions);\n\n        // Set the zoom level if valid and fire a ZoomLevelDidChange event\n        if (this.hasChangedOption(newOptions, 'zoomLevel'))\n        {\n            this.viewerState.oldZoomLevel = this.settings.zoomLevel;\n            this.viewerState.options.zoomLevel = newOptions.zoomLevel;\n            queuedEvents.push([\"ZoomLevelDidChange\", newOptions.zoomLevel]);\n        }\n\n        // Set the pages per row if valid and fire an event\n        if (this.hasChangedOption(newOptions, 'pagesPerRow'))\n        {\n            this.viewerState.options.pagesPerRow = newOptions.pagesPerRow;\n            queuedEvents.push([\"GridRowNumberDidChange\", newOptions.pagesPerRow]);\n        }\n\n        // Update verticallyOriented (no event fired)\n        if (this.hasChangedOption(newOptions, 'verticallyOriented'))\n            this.viewerState.options.verticallyOriented = newOptions.verticallyOriented;\n\n        // Show/Hide non-paged pages\n        if (this.hasChangedOption(newOptions, 'showNonPagedPages'))\n        {\n            this.viewerState.options.showNonPagedPages = newOptions.showNonPagedPages;\n        }\n\n        // Update page position (no event fired here)\n        if ('goDirectlyTo' in newOptions)\n        {\n            this.viewerState.options.goDirectlyTo = newOptions.goDirectlyTo;\n\n            if ('verticalOffset' in newOptions)\n            {\n                this.viewerState.verticalOffset = newOptions.verticalOffset;\n            }\n\n            if ('horizontalOffset' in newOptions)\n            {\n                this.viewerState.horizontalOffset = newOptions.horizontalOffset;\n            }\n        }\n        else\n        {\n            // Otherwise the default is to remain on the current page\n            this.viewerState.options.goDirectlyTo = this.settings.activePageIndex;\n        }\n\n        if (this.hasChangedOption(newOptions, 'inGrid') || this.hasChangedOption(newOptions, 'inBookLayout'))\n        {\n            if ('inGrid' in newOptions)\n            {\n                this.viewerState.options.inGrid = newOptions.inGrid!;\n            }\n\n            if ('inBookLayout' in newOptions)\n            {\n                this.viewerState.options.inBookLayout = newOptions.inBookLayout!;\n            }\n\n            queuedEvents.push([\"ViewDidSwitch\", this.settings.inGrid]);\n        }\n\n        // Note: prepareModeChange() depends on inGrid and the vertical/horizontalOffset (for now)\n        if (this.hasChangedOption(newOptions, 'inFullscreen'))\n        {\n            this.viewerState.options.inFullscreen = newOptions.inFullscreen!;\n            this.prepareModeChange(newOptions);\n            queuedEvents.push([\"ModeDidSwitch\", this.settings.inFullscreen]);\n        }\n\n        this.clearViewer();\n        this.updateViewHandlerAndRendering();\n\n        if (this.viewerState.renderer)\n        {\n            // TODO: The usage of padding variables is still really\n            // messy and inconsistent\n            const rendererConfig: RendererLoadConfig = {\n                pageLayouts: getPageLayouts(this.settings),\n                padding: this.getPadding(),\n                maxZoomLevel: this.settings.inGrid ? null : this.viewerState.manifest!.maxZoom,\n                verticallyOriented: this.settings.verticallyOriented || this.settings.inGrid,\n            };\n\n            const viewportPosition = {\n                zoomLevel: this.settings.inGrid ? null : this.settings.zoomLevel,\n                anchorPage: this.settings.goDirectlyTo,\n                verticalOffset: this.viewerState.verticalOffset,\n                horizontalOffset: this.viewerState.horizontalOffset\n            };\n\n            const sourceProvider = this.getCurrentSourceProvider();\n\n            if (debug.enabled)\n            {\n                const serialized = Object.keys(rendererConfig)\n                    .filter(function (key)\n                    {\n                        // Too long\n                        return key !== 'pageLayouts' && key !== 'padding';\n                    })\n                    .map(function (key)\n                    {\n                        const value = rendererConfig[key];\n                        return key + ': ' + JSON.stringify(value);\n                    })\n                    .join(', ');\n\n                debug('reload with %s', serialized);\n            }\n\n            this.viewerState.renderer.load(rendererConfig, viewportPosition, sourceProvider);\n        }\n\n        queuedEvents.forEach( (params) =>\n        {\n            this.publish.apply(this, params);\n        });\n\n        return true;\n    }\n\n    // Handles switching in and out of fullscreen mode\n    prepareModeChange (options)\n    {\n        // Toggle the classes\n        const changeClass: 'add' | 'remove' = options.inFullscreen ? 'add' : 'remove';\n        this.viewerState.outerObject!.classList[changeClass]('diva-fullscreen');\n        document.body.classList[changeClass]('diva-hide-scrollbar');\n        this.settings.parentObject.classList[changeClass]('diva-full-width');\n\n        // Adjust Diva's internal panel size, keeping the old values\n        const storedHeight = this.settings.panelHeight;\n        const storedWidth = this.settings.panelWidth;\n        this.viewerState.viewport.invalidate();\n\n        // If this isn't the original load, the offsets matter, and the position isn't being changed...\n        if (!this.viewerState.loaded && !this.settings.inGrid && !('verticalOffset' in options))\n        {\n            //get the updated panel size\n            const newHeight = this.settings.panelHeight;\n            const newWidth = this.settings.panelWidth;\n\n            //and re-center the new panel on the same point\n            this.viewerState.verticalOffset += ((storedHeight - newHeight) / 2);\n            this.viewerState.horizontalOffset += ((storedWidth - newWidth) / 2);\n        }\n\n        //turn on/off escape key listener\n        if (options.inFullscreen)\n            document.addEventListener('keyup', this.boundEscapeListener);\n        else\n            document.removeEventListener('keyup', this.boundEscapeListener);\n    }\n\n    // Update the view handler and the view rendering for the current view\n    updateViewHandlerAndRendering ()\n    {\n        const Handler = this.settings.inGrid ? GridHandler : DocumentHandler;\n\n        if (this.viewerState.viewHandler && !(this.viewerState.viewHandler instanceof Handler))\n        {\n            this.viewerState.viewHandler.destroy();\n            this.viewerState.viewHandler = null;\n        }\n\n        if (!this.viewerState.viewHandler)\n        {\n            this.viewerState.viewHandler = new Handler(this);\n        }\n\n        if (!this.viewerState.renderer)\n        {\n            this.initializeRenderer();\n        }\n    }\n\n    // TODO: This could probably be done upon ViewerCore initialization\n    initializeRenderer ()\n    {\n        const compatErrors = Renderer.getCompatibilityErrors();\n\n        if (compatErrors)\n        {\n            this.showError(compatErrors);\n        }\n        else\n        {\n            const options: RendererSettings = {\n                viewport: this.viewerState.viewport,\n                outerElement: this.viewerState.outerElement!,\n                innerElement: this.viewerState.innerElement!,\n                settings: this.settings\n            };\n\n            const hooks = {\n                onViewWillLoad: () =>\n                {\n                    this.viewerState.viewHandler.onViewWillLoad();\n                },\n                onViewDidLoad: () =>\n                {\n                    this.updatePageOverlays();\n                    this.viewerState.viewHandler.onViewDidLoad();\n                },\n                onViewDidUpdate: (pages, targetPage) =>\n                {\n                    this.updatePageOverlays();\n                    this.viewerState.viewHandler.onViewDidUpdate(pages, targetPage);\n                },\n                onViewDidTransition: () =>\n                {\n                    this.updatePageOverlays();\n                },\n                onPageWillLoad: (pageIndex: number) =>\n                {\n                    this.publish('PageWillLoad', pageIndex);\n                },\n                onZoomLevelWillChange: (zoomLevel: number) =>\n                {\n                    this.publish('ZoomLevelWillChange', zoomLevel);\n                }\n            };\n\n            this.viewerState.renderer = new Renderer(options, hooks);\n        }\n    }\n\n    getCurrentSourceProvider (): SourceProvider\n    {\n        if (this.settings.inGrid)\n        {\n            const gridSourceProvider: SourceProvider = {\n                getAllZoomLevelsForPage: (page: PageInfo): DivaTiledPage[] =>\n                {\n                    return [gridSourceProvider.getBestZoomLevelForPage(page)];\n                },\n                getBestZoomLevelForPage: (page: PageInfo): DivaTiledPage =>\n                {\n                    const url = this.settings.manifest.getPageImageURL(page.index, {\n                        width: page.dimensions.width\n                    });\n\n                    return {\n                        zoomLevel: 1, // FIXME\n                        rows: 1,\n                        cols: 1,\n                        tiles: [{\n                            url: url,\n                            zoomLevel: 1, // FIXME\n                            row: 0,\n                            col: 0,\n                            dimensions: page.dimensions,\n                            offset: {\n                                top: 0,\n                                left: 0\n                            }\n                        }]\n                    };\n                }\n            };\n\n            return gridSourceProvider;\n        }\n\n        const tileDimensions: Dimension = {\n            width: this.settings.tileWidth,\n            height: this.settings.tileHeight\n        };\n\n        return {\n            getBestZoomLevelForPage: (page: PageInfo): DivaTiledPage =>\n            {\n                return this.settings.manifest.getPageImageTiles(page.index, Math.ceil(this.settings.zoomLevel), tileDimensions);\n            },\n            getAllZoomLevelsForPage: (page: PageInfo): DivaTiledPage[] =>\n            {\n                const levels = [];\n                const levelCount = this.viewerState.manifest.maxZoom;\n\n                for (let level=0; level <= levelCount; level++)\n                {\n                    levels.push(this.settings.manifest.getPageImageTiles(page.index, level, tileDimensions));\n                }\n\n                levels.reverse();\n\n                return levels;\n            }\n        };\n    }\n\n    getPadding (): PaddingDefinitions\n    {\n        let topPadding, leftPadding;\n        let docVPadding, docHPadding;\n\n        if (this.settings.inGrid)\n        {\n            docVPadding = this.settings.fixedPadding;\n            topPadding = leftPadding = docHPadding = 0;\n        }\n        else\n        {\n            topPadding = this.settings.verticallyOriented ? this.viewerState.verticalPadding : 0;\n            leftPadding = this.settings.verticallyOriented ? 0 : this.viewerState.horizontalPadding;\n\n            docVPadding = this.settings.verticallyOriented ? 0 : this.viewerState.verticalPadding;\n            docHPadding = this.settings.verticallyOriented ? this.viewerState.horizontalPadding : 0;\n        }\n\n        return {\n            document: {\n                top: docVPadding,\n                bottom: docVPadding,\n                left: docHPadding,\n                right: docHPadding\n            },\n            page: {\n                top: topPadding,\n                bottom: 0,\n                left: leftPadding,\n                right: 0\n            }\n        };\n    }\n\n    updatePageOverlays ()\n    {\n        this.viewerState.pageOverlays.updateOverlays(\n            this.viewerState.renderer.getRenderedPages()\n        );\n    }\n\n    // Called to handle any zoom level\n    handleZoom (newZoomLevel: number, focalPoint?: PagePosition): boolean\n    {\n        // If the zoom level provided is invalid, return false\n        if (!this.isValidOption('zoomLevel', newZoomLevel))\n        {\n            return false;\n        }\n\n        // While zooming, don't update scroll offsets based on the scaled version of diva-inner\n        this.viewerState.viewportObject.removeEventListener('scroll', this.boundScrollFunction);\n\n        // If no focal point was given, zoom on the center of the viewport\n        if (!focalPoint)\n        {\n            const viewport = this.viewerState.viewport;\n            const currentRegion = this.viewerState.renderer.layout.getPageRegion(this.settings.activePageIndex);\n\n            focalPoint = {\n                anchorPage: this.settings.activePageIndex,\n                offset: {\n                    left: (viewport.width / 2) - (currentRegion.left - viewport.left),\n                    top: (viewport.height / 2) - (currentRegion.top - viewport.top)\n                }\n            };\n        }\n\n        const pageRegion = this.viewerState.renderer.layout.getPageRegion(focalPoint.anchorPage);\n\n        // calculate distance from cursor coordinates to center of viewport\n        const focalXToCenter = (pageRegion.left + focalPoint.offset.left) -\n            (this.settings.viewport.left + (this.settings.viewport.width / 2));\n        const focalYToCenter = (pageRegion.top + focalPoint.offset.top) -\n            (this.settings.viewport.top + (this.settings.viewport.height / 2));\n\n        const getPositionForZoomLevel =  (zoomLevel: number, initZoom: number): RendererViewportPosition =>\n        {\n            const zoomRatio = Math.pow(2, zoomLevel - initZoom);\n\n            //TODO(jeromepl): Calculate position from page top left to viewport top left\n            // calculate horizontal/verticalOffset: distance from viewport center to page upper left corner\n            const horizontalOffset = (focalPoint.offset.left * zoomRatio) - focalXToCenter;\n            const verticalOffset = (focalPoint.offset.top * zoomRatio) - focalYToCenter;\n\n            return {\n                zoomLevel: zoomLevel,\n                anchorPage: focalPoint.anchorPage,\n                verticalOffset: verticalOffset,\n                horizontalOffset: horizontalOffset\n            };\n        };\n\n        this.viewerState.options.zoomLevel = newZoomLevel;\n        let initialZoomLevel = this.viewerState.oldZoomLevel;\n        this.viewerState.oldZoomLevel = this.settings.zoomLevel;\n        const endPosition = getPositionForZoomLevel(newZoomLevel, initialZoomLevel);\n        this.viewerState.options.goDirectlyTo = endPosition.anchorPage;\n        this.viewerState.verticalOffset = endPosition.verticalOffset;\n        this.viewerState.horizontalOffset = endPosition.horizontalOffset;\n\n        this.viewerState.renderer.transitionViewportPosition({\n            duration: this.settings.zoomDuration,\n            parameters: {\n                zoomLevel: {\n                    from: initialZoomLevel,\n                    to: newZoomLevel\n                }\n            },\n            getPosition: (parameters: any): RendererViewportPosition =>\n            {\n                return getPositionForZoomLevel(parameters.zoomLevel, initialZoomLevel);\n            },\n            onEnd: (info: any): void =>\n            {\n                this.viewerState.viewportObject.addEventListener('scroll', this.boundScrollFunction);\n\n                if (info.interrupted)\n                {\n                    this.viewerState.oldZoomLevel = newZoomLevel;\n                }\n            }\n        });\n\n        // Deactivate zoom buttons while zooming\n        let zoomInButton: HTMLButtonElement = document.getElementById(this.settings.selector + 'zoom-in-button')! as HTMLButtonElement;\n        let zoomOutButton: HTMLButtonElement = document.getElementById(this.settings.selector + 'zoom-out-button')! as HTMLButtonElement;\n        zoomInButton.disabled = true;\n        zoomOutButton.disabled = true;\n        setTimeout(() =>\n        {\n            zoomInButton.disabled = false;\n            zoomOutButton.disabled = false;\n        }, this.settings.zoomDuration);\n\n        // Send off the zoom level did change event.\n        this.publish(\"ZoomLevelDidChange\", newZoomLevel);\n\n        return true;\n    }\n\n    /*\n     Gets the Y-offset for a specific point on a specific page\n     Acceptable values for \"anchor\":\n     \"top\" (default) - will anchor top of the page to the top of the diva-outer element\n     \"bottom\" - top, s/top/bottom\n     \"center\" - will center the page on the diva element\n     Returned value will be the distance from the center of the diva-outer element to the top of the current page for the specified anchor\n     */\n    getYOffset (pageIndex?: number, anchor?: string): number\n    {\n        let pidx = (typeof(pageIndex) === \"undefined\" ? this.settings.activePageIndex : pageIndex);\n\n        if (anchor === \"center\" || anchor === \"centre\") //how you can tell an American coded this\n        {\n            return Math.floor(this.getPageData(pidx, \"h\") / 2);\n        }\n        else if (anchor === \"bottom\")\n        {\n            return Math.floor(this.getPageData(pidx, \"h\") - this.settings.panelHeight / 2);\n        }\n        else\n        {\n            return Math.floor(this.settings.panelHeight / 2);\n        }\n    }\n\n    //Same as getYOffset with \"left\" and \"right\" as acceptable values instead of \"top\" and \"bottom\"\n    getXOffset (pageIndex?: number, anchor?: string): number\n    {\n        let pidx = (typeof(pageIndex) === \"undefined\" ? this.settings.activePageIndex : pageIndex);\n\n        if (anchor === \"left\")\n        {\n            return Math.floor(this.settings.panelWidth / 2);\n        }\n        else if (anchor === \"right\")\n        {\n            return Math.floor(this.getPageData(pidx, \"w\") - this.settings.panelWidth / 2);\n        }\n        else\n        {\n            return Math.floor(this.getPageData(pidx, \"w\") / 2);\n        }\n    }\n\n    // updates panelHeight/panelWidth on resize\n    updatePanelSize ()\n    {\n        this.viewerState.viewport.invalidate();\n\n        // FIXME(wabain): This should really only be called after initial load\n        if (this.viewerState.renderer)\n        {\n            this.updateOffsets();\n            this.viewerState.renderer.goto(this.settings.activePageIndex, this.viewerState.verticalOffset, this.viewerState.horizontalOffset);\n        }\n\n        return true;\n    }\n\n    updateOffsets ()\n    {\n        const pageOffset = this.viewerState.renderer.layout.getPageToViewportCenterOffset(this.settings.activePageIndex, this.viewerState.viewport);\n\n        if (pageOffset)\n        {\n            this.viewerState.horizontalOffset = pageOffset.x;\n            this.viewerState.verticalOffset = pageOffset.y;\n        }\n    }\n\n    // Bind mouse events (drag to scroll, double-click)\n    bindMouseEvents ()\n    {\n        // Set drag scroll on the viewport object\n        this.viewerState.viewportObject.classList.add('dragscroll');\n\n        gestureEvents.onDoubleClick(this.viewerState.viewportObject, (event, coords) =>\n        {\n            debug('Double click at %s, %s', coords.left, coords.top);\n            this.viewerState.viewHandler.onDoubleClick(event, coords);\n        });\n    }\n\n    onResize ()\n    {\n        this.updatePanelSize();\n        // Cancel any previously-set resize timeouts\n        clearTimeout(this.viewerState.resizeTimer);\n\n        this.viewerState.resizeTimer = setTimeout( () =>\n        {\n            const pageOffset = this.viewerState.renderer.layout.getPageToViewportCenterOffset(this.settings.activePageIndex, this.viewerState.viewport);\n\n            if (pageOffset)\n            {\n                this.reloadViewer({\n                    goDirectlyTo: this.settings.activePageIndex,\n                    verticalOffset: pageOffset.y,\n                    horizontalOffset: pageOffset.x\n                });\n            }\n            else\n            {\n                this.reloadViewer({\n                    goDirectlyTo: this.settings.activePageIndex\n                });\n            }\n        }, 200);\n    }\n\n    // Bind touch and orientation change events\n    bindTouchEvents ()\n    {\n        // Block the user from moving the window only if it's not integrated\n        if (this.settings.blockMobileMove)\n        {\n            document.body.addEventListener('touchmove', (event) =>\n            {\n                event.preventDefault();\n                return false;\n            });\n        }\n\n        // Touch events for swiping in the viewport to scroll pages\n        // this.viewerState.viewportObject.addEventListener('scroll', this.scrollFunction.bind(this));\n\n        gestureEvents.onPinch(this.viewerState.viewportObject,  (event, coords, start, end) =>\n        {\n            debug('Pinch %s at %s, %s', end - start, coords.left, coords.top);\n            this.viewerState.viewHandler.onPinch(event, coords, start, end);\n        });\n\n        gestureEvents.onDoubleTap(this.viewerState.viewportObject,  (event, coords) =>\n        {\n            debug('Double tap at %s, %s', coords.left, coords.top);\n            this.viewerState.viewHandler.onDoubleClick(event, coords);\n        });\n    }\n\n    // Handle the scroll\n    scrollFunction ()\n    {\n        const previousTopScroll = this.viewerState.viewport.top;\n        const previousLeftScroll = this.viewerState.viewport.left;\n\n        let direction;\n\n        this.viewerState.viewport.invalidate();\n\n        const newScrollTop = this.viewerState.viewport.top;\n        const newScrollLeft = this.viewerState.viewport.left;\n\n        if (this.settings.verticallyOriented || this.settings.inGrid)\n        {\n            direction = newScrollTop - previousTopScroll;\n        }\n        else\n        {\n            direction = newScrollLeft - previousLeftScroll;\n        }\n\n        this.viewerState.renderer.adjust();\n\n        const primaryScroll = (this.settings.verticallyOriented || this.settings.inGrid) ? newScrollTop : newScrollLeft;\n\n        this.publish(\"ViewerDidScroll\", primaryScroll);\n\n        if (direction > 0)\n        {\n            this.publish(\"ViewerDidScrollDown\", primaryScroll);\n        }\n        else if (direction < 0)\n        {\n            this.publish(\"ViewerDidScrollUp\", primaryScroll);\n        }\n\n        this.updateOffsets();\n    }\n\n    // Binds most of the event handlers (some more in createToolbar)\n    handleEvents ()\n    {\n        // Change the cursor for dragging\n        this.viewerState.innerObject.addEventListener('mousedown', () =>\n        {\n            this.viewerState.innerObject.classList.add('diva-grabbing');\n        });\n\n        this.viewerState.innerObject.addEventListener('mouseup', () =>\n        {\n            this.viewerState.innerObject.classList.remove('diva-grabbing');\n        });\n\n        this.bindMouseEvents();\n        this.viewerState.viewportObject.addEventListener('scroll', this.boundScrollFunction);\n\n        const upArrowKey = 38,\n            downArrowKey = 40,\n            leftArrowKey = 37,\n            rightArrowKey = 39,\n            spaceKey = 32,\n            pageUpKey = 33,\n            pageDownKey = 34,\n            homeKey = 36,\n            endKey = 35;\n\n        // Catch the key presses in document\n        document.addEventListener('keydown.diva', (event: KeyboardEvent): boolean =>\n        {\n            if (!this.viewerState.isActiveDiva)\n            {\n                return true;\n            }\n\n            // Space or page down - go to the next page\n            if ((this.settings.enableSpaceScroll && !event.shiftKey && event.keyCode === spaceKey) || (this.settings.enableKeyScroll && event.keyCode === pageDownKey))\n            {\n                this.viewerState.viewport.top += this.settings.panelHeight;\n                return false;\n            }\n            else if (!this.settings.enableSpaceScroll && event.keyCode === spaceKey)\n            {\n                event.preventDefault();\n            }\n\n            if (this.settings.enableKeyScroll)\n            {\n                // Don't steal keyboard shortcuts (metaKey = command [OS X], super [Win/Linux])\n                if (event.shiftKey || event.ctrlKey || event.metaKey)\n                {\n                    return true;\n                }\n\n                switch (event.keyCode)\n                {\n                    case pageUpKey:\n                        // Page up - go to the previous page\n                        this.viewerState.viewport.top -= this.settings.panelHeight;\n                        return false;\n\n                    case upArrowKey:\n                        // Up arrow - scroll up\n                        this.viewerState.viewport.top -= this.settings.arrowScrollAmount;\n                        return false;\n\n                    case downArrowKey:\n                        // Down arrow - scroll down\n                        this.viewerState.viewport.top += this.settings.arrowScrollAmount;\n                        return false;\n\n                    case leftArrowKey:\n                        // Left arrow - scroll left\n                        this.viewerState.viewport.left -= this.settings.arrowScrollAmount;\n                        return false;\n\n                    case rightArrowKey:\n                        // Right arrow - scroll right\n                        this.viewerState.viewport.left += this.settings.arrowScrollAmount;\n                        return false;\n\n                    case homeKey:\n                        // Home key - go to the beginning of the document\n                        this.viewerState.viewport.top = 0;\n                        return false;\n\n                    case endKey:\n                        // End key - go to the end of the document\n                        // Count on the viewport coordinate value being normalized\n                        if (this.settings.verticallyOriented)\n                        {\n                            this.viewerState.viewport.top = Infinity;\n                        }\n                        else\n                        {\n                            this.viewerState.viewport.left = Infinity;\n                        }\n\n                        return false;\n\n                    default:\n                        return true;\n                }\n            }\n            return true;\n        });\n\n        divaGlobal.Events.subscribe('ViewerDidTerminate', () =>\n        {\n            document.removeEventListener('keydown.diva');\n        }, this.settings.ID);\n\n        // this.bindTouchEvents();\n\n        // Handle window resizing events\n        window.addEventListener('resize', this.onResize.bind(this), false);\n\n        divaGlobal.Events.subscribe('ViewerDidTerminate', function()\n        {\n            window.removeEventListener('resize', this.onResize, false);\n        }, this.settings.ID);\n\n        // Handle orientation change separately\n        if ('onorientationchange' in window)\n        {\n            window.addEventListener('orientationchange', this.onResize, false);\n\n            divaGlobal.Events.subscribe('ViewerDidTerminate', function()\n            {\n                window.removeEventListener('orientationchange', this.onResize, false);\n            }, this.settings.ID);\n        }\n\n        divaGlobal.Events.subscribe('PanelSizeDidChange', this.updatePanelSize, this.settings.ID);\n\n        // Clear page and resize timeouts when the viewer is destroyed\n        divaGlobal.Events.subscribe('ViewerDidTerminate', () =>\n        {\n            if (this.viewerState.renderer)\n            {\n                this.viewerState.renderer.destroy();\n            }\n\n            clearTimeout(this.viewerState.resizeTimer);\n        }, this.settings.ID);\n    }\n\n    initPlugins ()\n    {\n        if (!this.settings.hasOwnProperty('plugins'))\n        {\n            return null;\n        }\n\n        this.viewerState.pluginInstances = this.settings.plugins.map( (plugin) =>\n        {\n            const p = new plugin(this);\n\n            if (p.isPageTool)\n            {\n                this.viewerState.pageTools.push(p);\n            }\n\n            return p;\n        });\n    }\n\n    showThrobber ()\n    {\n        this.hideThrobber();\n\n        this.viewerState.throbberTimeoutID = setTimeout( () =>\n        {\n            let thb = document.getElementById(this.settings.selector + 'throbber');\n            if (thb) thb.style.display = 'block';\n        }, this.settings.throbberTimeout);\n    }\n\n    hideThrobber ()\n    {\n        // Clear the timeout, if it hasn't executed yet\n        clearTimeout(this.viewerState.throbberTimeoutID);\n\n        let thb = document.getElementById(this.settings.selector + 'throbber');\n        // Hide the throbber if it has already executed\n        if (thb)\n        {\n            thb.style.display = 'none';\n        }\n    }\n\n    showError (message)\n    {\n        const errorElement = elt('div', this.elemAttrs('error'), [\n            elt('button', this.elemAttrs('error-close', {'aria-label': 'Close dialog'})),\n            elt('p',\n                elt('strong', 'Error')\n            ),\n            elt('div', message)\n        ]);\n\n        this.viewerState.outerObject.appendChild(errorElement);\n\n        // Bind dialog close button\n        document.getElementById(this.settings.selector + 'error-close').addEventListener('click', () =>\n        {\n            errorElement.parentNode.removeChild(errorElement);\n        });\n    }\n\n    setManifest (manifest: ImageManifest, loadOptions: any)\n    {\n        this.viewerState.manifest = manifest;\n\n        this.hideThrobber();\n\n        // Convenience value\n        this.viewerState.numPages = this.settings.manifest.pages.length;\n\n        this.optionsValidator.validate(this.viewerState.options);\n\n        this.publish('NumberOfPagesDidChange', this.settings.numPages);\n\n        // Calculate the horizontal and vertical inter-page padding based on the dimensions of the average zoom level\n        if (this.settings.adaptivePadding > 0)\n        {\n            const z: number = Math.floor((this.settings.minZoomLevel + this.settings.maxZoomLevel) / 2);\n            this.viewerState.horizontalPadding = Math.floor(this.settings.manifest.getAverageWidth(z) * this.settings.adaptivePadding);\n            this.viewerState.verticalPadding = Math.floor(this.settings.manifest.getAverageHeight(z) * this.settings.adaptivePadding);\n        }\n        else\n        {\n            // It's less than or equal to 0; use fixedPadding instead\n            this.viewerState.horizontalPadding = this.settings.fixedPadding;\n            this.viewerState.verticalPadding = this.settings.fixedPadding;\n        }\n\n        // Make sure the vertical padding is at least 40, if plugin icons are enabled\n        if (this.viewerState.pageTools.length)\n        {\n            this.viewerState.verticalPadding = Math.max(40, this.viewerState.verticalPadding);\n        }\n\n        // If we detect a viewingHint of 'paged' in the manifest or sequence, enable book view by default\n        if (this.settings.manifest.paged)\n        {\n            this.viewerState.options.inBookLayout = true;\n        }\n\n        // Plugin setup hooks should be bound to the ObjectDidLoad event\n        this.publish('ObjectDidLoad', this.settings);\n\n        // Adjust the document panel dimensions\n        this.updatePanelSize();\n\n        let needsXCoord, needsYCoord;\n\n        let anchoredVertically = false;\n        let anchoredHorizontally = false;\n\n        // NB: `==` here will check both null and undefined\n        if (loadOptions.goDirectlyTo == null)\n        {\n            loadOptions.goDirectlyTo = this.settings.goDirectlyTo;\n            needsXCoord = needsYCoord = true;\n        }\n        else\n        {\n            needsXCoord = loadOptions.horizontalOffset == null || isNaN(loadOptions.horizontalOffset);\n            needsYCoord = loadOptions.verticalOffset == null || isNaN(loadOptions.verticalOffset);\n        }\n\n        // Set default values for the horizontal and vertical offsets\n        if (needsXCoord)\n        {\n            // FIXME: What if inBookLayout/verticallyOriented is changed by loadOptions?\n            if (loadOptions.goDirectlyTo === 0 && this.settings.inBookLayout && this.settings.verticallyOriented)\n            {\n                // if in book layout, center the first opening by default\n                loadOptions.horizontalOffset = this.viewerState.horizontalPadding;\n            }\n            else\n            {\n                anchoredHorizontally = true;\n                loadOptions.horizontalOffset = this.getXOffset(loadOptions.goDirectlyTo, \"center\");\n            }\n        }\n\n        if (needsYCoord)\n        {\n            anchoredVertically = true;\n            loadOptions.verticalOffset = this.getYOffset(loadOptions.goDirectlyTo, \"top\");\n        }\n\n        this.reloadViewer(loadOptions);\n\n        //prep dimensions one last time now that pages have loaded\n        this.updatePanelSize();\n\n        if (this.settings.enableAutoTitle)\n        {\n            let title = document.getElementById(this.settings.selector + 'title');\n\n            if (title)\n            {\n                title.innerHTML = this.settings.manifest.itemTitle;\n            }\n            else\n            {\n                this.settings.parentObject.insertBefore(\n                    elt('div', this.elemAttrs('title'), [this.settings.manifest.itemTitle]),\n                    this.settings.parentObject.firstChild\n                );\n            }\n        }\n\n        // FIXME: This is a hack to ensure that the outerElement scrollbars are taken into account\n        if (this.settings.verticallyOriented)\n        {\n            this.viewerState.innerElement.style.minWidth = this.settings.panelWidth + 'px';\n        }\n        else\n        {\n            this.viewerState.innerElement.style.minHeight = this.settings.panelHeight + 'px';\n        }\n\n        // FIXME: If the page was supposed to be positioned relative to the viewport we need to\n        // recalculate it to take into account the scrollbars\n        if (anchoredVertically || anchoredHorizontally)\n        {\n            if (anchoredVertically)\n            {\n                this.viewerState.verticalOffset = this.getYOffset(this.settings.activePageIndex, \"top\");\n            }\n\n            if (anchoredHorizontally)\n            {\n                this.viewerState.horizontalOffset = this.getXOffset(this.settings.activePageIndex, \"center\");\n            }\n\n            this.viewerState.renderer.goto(this.settings.activePageIndex, this.viewerState.verticalOffset, this.viewerState.horizontalOffset);\n        }\n\n        // signal that everything should be set up and ready to go.\n        this.viewerState.loaded = true;\n\n        this.publish(\"ViewerDidLoad\", this.settings);\n    }\n\n    publish (event: string, ...args: any[])\n    {\n        // const args = Array.prototype.slice.call(arguments, 1);\n        globalDiva.Events.publish(event, args, this.publicInstance);\n    }\n\n    getSettings ()\n    {\n        return this.settings;\n    }\n\n    // Temporary accessor for the state of the viewer core\n    // TODO: Replace this with a more restricted view of whatever needs\n    // be exposed through settings for backwards compat\n    getInternalState ()\n    {\n        return this.viewerState;\n    }\n\n    getPublicInstance ()\n    {\n        return this.publicInstance;\n    }\n\n    getPageTools ()\n    {\n        return this.viewerState.pageTools;\n    }\n\n    getCurrentLayout ()\n    {\n        return this.viewerState.renderer ? this.viewerState.renderer.layout : null;\n    }\n\n    /** Get a copy of the current viewport dimensions */\n    getViewport (): ViewportSize\n    {\n        const viewport = this.viewerState.viewport;\n\n        return {\n            top: viewport.top,\n            left: viewport.left,\n            bottom: viewport.bottom,\n            right: viewport.right,\n\n            width: viewport.width,\n            height: viewport.height\n        };\n    }\n\n    addPageOverlay (overlay: PageToolsOverlay): void\n    {\n        this.viewerState.pageOverlays.addOverlay(overlay);\n    }\n\n    removePageOverlay (overlay: PageToolsOverlay): void\n    {\n        this.viewerState.pageOverlays.removeOverlay(overlay);\n    }\n\n    getPageRegion (pageIndex: number, options: PageRegionOptions): Region | null\n    {\n        const layout = this.viewerState.renderer!.layout!;\n        const region = layout.getPageRegion(pageIndex, options)!;\n\n        if (options && options.incorporateViewport)\n        {\n            const secondaryDim = this.settings.verticallyOriented ? 'width' : 'height';\n\n            if (this.viewerState.viewport[secondaryDim] > layout.dimensions[secondaryDim])\n            {\n                const docOffset = (this.viewerState.viewport[secondaryDim] - layout.dimensions[secondaryDim]) / 2;\n\n                if (this.settings.verticallyOriented)\n                {\n                    return {\n                        top: region.top,\n                        bottom: region.bottom,\n\n                        left: region.left + docOffset,\n                        right: region.right + docOffset\n                    };\n                }\n                else\n                {\n                    return {\n                        top: region.top + docOffset,\n                        bottom: region.bottom + docOffset,\n\n                        left: region.left,\n                        right: region.right\n                    };\n                }\n            }\n        }\n\n        return region;\n    }\n\n    getPagePositionAtViewportOffset (coords: Offset): PagePosition\n    {\n        const docCoords = {\n            left: coords.left + this.viewerState.viewport.left,\n            top: coords.top + this.viewerState.viewport.top\n        };\n        const renderer = this.viewerState.renderer!;\n\n        const renderedPages: number[] = renderer.getRenderedPages();\n        const pageCount = renderedPages.length;\n\n        // Find the page on which the coords occur\n        for (let i=0; i < pageCount; i++)\n        {\n            const pageIndex: number = renderedPages[i];\n            const region = renderer.layout!.getPageRegion(pageIndex)!;\n\n            if (region.left <= docCoords.left && region.right >= docCoords.left &&\n                region.top <= docCoords.top && region.bottom >= docCoords.top)\n            {\n                return {\n                    anchorPage: pageIndex,\n                    offset: {\n                        left: docCoords.left - region.left,\n                        top: docCoords.top - region.top\n                    }\n                };\n            }\n        }\n\n        // Fall back to current page\n        // FIXME: Would be better to use the closest page or something\n        const currentRegion = renderer.layout!.getPageRegion(this.settings.activePageIndex)!;\n\n        return {\n            anchorPage: this.settings.activePageIndex,\n            offset: {\n                left: docCoords.left - currentRegion.left,\n                top: docCoords.top - currentRegion.top\n            }\n        };\n    }\n\n    // setManifest (manifest, loadOptions)\n    // {\n    //     setManifest(manifest, loadOptions || {});\n    // }\n\n    /**\n     * Set the current page to the given index, firing VisiblePageDidChange\n     *\n     * @param activePage\n     * @param visiblePages\n     */\n    setCurrentPages (activePage: number, visiblePages: number[])\n    {\n        if (!arraysEqual(this.viewerState.currentPageIndices, visiblePages))\n        {\n            this.viewerState.currentPageIndices = visiblePages;\n            if (this.viewerState.activePageIndex !== activePage)\n            {\n                this.viewerState.activePageIndex = activePage;\n                this.publish(\"ActivePageDidChange\", activePage);\n            }\n            this.publish(\"VisiblePageDidChange\", visiblePages);\n\n            // Publish an event if the page we're switching to has other images.\n            if (this.viewerState.manifest.pages[activePage].otherImages.length > 0)\n            {\n                this.publish('VisiblePageHasAlternateViews', activePage);\n            }\n        }\n        else if (this.viewerState.activePageIndex !== activePage)\n        {\n            this.viewerState.activePageIndex = activePage;\n            this.publish(\"ActivePageDidChange\", activePage);\n        }\n    }\n\n    getPageName (pageIndex: number)\n    {\n        return this.viewerState.manifest!.pages[pageIndex].f;\n    }\n\n    reload (newOptions: ActiveViewOptions): boolean\n    {\n        return this.reloadViewer(newOptions);\n    }\n\n    zoom (zoomLevel: number, focalPoint?: PagePosition): boolean\n    {\n        return this.handleZoom(zoomLevel, focalPoint);\n    }\n\n    enableScrollable ()\n    {\n        if (!this.viewerState.isScrollable)\n        {\n            this.bindMouseEvents();\n            this.enableDragScrollable();\n            this.viewerState.options.enableKeyScroll = this.viewerState.initialKeyScroll;\n            this.viewerState.options.enableSpaceScroll = this.viewerState.initialSpaceScroll;\n            this.viewerState.viewportElement!.style.overflow = 'auto';\n            this.viewerState.isScrollable = true;\n        }\n    }\n\n    enableDragScrollable ()\n    {\n        if (this.viewerState.viewportObject!.hasAttribute('nochilddrag'))\n        {\n            this.viewerState.viewportObject!.removeAttribute('nochilddrag');\n        }\n    }\n\n    disableScrollable ()\n    {\n        if (this.viewerState.isScrollable)\n        {\n            // block dragging\n            this.disableDragScrollable();\n\n            // block double-click zooming\n            this.viewerState.outerObject!.ondblclick = null;\n            this.viewerState.outerObject!.oncontextmenu = null;\n\n            // disable all other scrolling actions\n            this.viewerState.viewportElement!.style.overflow = 'hidden';\n\n            // block scrolling keys behavior, respecting initial scroll settings\n            this.viewerState.initialKeyScroll = this.settings.enableKeyScroll;\n            this.viewerState.initialSpaceScroll = this.settings.enableSpaceScroll;\n            this.viewerState.options.enableKeyScroll = false;\n            this.viewerState.options.enableSpaceScroll = false;\n\n            this.viewerState.isScrollable = false;\n        }\n    }\n\n    disableDragScrollable ()\n    {\n        if (!this.viewerState.viewportObject.hasAttribute('nochilddrag'))\n        {\n            this.viewerState.viewportObject.setAttribute('nochilddrag', \"\");\n        }\n    }\n\n    // isValidOption (key, value)\n    // {\n    //     return isValidOption(key, value);\n    // }\n\n    // getXOffset (pageIndex, xAnchor)\n    // {\n    //     return getXOffset(pageIndex, xAnchor);\n    // }\n\n    // getYOffset (pageIndex, yAnchor)\n    // {\n    //     return getYOffset(pageIndex, yAnchor);\n    // }\n\n    // this.publish = publish;\n\n    clear ()\n    {\n        this.clearViewer();\n    }\n\n    setPendingManifestRequest (pendingManifestRequest: Promise<void>)\n    {\n        this.viewerState.pendingManifestRequest = pendingManifestRequest;\n    }\n\n    destroy ()\n    {\n        // Useful event to access elements in diva before they get destroyed. Used by the highlight plugin.\n        this.publish('ViewerWillTerminate', this.settings);\n\n        // Cancel any pending request retrieving a manifest\n        if (this.settings.pendingManifestRequest)\n        {\n            this.settings.pendingManifestRequest.abort();\n        }\n\n        // Removes the hide-scrollbar class from the body\n        document.body.classList.remove('diva-hide-scrollbar');\n\n        // Empty the parent container and remove any diva-related data\n        this.settings.parentObject.parentElement.replaceChildren();\n\n        // Remove any additional styling on the parent element\n        this.settings.parentObject.parentElement.removeAttribute('style');\n        this.settings.parentObject.parentElement.removeAttribute('class');\n\n        this.publish('ViewerDidTerminate', this.settings);\n\n        // Clear the Events cache\n        globalDiva.Events.unsubscribeAll(this.settings.ID);\n    }\n}\n","import {Region} from \"./viewer-type-definitions\";\n\n\nexport default class Viewport\n{\n    intersectionTolerance: number;\n    outer: HTMLElement;\n    _top: number | null;\n    _left: number | null;\n    _width: number | null;\n    _height: number | null;\n    _innerDimensions: any;\n    top: number;\n    bottom: number;\n    left: number;\n    right: number;\n\n    constructor (outer: HTMLElement, options: { intersectionTolerance?: any; })\n    {\n        options = options || {};\n\n        this.intersectionTolerance = options.intersectionTolerance || 0;\n        this.outer = outer;\n        this._top = this._left = this._width = this._height = this._innerDimensions = null;\n\n        this.invalidate();\n    }\n\n    intersectsRegion (region: Region): boolean\n    {\n        return this.hasHorizontalOverlap(region) && this.hasVerticalOverlap(region);\n    }\n\n    hasVerticalOverlap (region: Region): boolean\n    {\n        const top = this.top - this.intersectionTolerance;\n        const bottom = this.bottom + this.intersectionTolerance;\n\n        return (\n            fallsBetween(region.top, top, bottom) ||\n            fallsBetween(region.bottom, top, bottom) ||\n            (region.top <= top && region.bottom >= bottom)\n        );\n    }\n\n    hasHorizontalOverlap (region: Region): boolean\n    {\n        const left = this.left - this.intersectionTolerance;\n        const right = this.right + this.intersectionTolerance;\n\n        return (\n            fallsBetween(region.left, left, right) ||\n            fallsBetween(region.right, left, right) ||\n            (region.left <= left && region.right >= right)\n        );\n    }\n\n    invalidate ()\n    {\n        // FIXME: Should this check the inner dimensions as well?\n        this._width = this.outer.clientWidth;\n        this._height = this.outer.clientHeight;\n\n        this._top = this.outer.scrollTop;\n        this._left = this.outer.scrollLeft;\n    }\n\n    setInnerDimensions (dimensions: { height: number; width: number; })\n    {\n        this._innerDimensions = dimensions;\n\n        if (dimensions)\n        {\n            this._top = clamp(this._top, 0, dimensions.height - this._height);\n            this._left = clamp(this._left, 0, dimensions.width - this._width);\n        }\n    }\n}\n\nObject.defineProperties(Viewport.prototype, {\n    top: getCoordinateDescriptor('top', 'height'),\n    left: getCoordinateDescriptor('left', 'width'),\n\n    width: getDimensionDescriptor('width'),\n    height: getDimensionDescriptor('height'),\n\n    bottom: {\n        get: function ()\n        {\n            return this._top + this._height;\n        }\n    },\n    right: {\n        get: function ()\n        {\n            return this._left + this._width;\n        }\n    }\n});\n\nfunction getCoordinateDescriptor (coord: string, associatedDimension: string)\n{\n    const privateProp = '_' + coord;\n    const source = 'scroll' + coord.charAt(0).toUpperCase() + coord.slice(1);\n\n    return {\n        get: function ()\n        {\n            return this[privateProp];\n        },\n        set: function (newValue: number)\n        {\n            let normalized;\n\n            if (this._innerDimensions)\n            {\n                const maxAllowed = this._innerDimensions[associatedDimension] - this[associatedDimension];\n                normalized = clamp(newValue, 0, maxAllowed);\n            }\n            else\n            {\n                normalized = clampMin(newValue, 0);\n            }\n\n            this[privateProp] = this.outer[source] = normalized;\n        }\n    };\n}\n\nfunction getDimensionDescriptor (dimen: string)\n{\n    return {\n        get: function ()\n        {\n            return this['_' + dimen];\n        }\n    };\n}\n\nfunction fallsBetween (point: number, start: number, end: number): boolean\n{\n    return point >= start && point <= end;\n}\n\nfunction clamp (value: number, min: number, max: number): number\n{\n    return clampMin(clampMax(value, max), min);\n}\n\nfunction clampMin (value: number, min: number): number\n{\n    return Math.max(value, min);\n}\n\nfunction clampMax (value: number, max: number): number\n{\n    return Math.min(value, max);\n}\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvBA;AAaA;AA0BA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AAGA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAvIA;AAJA;AACA;AACA;AAIA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAsHA;AAvJA;;;;;;;AAOA;AAkJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;;;;;;;;;;;ACnLA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAIA;;;;;;;;;;;;;;;;AAgBA;AAsHA;;AAEA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AAGA;AACA;AAEA;;AAEA;AAGA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAKA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;;AAEA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;;AAEA;AAGA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AAGA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AAGA;AAEA;AAEA;AACA;AAGA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAGA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AAGA;AACA;AAEA;;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AAGA;AACA;AAEA;;AAEA;AAGA;AACA;AAEA;;;;AAIA;;;;AAMA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;;AAIA;AAGA;AACA;AAEA;;;;AAIA;AAGA;AACA;AAEA;;;;AAIA;AAGA;AACA;AAEA;;;;AAIA;AAGA;AACA;AAEA;;;;AAIA;AAGA;AACA;AAEA;;;;AAIA;AAGA;AACA;AAEA;;;;;;;;AAQA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AAGA;AAEA;AACA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;;;;AAMA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;;;;AAMA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AACA;AAEA;;;;;AAKA;AAEA;AAEA;AACA;AAEA;;;;;;AAMA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;;;;AAMA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AAGA;AACA;AAEA;;;;;;AAMA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;AAOA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;AAOA;AAGA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AAGA;AACA;AAEA;;;;;;;;AAQA;AAGA;AACA;AAEA;;;;;;;;AAQA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;;;;;;;AASA;AAGA;AACA;AAEA;;;;;;;;;AASA;AAGA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;AAQA;AAGA;AACA;AACA;AAEA;;;;;;AAMA;AAGA;AACA;AAEA;;;;AAIA;AAGA;AAAA;AAAA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;;;;AAMA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;;;;;;;;AAUA;AAGA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AAGA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AAGA;AAAA;AAAA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;;AAcA;AAGA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;AAGA;AAGA;AACA;AAt+CA;AARA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;;AAEA;AAGA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AA83CA;AAEA;AAEA;AAEA;;AAEA;AAEA;AAEA;AACA;AACA;;;;;;;;;;;;;;AChiDA;AACA;AAQA;AAuCA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAnJA;AAJA;AACA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAqHA;AA1JA;AA4JA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;;;;;;;;;;AC5LA;;;;AAIA;AAeA;AAeA;;;AAGA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AACA;AAEA;;;;;AAKA;AAGA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;AAMA;AAGA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAxIA;AAJA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAkIA;AA/IA;AAiJA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;AC5TA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAMA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAOA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjMA;AAYA;AASA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AAGA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AA5GA;AAFA;AAIA;AACA;AA0GA;AAjHA;AAmHA;AAEA;AAEA;AAEA;AACA;AACA;AACA;;;;;;;;;;ACrIA;AAEA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AA9DA;;;;;;;;;;;;ACHA;AAEA;;AAEA;AAGA;AAiBA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AA5GA;AALA;AACA;AACA;AACA;AAIA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAqGA;AApHA;;;;;;;;;;;;;;ACPA;AACA;AAWA;AAyCA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AAGA;AACA;AAEA;;AAEA;AAGA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AA/JA;AAfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AA0IA;AAjLA;AAmLA;AAEA;AACA;;;;;;;;;;;;ACzLA;AAiCA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAjEA;AAVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AA+CA;AArFA;;;;;;AAMA;;;;;;;;;;ACRA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AACA;AAEA;;;;AAIA;AAGA;AACA;AAEA;AAGA;AACA;AACA;AAKA;AACA;;;;;;;;;;;AClHA;AAIA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AAGA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAKA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC1KA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;ACpGA;AACA;AACA;AAIA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;ACxCA;AAEA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACXA;AAIA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;;;;;;;;;;;AC9BA;;;;;;;;;;AAUA;AAGA;AAaA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAlGA;AAJA;AACA;AACA;AAIA;AACA;AACA;AACA;AA8FA;AAzGA;;;;;;;;;;;;;ACbA;AAOA;AAqBA;AAEA;AAEA;AAEA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAtFA;AARA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAEA;AACA;AACA;AACA;AA8EA;AArGA;;;AAGA;;;;;;;;;;;ACNA;AAQA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAOA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AAGA;AACA;AAGA;AACA;AACA;AAEA;;;;;;AAMA;AAGA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAmBA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AAGA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;ACjUA;AACA;AACA;AACA;AACA;AACA;AAkBA;AAEA;AAmDA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAGA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAMA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AA9gBA;AAnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAmfA;AApiBA;AAsiBA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/mBA;AAaA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAvBA;AAJA;AACA;AACA;AAIA;AACA;AACA;AACA;AAmBA;AA9BA;;;;;;;;;;;;;;ACAA;AACA;AAEA;AAWA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AAGA;AAGA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAMA;AAEA;AAEA;AAEA;AAEA;AACA;AAGA;AAGA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAKA;AAIA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AApmBA;AAHA;AACA;AAIA;AACA;AACA;AAimBA;AA1mBA;;;;;ACHA;;;;;;AAMA;AAGA;AAEA;AAAA;AAAA;AACA;AAGA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;;;;;;;;;;;ACzGA;AAEA;;;;;;;;;AASA;AACA;AAAA;;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;;;;AAIA;AAGA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;;;;;;;;;;;ACtGA;;;;;;;;AAQA;AAEA;AASA;;;;;;;;;;;;AAYA;AAGA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AAGA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;;;;;;;;;;AAUA;AAGA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAQA;AAGA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AA9KA;AAFA;AAIA;AACA;AA4KA;AAEA;;;;;;;;;;AC/LA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;;;;;;;;;AC7BA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACrFA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC1CA;;;;;;AAMA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;ACjCA;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;AC5gBA;AAaA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAvGA;AAJA;AACA;AACA;AAIA;AACA;AACA;AACA;AAmGA;AA9GA;AAgHA;AACA;AACA;;;;;;;;AAQA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAoBA;AAIA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AA+JA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;;;AAGA;AAGA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;AAOA;AAGA;AAEA;AAEA;AACA;AAGA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAUA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AAAA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AA77CA;AARA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AA2yCA;AAx8CA;;;;;;;;;;;;AClLA;AAyBA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAKA;AAEA;AAEA;AACA;AAEA;AAKA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AA3DA;AAZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AAmDA;AA1EA;AA4EA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA"}